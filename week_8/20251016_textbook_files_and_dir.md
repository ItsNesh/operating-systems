<!-- 
Generated by LectureQ (Enhanced Comprehensive Version)
Date: 2025-10-16 00:19:07
Model: qwen3:30b
Output Mode: Comprehensive
-->

I need to create comprehensive study notes based on a textbook chapter about files and directories. Let me analyze the content carefully.

The chapter is titled "Interlude: Files and Directories" from what appears to be an operating systems textbook (OSTEP - Operating Systems: Three Easy Pieces). I'll extract all concepts, theories, principles, examples, case studies, etc., and organize them into comprehensive study notes following the specified format.

Let me break down the key topics covered in this chapter:

1. Introduction to persistent storage as a virtualization abstraction
2. File system basics (files, directories)
3. The file system interface (system calls like open(), read(), write(), close())
4. File descriptors and their management
5. Directory structure and naming conventions
6. Reading/writing files sequentially vs non-sequentially
7. Sharing file table entries with fork() and dup()
8. fsync() for forcing writes to persistent storage
9. Renaming files (rename() system call)
10. Getting information about files (stat(), fstat())
11. Removing files (unlink() system call)
12. Making directories (mkdir())
13. Reading directories (opendir(), readdir(), closedir())
14. Deleting directories (rmdir())
15. Hard links vs symbolic links
16. Permission bits and access control lists

Now I'll create comprehensive study notes covering all these topics in detail, following the specified format.

I need to:
- Use hierarchical headers for organization
- Bold key terms/concepts
- Include tables where appropriate
- Provide complete explanations of all concepts
- Include every example with detailed explanation
- Create 15-20 study questions at the end

Let me start creating these notes.
</think>

# Comprehensive Study Notes: Files and Directories (Week 8)

## Introduction to Persistent Storage Abstraction

### Core Concept: Virtualization of Persistent Storage
*   **Persistent storage** is a critical operating system abstraction that allows data to be stored permanently, unlike volatile memory which loses content on power loss.
*   The OS must manage persistent devices carefully as users store important data there.

> "Thus far we have seen the development of two key operating system abstractions: the process, which is a virtualization of the CPU, and the address space, which is a virtualization of memory. In tandem, these two abstractions allow a program to run as if it is in its own private, isolated world; as if it has its own processor (or processors); as if it has its own memory."

> "This illusion makes programming the system much easier and thus is prevalent today not only on desktops and servers but increasingly on all programmable platforms including mobile phones and the like. In this section, we add one more critical piece to the virtualization puzzle: persistent storage."

## File System Fundamentals

### Key Abstractions
1. **File**: A linear array of bytes that can be read or written.
   - Each file has a low-level name (often called an *inode number*).
   - The OS doesn't know about the structure of files (e.g., whether it's text, image, code).

2. **Directory**: Contains entries mapping human-readable names to inode numbers.
   - A directory itself also has a low-level name (an inode number).
   - Directories contain `(user-readable name, low-level name)` pairs.

### Directory Hierarchy
* The file system is organized as a tree structure starting from the root (`/` in UNIX systems).
* Pathnames use `/` to separate components: `path/to/file`.
* Example directory hierarchy (Figure 39.1):
    * Valid directories: `/`, `/foo`, `/bar`, `/bar/bar`, `/bar/foo`
    * Valid files: `/foo/bar.txt`, `/bar/foo/bar.txt`

> "By placing directories within other directories, users are able to build an arbitrary directory tree (or directory hierarchy), under which all files and directories are stored."

### Naming Conventions
* File extensions like `.txt` or `.c` indicate file type but aren't enforced.
* **Important**: Files can have the same name in different locations (`/foo/bar.txt` vs `/bar/foo/bar.txt`).

> "Naming is an important aspect of computer systems. In UNIX systems, virtually everything that you can think of is named through the file system."

## File System Interface

### Creating Files
* **System Call**: `open()`
  * Flags: 
    - `O_CREAT`: Create a new file if it doesn't exist.
    - `O_WRONLY`: Open for writing only (not reading).
    - `O_TRUNC`: Truncate existing files to zero length when opened.

```c
int fd = open("foo", O_CREAT|O_WRONLY|O_TRUNC, S_IRUSR|S_IWUSR);
```

* **Alternative**: `creat()` is an older way that's equivalent to:
  ```c
  int fd = creat("foo"); // Equivalent to: open("foo", O_CREAT | O_WRONLY | O_TRUNC)
  ```

> "The routine open() takes a number of different flags. In this example, the second parameter creates the file (O_CREAT) if it does not exist, ensures that the file can only be written to (OWRONLY), and, if the file already exists, truncates it to a size of zero bytes thus removing any existing content (OTRUNC). The third parameter specifies permissions, in this case making the file readable and writable by the owner."

### File Descriptors
* **Definition**: An integer returned by `open()` that's used for subsequent operations.
* **Key Properties**:
  - Private per process
  - Acts as a capability (an opaque handle granting access)
  - Used with read/write system calls

> "A file descriptor is just an integer, private per process, and is used in UNIX systems to access files; thus, once a file is opened, you use the file descriptor to read or write the file, assuming you have permission to do so."

* **Process Structure** (xv6 example):
  ```c
  struct proc {
    ...
    struct file *ofile[NOFILE]; // Open files
    ...
  };
  ```

### Reading and Writing Files

#### Sequential Access Example (`cat` program)
```bash
prompt> echo hello > foo
prompt> cat foo
hello
```

**System Call Trace (using `strace`)**:
```
open("foo", O_RDONLY|O_LARGEFILE) = 3
read(3, "hello\n", 4096) = 6
write(1, "hello\n", 6) = 6
...
close(3) = 0
```

* **Key Observations**:
  - File descriptors start at `3` because processes have standard input (fd=0), output (fd=1), and error (fd=2) open by default.
  - The read operation returns the number of bytes actually read (`6` for "hello\n").
  - Standard output is written to file descriptor `1`.

#### Non-Sequential Access with lseek()
* **System Call**: `lseek(int fildes, off_t offset, int whence)`
  * `SEEK_SET`: Set offset to absolute position
  * `SEEK_CUR`: Add offset to current position
  * `SEEK_END`: Add offset to end of file

> "The lseek() call simply changes a variable in OS memory that tracks, for a particular process, at which offset its next read or write will start."

### Open File Table Structure (xv6 example)
```c
struct file {
    int ref;          // Reference count
    char readable;
    char writable;
    struct inode *ip; // Pointer to underlying inode
    uint off;         // Current offset in the file
};
```

* **Key Fields**:
  - `ref`: Tracks how many open descriptors refer to this entry.
  - `readable`/`writable`: Indicates access permissions.
  - `ip`: Points to the inode (metadata about the file).
  - `off`: Current read/write position in the file.

### File Access Patterns

#### Sequential Reading Example
| System Call | Return Code | Current Offset |
|-------------|-------------|----------------|
| `fd = open("file", O_RDONLY);` | 3 | 0 |
| `read(fd, buffer, 100);` | 100 | 100 |
| `read(fd, buffer, 100);` | 100 | 200 |
| `read(fd, buffer, 100);` | 100 | 300 |
| `read(fd, buffer, 100);` | 0 | 300 |

#### Multiple Open Descriptors Example
| System Call | Return Code | Current Offset (fd=1) | Current Offset (fd=2) |
|-------------|-------------|------------------------|------------------------|
| `fd1 = open("file", O_RDONLY);` | 3 | 0 | - |
| `fd2 = open("file", O_RDONLY);` | 4 | 0 | 0 |
| `read(fd1, buffer1, 100);` | 100 | 100 | 0 |
| `read(fd2, buffer2, 100);` | 100 | 100 | 100 |

#### lseek() Example
| System Call | Return Code | Current Offset |
|-------------|-------------|----------------|
| `fd = open("file", O_RDONLY);` | 3 | 0 |
| `lseek(fd, 200, SEEK_SET);` | 200 | 200 |
| `read(fd, buffer, 50);` | 50 | 250 |

## Advanced File Operations

### Sharing Open File Table Entries
#### fork() Example (Figure 39.2)
```c
int main(int argc, char *argv[]) {
    int fd = open("file.txt", O_RDONLY);
    assert(fd >= 0);
    int rc = fork();
    if (rc == 0) { // Child process
        rc = lseek(fd, 10, SEEK_SET);
        printf("child: offset %d\n", rc);
    } else if (rc > 0) { // Parent process
        wait(NULL);
        printf("parent: offset %d\n",
               (int)lseek(fd, 0, SEEK_CUR));
    }
    return 0;
}
```

**Output**: 
```
child: offset 10
parent: offset 10
```

> "When a parent process creates a child process with fork(), the file descriptor table is shared between them. The reference count in the open file entry increases, and both processes share the same current offset."

#### dup() Example (Figure 39.4)
```c
int main(int argc, char *argv[]) {
    int fd = open("README", O_RDONLY);
    assert(fd >= 0);
    int fd2 = dup(fd); // Now fd and fd2 refer to same file table entry
    return 0;
}
```

> "The dup() call allows a process to create a new file descriptor that refers to the same underlying open file as an existing descriptor."

### Forcing Writes with fsync()
* **System Call**: `fsync(int fd)`
* **Purpose**: Forces all dirty (not yet written) data for a file to disk.
* **Example**:
  ```c
  int fd = open("foo", O_CREAT|O_WRONLY|O_TRUNC,
                S_IRUSR|S_IWUSR);
  assert(fd > -1);
  int rc = write(fd, buffer, size);
  assert(rc == size);
  rc = fsync(fd); // Force data to disk immediately
  assert(rc == 0);
  ```

> "This sequence does not guarantee everything that you might expect; in some cases, you also need to fsync() the directory that contains the file foo. Adding this step ensures not only that the file itself is on disk, but that the file, if newly created, also is durably a part of the directory."

### Renaming Files (rename())
* **System Call**: `rename(char *old, char *new)`
* **Atomic Guarantee**: The operation either succeeds completely or fails entirely; no intermediate state exists.
* **Example Use Case**:
  ```c
  int fd = open("foo.txt.tmp", O_WRONLY|O_CREAT|O_TRUNC,
                S_IRUSR|S_IWUSR);
  write(fd, buffer, size); // Write new version to temporary file
  fsync(fd);
  close(fd);
  rename("foo.txt.tmp", "foo.txt"); // Atomically swap files
  ```

> "This last step atomically swaps the new file into place, while concurrently deleting the old version of the file, and thus an atomic file update is achieved."

### Getting File Information (stat())
* **System Call**: `stat()` or `fstat()`
* **Structure**:
  ```c
  struct stat {
      dev_t st_dev;        // ID of device containing file
      ino_t st_ino;        // inode number
      mode_t st_mode;      // protection (permissions)
      nlink_t st_nlink;    // number of hard links
      uid_t st_uid;        // user ID of owner
      gid_t st_gid;        // group ID of owner
      dev_t st_rdev;       // device ID (if special file)
      off_t st_size;       // total size, in bytes
      blksize_t st_blksize;// blocksize for filesystem I/O
      blkcnt_t st_blocks;  // number of blocks allocated
      time_t st_atime;     // time of last access
      time_t st_mtime;     // time of last modification
      time_t st_ctime;     // time of last status change
  };
  ```

* **Example Output**:
  ```
  File: 'file'
  Size: 6 Blocks: 8 IO Block: 4096 regular file
  Device: 811h/2065d Inode: 67158084 Links: 1
  Access: (0640/-rw-r-----) Uid: (30686/remzi)
  Gid: (30686/remzi)
  Access: 2011-05-03 15:50:20.157594748 -0500
  Modify: 2011-05-03 15:50:20.157594748 -0500
  Change: 2011-05-03 15:50:20.157594748 -0500
  ```

### Removing Files (unlink())
* **System Call**: `unlink(char *pathname)`
* **Why "unlink"?** Because removing a file means unlinking it from the directory structure, not deleting its underlying data.
* **How It Works**:
  1. Removes the link between the human-readable name and inode number
  2. Decrements reference count in inode
  3. Only when reference count reaches zero does OS free inode and related blocks

> "When you create a file, you are really doing two things: First, making an inode that tracks information about the file; second, linking a human-readable name to that inode."

### Making Directories (mkdir())
* **System Call**: `mkdir(char *pathname, mode_t mode)`
* **Directory Contents**:
  - `. (dot)`: Refers to itself
  - `.. (dot-dot)`: Refers to parent directory

> "An empty directory has two entries: one entry that refers to itself, and one entry that refers to its parent."

### Reading Directories (opendir(), readdir())
* **System Calls**:
  ```c
  DIR *dp = opendir(".");
  struct dirent *d;
  while ((d = readdir(dp)) != NULL) {
      printf("%lu %s\n", (unsigned long)d->d_ino, d->d_name);
  }
  closedir(dp);
  ```

* **Directory Entry Structure**:
  ```c
  struct dirent {
      char d_name[256];    // filename
      ino_t d_ino;         // inode number
      off_t d_off;         // offset to next dirent
      unsigned short d_reclen; // length of this record
      unsigned char d_type; // type of file (regular, directory, etc.)
  };
  ```

### Deleting Directories (rmdir())
* **System Call**: `rmdir(char *pathname)`
* **Requirement**: Directory must be empty before deletion.
* **Error Case**:
  ```bash
  prompt> rmdir non_empty_dir
  rmdir: failed to remove 'non_empty_dir': Directory not empty
  ```

## Links and Permissions

### Hard Links (link())
* **System Call**: `link(char *old, char *new)`
* **How It Works**:
  - Creates a new directory entry pointing to the same inode.
  - Does NOT copy file data; just creates another name for existing data.

> "After creating a hard link to a file, the file system perceives no difference between the original file name (file) and the newly created file name (file2); they are both just links to the underlying metadata about the file."

* **Example**:
  ```bash
  prompt> echo hello > file
  prompt> ln file file2
  prompt> cat file
  hello
  prompt> cat file2
  hello
  ```

* **Link Count Tracking** (via `stat`):
  ```
  prompt> stat file
  ... Inode: 67158084 Links: 1 ...
  prompt> ln file file2
  prompt> stat file
  ... Inode: 67158084 Links: 2 ...
  ```

### Symbolic Links (soft links)
* **System Call**: `ln -s <target> <linkname>`
* **How It Works**:
  - Creates a special type of file that contains the path to another file.
  - Different from hard links in several ways.

| Feature | Hard Link | Symbolic Link |
|---------|-----------|---------------|
| Created with | `ln` command | `ln -s` command |
| Can link to directory? | No (would create cycle) | Yes |
| Across filesystems? | No (inode numbers unique per FS) | Yes |
| What happens if target deleted? | File still accessible via other links | Link becomes dangling reference |

* **Example**:
  ```bash
  prompt> echo hello > file
  prompt> ln -s file file2
  prompt> cat file2
  hello
  prompt> rm file
  prompt> cat file2
  cat: file2: No such file or directory
  ```

### Permission Bits (chmod)
* **Format**: `rwx` for owner, group, and others.
* **Example**:
  ```
  -rw-r--r--   # Owner can read/write; Group/others only read
  drwx------   # Directory: Owner has full access; Others have none
  ```

* **Numeric Representation** (octal):
  | Bit Position | Value |
  |--------------|-------|
  | Read (r)     | 4     |
  | Write (w)    | 2     |
  | Execute (x)  | 1     |

* **Example Commands**:
  ```bash
  chmod 600 file.txt   # Owner: read/write; Group/others: none
  chmod +x script.sh   # Add execute permission for all users
  ```

### Access Control Lists (ACLs)
* **More sophisticated than basic permissions bits**
* **Example**:
  ```
  prompt> fs listacl private
  Access list for private is
  Normal rights:
    system:administrators rlidwka
    remzi rlidwka
  ```

## File System Assembly

### Making a File System (mkfs)
* **Tool**: `mkfs` ("make file system")
* **Purpose**: Creates an empty filesystem on disk partition.
* **Example**:
  ```bash
  mkfs -t ext3 /dev/sda1   # Create ext3 filesystem on device sda1
  ```

### Mounting File Systems (mount)
* **System Call**: `mount()`
* **Purpose**: Makes a file system accessible at a specific point in the directory tree.
* **Example**:
  ```bash
  mount -t ext3 /dev/sda1 /home/users   # Mount filesystem to /home/users
  ```

> "The beauty of mount: instead of having a number of separate file systems, mount unifies all file systems into one tree, making naming uniform and convenient."

* **Viewing Mounted File Systems**:
  ```bash
  prompt> mount
  /dev/sda1 on / type ext3 (rw)
  proc on /proc type proc (rw)
  sysfs on /sys type sysfs (rw)
  /dev/sda5 on /tmp type ext3 (rw)
  ```

## Security Considerations

### TOCTTOU Problem
* **Time Of Check To Time Of Use** problem.
* **Description**: Gap between checking a file's status and using it, allowing an attacker to change the state during that window.

> "The gap between the check and the update leads to a problem: the attacker (in this case, the user who is receiving the mail) switches the inbox file... The server will blithely update the sensitive file with the contents of the mail."

* **Example Attack**:
  ```c
  // Mail service pseudocode
  lstat(inbox);       // Check it's a regular file owned by target user
  append_to_file();   // Update the inbox (attacker has changed to /etc/passwd)
  ```

> "The usual (lame) advice: be careful when you write code that runs with high privileges!"

### Superuser Considerations
* **Superuser**: User who can access all files regardless of permissions.
* **Security Risk**: If attacker impersonates superuser, they gain full system access.

## Key File System Terms

| Term | Definition |
|------|------------|
| **File** | An array of bytes which can be created, read, written, and deleted. Has a low-level name (i-number) that refers to it uniquely. |
| **Directory** | A collection of tuples containing human-readable names mapped to inode numbers. Always has two special entries: `.` (self) and `..` (parent). |
| **Inode Number** | Low-level unique identifier for files/directories; often called "i-number". |
| **File Descriptor** | Integer returned by open() that's used for subsequent read/write operations on a file. Private per process. |
| **Open File Table Entry** | Tracks which underlying file the descriptor refers to, current offset, and other details (readable/writable). |
| **Hard Link** | Another name in directory structure pointing to same inode; doesn't copy data. |
| **Symbolic Link** | Special file containing path to another file; can point to non-existent files ("dangling reference"). |

## Summary of Critical Concepts

### File System Operations
* Files are linear arrays of bytes with low-level names (inodes).
* Directories organize files into a tree structure using human-readable names.
* `open()` creates/gets access to a file, returning a descriptor.
* `read()`, `write()`, and `lseek()` manipulate the current offset in an open file.
* `unlink()` removes directory entries but doesn't necessarily delete data (only when reference count reaches zero).
* Hard links share inode; symbolic links are separate files containing paths.

### File System Implementation
* Inodes store metadata about files/directories on disk.
* Directories map human-readable names to inodes via `(name, inode)` pairs.
* The open file table tracks per-process state for each opened file (offset, permissions).
* `fsync()` forces data from memory buffers to persistent storage.

### Security and Reliability
* Permissions bits control access; ACLs provide more granular control.
* TOCTTOU is a critical security vulnerability in race conditions with filesystem operations.
* Atomicity of rename() ensures safe file updates without intermediate states.

## Study Questions

1. **Explain the difference between sequential and non-sequential file access, including how `lseek()` works to enable random access.**
2. **Why does removing a file use an "unlink" system call instead of "remove"? Explain using inode reference counts.**
3. **Describe what happens when you create two hard links to the same file (e.g., via `ln old new`). How would this affect the output of `stat`?**
4. **What is the purpose of a directory's special entries `.`, and `..`? Why are they necessary for filesystem operation?**
5. **How does the open file table differ from an inode structure in terms of what it tracks about files?**
6. **Explain why using `fsync()` on just the file might not be sufficient to guarantee data persistence, especially when creating new files. What additional step is needed and why?**
7. **Describe how a symbolic link differs fundamentally from a hard link (not just in usage but implementation). Include examples of where each would fail or succeed.**
8. **What are the security implications if an attacker can exploit TOCTTOU vulnerabilities when accessing sensitive files like `/etc/passwd`? Provide a concrete example scenario.**
9. **Explain how `fork()` affects file descriptor sharing in terms of open file table entries and reference counts. What would happen to two processes that both read from the same file after forking?**
10. **Why does the standard output (stdout) correspond to file descriptor 1, while stdin is 0 and stderr is 2 by default? How might this affect a program's behavior if it opens additional files?**
11. **What happens when you call `dup()` on an open file descriptor? What are two practical uses for the `dup()` system call in shell programming?**
12. **How would you implement a simple version of the Unix command `tail -n` (showing last n lines) using only standard filesystem operations like `lseek()`, `read()`, and basic string processing?**
13. **What is the difference between an inode number and a file's path name in terms of how they're used by the operating system versus users? Why does this distinction matter for filesystem design?**
14. **Explain why directories cannot be written directly, but must have their contents updated through operations like `mkdir` or creating files within them. What would happen if direct directory writes were allowed?**
15. **How do permissions bits work in terms of the three groups (owner, group, others)? Provide an example where you'd want to set different permissions for each group and explain why that's useful.**
16. **What is a dangling reference as it relates to symbolic links? How does this differ from what happens when deleting files with hard links still existing?**
17. **Why might the `rename()` system call be implemented atomically, while other operations like copying or moving large files are not? What would happen if rename wasn't atomic during a critical operation (e.g., updating configuration files)?**
18. **Describe how you'd implement your own version of the Unix command `ls -l` using only standard filesystem system calls (`opendir`, `readdir`, and `stat`). Include details about what information each call provides.**
19. **What is a "mount point" in file systems, and why would an operating system use multiple mount points for different storage devices? How does mounting unify the directory tree structure across these devices?**
20. **Explain how reference counting works with hard links to prevent premature deletion of files that are still being accessed through other names. What happens when a process closes all file descriptors pointing to a particular inode, but another process is still using it?**