SPEAKER 0
I'm not going to release one for week 12, OK, everyone agree that that would be very meta, right? But I, I'll, I will try and post something this weekend for next week or maybe Monday next week, I don't know. Oh yeah, that's the other one, Oh we actually started? Excellent. OK. Hi and welcome to operating Systems, people at home who are listening at home. Um, today we're just gonna be going through revision for the exam, so I'll start with, uh, first and foremost, again, reminder, I can't tell you when the exam is, please do not ask, please check your timetable. If you have not studied, started studying by now, I think you've made a mistake. Um start studying ASAP, your exam is imminent. Um. Uh, what do you call it, uh, revision quizzes are reopened. What else is there? Ivan, and then, and then, and then. And then, and then that's about it. I'm not doing the housekeeping because this is a revision lecture, you guys should know you're in housekeeping by now. Alright, so the OS exam. I posted this before, it's a 100 minute, 100 mark exam, there are 120 minutes, um. You know, uh, the one mark per minute thing is kind of a vague guide, I guess is what you would describe, um, which means that in this exam you should have enough time. Like this is not an exam where you should be like really struggling to finish. I've done many exams where people are really struggling to finish. Hopefully this is not one of those. Um, generally, if, like I don't like to give a question that is worth more marks than I think I could answer the question in, in that, you know, time, like basically my rule of thumb is, can I finish the exam in half an hour and if I can't finish the exam in half an hour then I've probably stuffed up. Um, I'm pretty quick at exams, so, you know, I can, I'm asking the questions myself, so these are all things I already know, so it's a bit unsurprising that I'd be able to finish it quick, but that's basically my rule of thumb. So this exam should not be excessively long. There are 8 MCQs and there are 92 marks of not MCQs. Alright. First, we start with this slide. Are there any questions about the content of this course that you would like to ask upfront? Um, I will be going through basically the whole course in the course of 2 hours. Ah yes. Yes, the front cover of the exam does not permit you to have any paper of any kind other than. Yeah, Any paper of any kind, there is no cheat sheet for this exam. Um, I've been asked about this a lot, um, I'm, I, I am to understand that a lot of you guys have had cheat sheets in previous exams. I have never run a an exam with a cheat sheet. Um What I'm looking towards is sort of like the scientific evidence for the benefit of cheat sheets. Now I've heard people say, well, you know, by having a cheat sheet you can prepare, you know, prepare your cheat sheet for the exam and it helps consolidate your, your ideas and stuff, and I'm like, OK, that's a cool idea, you should do that. It, it doesn't necessarily mean you have to bring it to the exam. My theory is, right, and this is, this is my model, yeah, it might be true that like by constructing a cheat sheet or really, I mean you should be doing this anyway with these studies, is constructing like your map of the subjects, right, so that you know what you think you need to know. Um Is that if I set an exam that said you were allowed a cheat sheet, and at the start of the exam I took everyone's cheat sheets away, I feel like they'd all do worse. And if everyone does worse as a consequence of that, it means I think they don't know the material, right? And if my goal in life is to convince employers that you're worth employing, there is a, there is a level where I'm like, yes, I expect them to know the things that I said that I taught them. Um, and if, if that's not the case, then I think it is a waste of time. So that is my like ideological position, I suppose, um, but yes, there is no cheat sheet. Any other broad questions? Yes. Um, it's roughly evening, roughly even, I think is the easiest answer to that. Roughly even, right, I will, yes, oh sorry, I will, uh, the, the, there's more than sort of three parts, like, how would I put it, um, virtualization, like the first part, is a bigger, bigger, bigger topic, right, cause there's virtualization of processes and there's virtualization of memory and stuff like that. So that one is correspondingly a little bit bigger, and there are some questions just about, What I would call, it's not revision, but it's like the stuff that's kind of common across all of them, so like how operating systems work. Right, which is not really about virtualization, it's not really about um. Concurrency, it's more about, you know, just OS and in general, yes.

SPEAKER 1
Based on these things No, I'm not going, I don't,

SPEAKER 0
I don't, that one specifically I can, I can tell you that I'm not gonna ask you to calculate the time of a random read in a, Uh, hard drive. I think We will get to all this will answer your question. So if it's not here, if there is a calculation question, it will be here, right? Like, and I will, I will, I will, I will be upfront with what those cal the calculations I expect you to be able to do. Um, in the case of the hard drive one, I do think it's kind of a little bit, like, are you capable of doing arithmetic? OK, um, I don't know what the benefit of that is, um. Uh Yes. Will, you have what? Like a uh a practice exam. Um, no, cos I think, alright, again. One of the things that I think is really dangerous is that if you, like I mean I did this when I was a student, right? Um, like studying engineering, we used to do that where you'd be like, I'm gonna get 5 past year's exams and then study them. And the problem with that approach is that it would, you know, like it would just be the, you know, there'd be a whole section which you didn't study because you didn't have the question in the exam. Like it sort of gives you a false impression of what the dimensions of the exam are going to be like, right? And so what I'm going to present to you here is going to basically be a practice exam, give or take, but one that would go for like 4 hours rather than. 100 minutes, right? Um, so there shouldn't be anything that I haven't asked vaguely in the form of a question or a question that's sort of equivalent, cos some of these you can reword into different kinds of questions, but to give you an idea of what the content is going to be like. So the only benefit that a practice exam would give you is timing, and as I said, this exam is not particularly sharp on timing, so like. Yeah, I'm not, I'm not, I'm not super keen on practice exams, just as like, like cos I've done enough I've done enough exams to know that this is like not um it, it sort of prevents you from authentically learning topics sometimes. Um Oh sorry, any other questions before we start, and then I'll. Get onto. Alright, let's go through the material, yeah, yeah, yeah, yeah, yeah. Week one. But I didn't say week one continued. Oh god, have I made a mistake in my, my first slide? Oh, it's, it's all messed up. OK, so what happened? All right, we'll try again. OK, cool. Using these slides, oh. Right. And then no, no. Da da da da da da da da da da da na na dun dun dun da na. Uh. I duplicate these displays. Yeah, he changes. It hates me sometimes. OK. Purpose of these slides, it gives you a scope of the exam. OK, so basically I'm gonna ask questions where the answer are the things I expect you to kind of know, right, so this is my way of saying this is like the, the space in which exam questions exist. They are not. Exam questions, right? All of these questions are really vague, right? Well not all of them, some are more specific, but broadly speaking they're a little bit more vague. In an exam, I'm usually very precise with the wording of what I'm going to ask you to best elicit the thing that I'm going to ask you. In computer science, in my experience, I have seen many exams where there are questions, and you will look at the question, and you'll be like, what? And then you'll answer the question, based on what the question looks like. Then you'll see the answer and you'll be like, yes, that is one way of interpreting the question. Damn it, it was not the way that I interpreted the question. So, these are, these are more vague ones, right, so it's just, the idea is to elicit. What kinds of things you're gonna be studying about, right? Um, and yeah, a lot of this stuff is not gonna be in the exam because, my trick here is to make you think to learn things that aren't necessarily in the exam because I just want you to know things and you can hate me if I've made you understand the world better, that's your, your decision, but you know what I mean, it doesn't matter. Alright, so let's go. You know, what is an operating system and what does it do? Being able to say, oh yeah, it's like a process that runs on a computer that manages other processes, is something that I expect that you should know. Um, what is virtualization, and you know, what is virtualized, right, when we say that something is virtualized, you know, like, so in this kind of case I'm, I'm looking for things like, do you understand what, You know, the, the, the process of virtualizing, so you're going, oh well, each process should be looking at a computer and pretending it's running on the computer by itself, and this includes things like, you know, CPU or access to CPU, access to memory, access to peripherals, all that kind of thing. Um. You know, like, uh, abstraction, so like if we're talking about abstraction, what we're looking at is we're talking about things like, oh, OK, well, if every operating system needed to know the, the intricacies or every process needed to know the intricacies of every little bit of IO or every other process or every other bit of um computation or hardware within an operating system, every process would, and every programmer would be like losing their mind because they'd, every time someone changes the peripheral, they'd have to change their program. That's the kind of space that abstraction is talking about. Um, give me an example of OS abstraction, that should be fairly straightforward based on what I just said, but you know, like we abstract lots of things, so you know, like, um, a hardware device is just, you know, a couple of registers that you read and write from and you sort of treat it like a file. Everything is a file is a really good answer to that question, although it's not a very explanatory one, it's a nice meme, but you probably want to explain what that means, um. Why must OSs provide protection, protection from what? This is where you could give an example of two operating, you know, two processors writing over each other's memory and causing chaos. Um, I have two processes on one machine, that's basically the same question, what could go wrong? All kinds of things. Um, they could interrupt each other. One of them could starve, the other one for, um, the CPU permanently and be like, I am the king process, I will never finish. Um. What is a process, what is a program, what is a thread? I mean this should all be revision from systems programming, but that's not a prerequisite anymore, so being able to just really articulate what a process is, right, like, like what what what does it mean? What does it contain? what are the parts of a process? Um, how do they interact with other processes? What is, what is a thread as opposed to a process? That's a little bit nebulous, right, like, because we, we know that basically threads are kind of like processes, but when you kill a process. It kills all the threads associated with that process, which is maybe a little bit different from a process which creates another process which could run sort of independently of it. So there's a few, you know, little nuances there, and you can use those as your descriptions or ways of explaining the difference between them. Knowing the difference between a process and a program is very important. One is something that someone has written, one is something that is currently operating, something that someone has written, but it is also represented by, you know, having memory associated somewhere in a computer and having access to the CPU and running instructions and all those kinds of things. Um, what is a process control block and what does it contain that's worth revising, like, as in what are the parts of it, because it's quite a reasonable question, like what are the things that I need to keep track of for every process, so that if I wanted to switch from one process to another, what are the things I'd have to think about? And in that case we'd be talking about things like stack pointers or program pointers and, you know, memory and bases and bounds and a whole bunch of things like that, um. Explain what happens when I switch from one process to another. OK, so what's going to have to change, right? Here's an example, you know, like, oh, I have this one process and now I need to change to this other process. There's a whole bunch of things loaded in registers. There's some other things that I need to transfer into memory. I need to store this, this, this, this, this and this. I need to chuck all that out. I had to put the new process in, I need to put all of this stuff back in. Um, it doesn't have to be at the highest level of detail, but it is good that you have at least got a description where you are understanding parts of it. Um, what are the three main processes and queues, and what do they do? So this is where you're talking about things that are ready, things that are running, and things that are blocked. And, you know, why do they exist? Why would something be on the block queue? Why would something be on the ready queue? Why would something be on the running queue? How would it change between them? Which ones does it make sense to change between? Right? Um. Week 12. What are some pretty important registers that processors definitely need, right? Stack red stack, stack pointer, stack pointer, process pointer. And why, why, why would you need them, right? Like why would you need a stack pointer? It's like, OK, well if I don't, I can work out where in the process I am, you know, like as in I can go, I'm going through the program, right, and I'm, I'm on line 521, but if I don't know where in the stack I am, that's not very helpful, um. I really have to close my, my teams at some point. Um, what does starting a process look like? Like what's gonna happen when the operating system starts a process? Well, it's gonna have to start reserving some memory for that process. It's going to have to construct some data structures to, you know, con, you know, like a process control block amongst other things in order to start that process. Ah, how do you kill a process and what does that mean? What's the consequence of it? It's more along the lines of, you know, like, What if I had the process and I tell it to kill itself and it refuses, what would happen? You know, that kind of thing. Um, it would make it really, really annoying and, uh, the computer would probably crash, um, kernel mode versus user mode. What should be run when, what is this distinction, why do we need to make the distinction? Why would it be bad if we did not have this distinction? Um, what would, what would be the direct consequence of that? Like what motivated it in the first place? What is it, what is direct execution? What is the alternative, and why might we bother with direct execution, and then what about limited direct execution, what's the distinction between those two kinds of ideas, right, like as in. For direct execution, obviously we're saying, well, I want to be able to use the hardware directly rather than every time I do anything having to consult the CPU but at the same time, the problem is if I give you access to the hardware, you'll destroy my computer, you bastards. Right? And so I need to work out sort of a gatekeeping mechanism where I, the kernel can do things on your behalf and then use the hardware directly. Um. What is a trap? What is the opposite of, like this question will come up in like any topic. What is the difference between interrupt and polling, and what is the difference and what is the benefit of each of them? Um, it doesn't necessarily have to come up in this topic. I mean it, it applies to so many parts of operating system. Should we use polling or interrupts? It depends, right, on the context. Which, which, what are we actually going to do it with? Like, is the, the hassle of setting up the interrupt system sufficiently large that we could just poll for a bit and then maybe interrupt later. Um, explain how a system call works, what is a system call. So being able to draw a nice diagram of explaining how you get something out of memory which you're not supposed to be using. What are registers for and why are they important for an OS? I mean that's, that's a computer systems question, but I do expect you to know it, it's not. Um, it's not a question I'm likely to answer, ask in an exam, but it's something that I would expect you to know, and if you know it, it'll make the exam easier, maybe. Um, what is a stack point or a program counter? How do I decide when to switch processes, right? Like, what is the mechanism? Like, OK, so I have two processes. How should I switch between them, right? Like, as in, as an operating system, theoretical question. I have multiple processes, how would I switch between them, um. And why would I never let processors decide when to do switches, right? You know, like what would be the, the case, what would happen? What like I could ask you, you know, like I've decided to create a system where processes can dictate when they're finished. What is the problem with this system? Um, and how do I stop a wayward process? So like let's say that I have a process and it is running and I hate it. How do I actually kill it? What does that actually mean? Um, All right, that's the end of week one. Any questions about week one? Yes. That's a good question. How do you kill a process? Alright, well, basically what you do as the operating system, the operating system gets to um, When it's running things, the the operating system is doing the, the scheduling, right? And because it's doing the scheduling, there is a bit where the operating system gets to intervene a bit, right? And so you get the, you've got this like array of um signals, right, that will go in for each process, and then before it gets. It's allocated, it will check that signal buffer and it'll be like, hang on a second, it says kill you, right? And then it'll be like, well, I'm just gonna deschedule you because I'm in charge and I'm the operating system and I get to do things every so often. So it's basically in the gap where it's scheduling things, the operating system gets this little bit of runtime and inter uh the what do you call it, signals, you know, populate a little set of registers where it can go hang on a second, and then you're, you're done. And then all I have to say is that you don't have that memory anymore and you don't get um allocated to the CPU. So killing is not even really killing, it's just like, it's more like uh just abruptly not it's, it's, it's, it's sort of a bit more like kicking someone out of a club than it is um killing in any um nominal sense. Uh, any other questions about? Yes. Yes Yeah, no, basically, there's a lot of, there's a lot of, up until this point in time, this is sort of like the precursor to scheduling, right, like as in the stuff that's, I don't really consider it to be scheduling because I haven't really talked about scheduling yet, right? But it's all like, And yeah, what you would need to do to even start asking the question about scheduling, yes.

SPEAKER 1
Questions where it's like getting out to the nitty gritty of like can we take processes AIDS registers and we store them.

SPEAKER 0
I will not ask you to say where they are in memory, but I would ask you to be like, OK, well I would need to store registers, right? Like, as in like, you know, for example, if I said I, you know, a question was like how do you switch processors, it'd be like, OK, so what do I need? I need to, I've got stuff loaded in registers, I know that. It probably has some space in memory, I know that. Um, do I need to shunt that memory out to storage? Do I need to take that register and store it somewhere in a nice place in memory where I won't lose it so that when I go back to that process, and just having an idea of those, that sort of mechanical sense of what actually needs to be done, um, is basically it.

SPEAKER 1
All right.

SPEAKER 0
Week two, virtualization. Alright, so, uh, what is virtualization? What does it mean? We've already covered this question, but you know, like, I, I was going through my lectures basically going, here are questions that I think are reasonable. What is the difference between scheduling and dispatching, right? Like, that's a reasonable question, right? Like the way that we do dispatch can be quite different from the way that we do scheduling, right? Scheduling is about who gets to go first, Dispatch is more about like, how do I do it, right? Um, or how do I even run one thread or 11 process. Um, oh yeah, yeah, so basically knowing your basic definitions about things that you want to maximize and minimize when it comes to scheduling, so knowing what turnaround time is, knowing what response time is, knowing what waiting is, all those kinds of things. Um, also knowing about, you know, like having it in your, the back of your head that context switches are not free, right? So that's something that we also might want to minimize, the number of context switches. Um, throughput is the other one, I, you know, like throughput's the obvious one, right, like it's like I'm scheduling, I wanna get lots of stuff done, right? Like that's probably my main one, but like it's not one we ask you to calculate. Um, yes, Gant chart, Gant chart, right? Everyone understand Gant chart? If I just say Gant chart, right? Do I have to go to more effort than to say, I ask question, you make Gant chart, get marks, alright. Um, This is one of those ones which is a calculation, right? Um, OK, uh, round robin, shortest time to completion first, shortest job first, shortest time to completion first, again. OK. First come, first serve, FIFO, I don't know. Um, one promise I have made is that if I ask you to do shortest job first or shortest time to completion first in the exam. Then I will tell you which one is the preemptive one, because I do not think it is worthwhile memorizing that these two algorithms with basically the same name refer to different algorithms, right? So I will tell you which one is preemptive and which one is not. OK? So you don't have to, I don't know, lose that one. But basically I do expect, you know, if I say please implement a round robin blah blah blah on this set of jobs with an epoch of 4 or. Window time of 4 or something of 4 or 3 or 2 or whatever um what would happen and there are you know there are, do I have it here or maybe I don't. But you know, like I might also ask, oh yeah, no, I guess it's wrapped up in the next one. so you know, the questions that you have about each of these algorithms, you know, like what is good about them, what is bad about them, when do they always fail? Like with round robin, what if I make the time epoch bigger, what if I make it smaller? Uh, what is the convoy effect? Which of these algorithms suffers from the convoy effect? Which one could cause starvation? All of those kinds of questions. There's more than that is just there, but it's basically, you should be able to talk about every. Scheduling algorithm and basically go why does this one suck and the consequence in which it sucks, and when is it reasonably OK, right? Um. What is a multi-level feedback queue and how does it work? What problems is it attempting to solve? My expectation here is really just there are multiple cues, they have different time epochs, maybe draw a picture, explain what might happen in order to make it work. Right, like why would something go up in the level, why would something go down, and that's about it, right, I'm not expecting anything more sophisticated than that. Um, and yeah, what problem is it trying to solve is another one, like why would you need one in the first place. Um, lottery scheduling, what's the idea, how does it work? I give everyone tickets. Completely fair scheduler. What is it? How does it work? Um, it tries to balance across the, you know, in a pocket and it says, oh, OK, I've got all these tasks, you're gonna get 50%, you're gonna get 25%, you're gonna get 10%. Um, what is priority 4? Um, give an example of an algorithm with preemption versus non-preemption. Why is this important? How would this change things? Um. Can you get starvation without preemption, hm, maybe, maybe not. Uh, what, what, you're definitely not, sorry, I'm still teaching, right, so I should say, yeah, you can't get starvation unless there is some kind of, you know, um, preemption. Um, what problems does each algorithm solve or cause? Well, I guess you could get starvation without preemption, because you could just have a whole bunch of short jobs. You need, you need to change the priority, basically, you need priority, it's better to say you need, uh, you need, uh, you can get starvation if you have priority is a better way of describing it. Uh, what problems does each algorithm solve or cause? Yeah, that's fine, I've already been through that. Multi-CPU, what works, what doesn't? Oh yeah, so if I ask you, like if you have multiple CPUs, right, and you're going to schedule them. Should you have like multiple cues or you can have one cue, and if I have multiple cues, what's gonna go wrong, and if you have one cue, what's gonna go wrong, and what would be good and what would be bad? Um A lot of that you can sort of think your way through, I guess, um. Alright, week 2 is done. Questions about week 2. Yeah, yeah. Convoy effect. Yeah, the convoy effect occurs when you've got a whole bunch of short jobs and they're basically coming before, oh sorry, not a whole bunch of short jobs. I'm being stupid, that's starvation. The convoy effect is where you've got one giant job and then you've got 100 little jobs and they're like da da da da da da da and they're like, I could finish right now, I could, I could finish right now. Um, and yeah, that's the convoy effect. Yes.

SPEAKER 1
I think the shorter.

SPEAKER 0
Yeah, yeah, just imagine a tractor on the highway, right, and you've got some really slow job destroying everyone else, right, because they're just like, I could get done in the next 2 seconds, but there's this other job that I have to wait 10 days for, and so my response time sucks, and my turnaround time sucks even though my actual execution time is tiny, um. Yes. All right, uh, memory. Wait, oh sorry, more questions, more questions before I start week 3. Alright, memory, memory, I have bytes. I have bytes. How many megabytes are in a byte? I expect you to know the answer to that question. I'm not gonna ask you how many megabytes are in a byte, right? I just, you need to be able to answer this question in order to do some questions, OK, so it's like meta. I don't know. Um, uni programming versus multiprogramming, like, like. Why, what is this, you know, how does this relate to memory, you know, like if I have one program or multiple programs, what are the minimum requirements for multi-programming? Draw a stack, a heap, explain how it all works. Why is the heap annoying, why does the memory management unit, what does the MMU do? Um, yeah, so this stuff's all like precursors, so it's a bit like the week one stuff where we're like, in order to have a conversation about memory, you should be able to answer these questions. They're not necessarily exam questions, but like you need to know this, um. How do we stop two processes from colliding with each other in memory, right? And this is where you go, oh well, we need to, you know, base and bounds, or we need to do segmentation, or we need to do paging, or we need to do something, right? Like, um, we need to measure, you know, the areas in memory in which they're allowed to have, you know, fundamentally. Um, base bounds, what is it? How does it work? Good or bad? What issues could arise from poorly written system calls when considering process memory access? Ah. What is that referring to? Does anyone know? So, if I have a system called that allows me to, Give it a pointer to a string, or some other kind of array, right, and I just keep reading, yeah. And I give it a like a little crappy, really long string. Right, and I say, oh it's, it's only like uh 29 million characters long, and you'll be like, oh no, no, I take a pointer and a, a piece of it, OK, I'll write that into somewhere into memory, yeah. Right, that's what that's referring to, so that's a sort of more a security kind of thing. Um, segmentation, how does it work? Is it good or bad, why is it good or bad? Uh, multi-threaded segmentation, how would that all. Play out, um. Paging, yeah, obviously how does paging work? What is paging? Why do we do paging, what's the benefit of paging? What's the really big disadvantage of paging? Um, internal versus external fragmentation, this is gonna be covered in like almost every topic because. It happens in so many of these things, um. What is the advantage of a big page, what is the disadvantage of a big page, big page versus a little page, what is the like the logic behind defining how big a page should be? Uh, page tables and addressing them, yeah, OK, you may get some questions that look like this.

SPEAKER 1
Right? Oh yes. Hm OK, so the question is, in week 2, if

SPEAKER 0
I go back to week 2, there's a question about the heat. That's a no no no no no. Why is the heap annoying? Oh OK. Why is, oh yeah, why is the heap annoying? So I mean the main reason why the heap is annoying is because it results in fragmentation. Right? Um, because whenever you have something in a heap, you can add things to it and take things out of it, um. And you end up with all these little bits of heap memory that have all these holes in it, so it's not ordered and tidy, and so it's really hard to keep track of, and it means you end up with a lot of internal fragmentation. Right, where there are these gaps that you can't use because you stored an integer there and now you need to store an array, and now you've got to try and work out how to get that array, that kind of thing. Oh, alright, where was I to? Base and balance, paging, internal, yeah. The table, yeah, OK, so basically, you know, like I'll give you some addresses. It will be in hex. I'm not gonna write anything in binary, um. That may require you to do some decoding of HEC, uh, so you do need to know that HEC is 0123456789, A, B, C, D, E, F, right? That just needs to be a thing that's drilled into your brain. Um, page tables and addressing them. So yeah, I might be like, hey, I have, I have this address, I'm gonna be using paging. If I do, I'm gonna tell you how many bytes there are and how many bytes there are uh like how many bits there are per page, or at least I'm gonna tell you how big each page is in maybe in megabytes or kilobytes. Probably not megabytes, um. And yes, I could ask you potentially to do a single level or a multi-level page table, so I would suggest, That you familiarize yourself with what that process looks like, because then I'll be like, what is the final thing, the final address, the final frame number going to be looking like, that'll be what that question looks like, um. All right.

SPEAKER 1
B 3. Yes. So. Process and it's a process. Are they stored? So separately.

SPEAKER 0
That is a good question that I don't know the, I, I suspect they just stored in a page, right, that the, the operating system knows where that page is, right? Um. control box. I'd have to revise that. That's not gonna be a question in the exam, obviously because I don't know the answer to it. No, no, that's a good question. Um, yeah, like, presumably that, that, well, how could you do it? That, you could either have dedicated registers, or not registers, but you know, dedicated memory for storing process control blocks or they would probably just be in a memory, in main memory somewhere, and then you would have to. You know, the operating system would have a, a, you know, somewhere it goes, well, this is where I store all my process control blocks, and then it would be able to find them that way. Yeah, and that would, that would, that would just end up being like lots of memory addresses basically, plus, you know, stack pointers and stuff, um, stack pointers and uh program counters, yeah. Yes. The You would like a video. Calculator. I think you're allowed a calculator in the exam. Alright, this is where I need to be really careful not to show you anything more of the exam than I should, which means I'm just going to, I'm going to press the button that says installed PC. OK. We're gonna try and do this without like having forcing me to rewrite the exam. OK, no one can see anything, right? OK, no one can see anything. And this is my password fortnote, um. Alright, where is That's systems programming. That's OS. OK, so this is the bit where that's the dangerous bit, that's the dangerous bit, that's the dangerous bit. OK, this is where I'm sorry, I'm gonna be really paranoid about this. I'm going to print screen. The front page of the exam. And then I'm gonna close the exam. All right, we're all good. I, there's no way now I can show you anything that is inside the exam. All right. Uh Exam picture. All right. So, now if I press, OK, double-check, there is no exam anywhere. OK, cool, alright. Just to be sure, alright, so this is the really high quality picture of the front of the exam, right? As you can see. Um, answer 6 questions. So the 6 questions you like the, the, the exam itself is gonna be broken up into sections, right? So when it says questions, so example actually it, it's more than 6 questions, right, it's, it's, it's more than 6. And the first of those 6 questions is 8 multiple choice, we get what's going on here, right? Uh, it's closed book, write all the stuff, don't. Don't steal stuff. You're 3rd years, right? Please don't just do an exam. It's not that complicated, right? Um, that next section, but like paper translation dictionary, paper dictionary, drawing instruments or rulers, calculator. Uh, you can take both a calculator and a simple calculator that's my mistake, without alphanumeric memory. Alright, so that should just read, you can take simple calculator. And by calculate so you can't then be like oh well it said I could take a calculator and a simple calculator. It's just a simple calculator, alright. Damn it, I didn't notice that, but yeah, it's, it's gotta be like one of those like ones you give to like. Eight year olds in school where they're like 2 + 30 look, and then goggles upside down, whatever, right? Um, or hello. All right, there we go. Hopefully that answers that question. Alright. Any other questions? Oh yes. No, it'll be, it, it's more that you should be able to turn um HEx into binary, right? Like as in that is the calculation that you need to do. I might actually, you know, like, I'll, I'll, I'll, I'll. If I have time at the end, I may just do one of these questions, I will just make up a question and then I will just do one of them to give an idea because there are some tricks here that I don't think I really covered in great detail in the lectures that are supposed to have been done in the tutorials, but eh. You know, it's a tutorial, um, alright, uh, any other week three-ish questions? Alright, week 4, paging and stuff. Alright, so we're gonna just talk more about paging obviously. What is the big problem with naive implementation of paging? Too much space, right, so the biggest problem is that the page table is enormous, right? Um, the other problem is that like, as soon as you start like looking for things in pages, pages, you start going, is it here? Oh, I've got to go to the page table, and then I've got to go from the page table to the page, yeah. Right, and if it's multi-level, you have to do that a bunch of times. So it's both slow and the page table of a single-level page table is enormous. Um, often bigger than the computer itself. Um, what is locality, how does it apply to paging, so really just understanding the basic concept of what locality is, whether it's spatial or temporal. Um, what is caching, how can we use to improve insert topic, right, like, basically the idea is, you know, do you know what caching is? Um, and you know, like how would it apply to this particular problem. Uh, for example, the translation look aside buffer, the thing that I stuffed up in my lecture with the titles, I've, I have now gone back to my old lecture slides and updated them. I don't know if I've updated the one on the website, I might do that. Um, translator shouldn't look translate translation look aside buffer. What is it? How does it work? Why bother? Um, and do you know how to calculate what a miss rate is? That seems like a fairly easy thing to calculate. Um, is the. I'm gonna give you a series of numbers. I can guarantee you that I will give you a series of numbers at some point in this exam. So, um, and then I'll be like, what is a page fault, how does it resolve? Demand paging, page fault happens, what you need to do? Yeah, so basically trying to describe what, when, when there is a page fault, what's going to happen afterwards, like like. Um, what happens if you hit, what happens if you miss, um, and this is referring mostly to things like, oh, OK, so I had a page file hit. I was in the middle of doing something. Where's the program counter going to be? Because do I, have I finished that instruction now that it didn't work, or do I have to go back on instruction, and, and where does that lead me, um, to potentially nasty places, um, page replacement and TLB replacement. They're basically the same, one of the big differences I would say is the implementation of page replacement because there are more thoughts about pages, like things like copy on write and dirty bits and stuff like that, um, than there is for TLB replacement which is really just a, a list of things. So page replacement is a more complicated topic, but for the purposes of calculation, they are virtually identical. I'm not gonna ask you to do the clock exam, uh, the clock algorithm in an exam because that's weird. I don't know how I would do it, um. Or random, I'm not, well, actually I have thought about how to do random, right, there is a way to do random, um, but yeah, optimal, FIFO, explain to me how they work, right? Um, and maybe apply them to some numbers, do a thing, right? Um, OK, where are we next? What is thrashing? How do we tell that thrashing has occurred? What are guard pages? You know, like when I fork a process, copy and write, what does that mean? What would happen if I was trying to. Um, if I had distributed machines and I've got, you know, I've got processors running on multiple machines, where's that going to, um, run to, um, and things like what are, you know, present bits and dirty bits and. There's a few other bits, I would suggest that you just get familiar with what those bits are, um, present bits, yeah, there's another one, Those are the main ones. Alright, uh, week 4, yes. So, so a guard page is a page that you put between um processes basically and you can say that oh this page is not actually part of any other process and so ha ha, you went to my guard page. And so you can sort of um use them and they can act as like I think a security buffer between processes just in case someone has written bad code cos it's sort of like it's this place where people can oh you wrote it to a guard page, I don't care. Right, and you can make them invalid so that the operating system's like, well, you just wrote to a guard page, you jerk. Um, and you can also do it, I think like within processes, you can do similar things inside processes so that like if you've got multiple stacks and heaps that they, they play nicely with each other, um. All right. Week 5. We've covered, we've now done the first. 30 to 40% of the exam. OK. Other than the multiple choice questions, uh, da da da da da, concurrency, atomicity, what is it and why problem, right? OK, so being able to explain in very simple terms, an example of something that is atomic and something that is not atomic is something that you should just be able to do. So you'd be like, oh, OK, I have this thing. Uh While I want to do these two things, someone comes and slaps me. Ah, so I can't do the second thing, right? Um. You know, that that's basically what atomicity is, race conditions. An example of race con oh yes, uh.

SPEAKER 1
example Yeah. Yeah, so, um, well, none of them are really, like

SPEAKER 0
that's the problem, like no, no operation is no operation on a computer without hardware backing is really atomic, right? Because every, you know, like. Like, OK, let me think. Read from a register, right, you know what I mean, like you're like this is a pretty subtle, you know, small action where you're like, OK, I will go to memory, I will grab memory, I will put it in a, ah shit. Right, you know what I mean, right, like there's a, there's pretty much no really atomic. You know, they probably are, but from the operating system's perspective, not really, right, like as in you, you just have this thing where everything is going to take, you know, one or anything that you want to do that's useful is gonna take one or two, at least two things to do, usually. They're very, maybe you could increment a number already in a register, but no one writes programs like that except in Assembly. You know what I mean, right, like.

SPEAKER 1
I grab the register and I got it now.

SPEAKER 0
Yeah, yeah, you could probably, I would, I would say that loading something from memory to a register is probably atomic on most systems, right, like as in there's there's not much you can do to interrupt that process, cos you're basically going on this clock cycle, there are some numbers, they're going along wires and they end up in this other location in memory, right? And so that would happen on one clock cycle and so that would probably be an example of an atomic, um. Action, but that's sort of like hardware level, kind of a, you know, you know what I mean, like that that's in assembly somewhere, and so it's not gonna be in any program that any normal person writes, unless they're writing an assembly program. Yes.

SPEAKER 1
Yeah.

SPEAKER 0
Yeah, yeah, yeah, exactly, right, like as in, so what, what, what you, you would do for a non-attomic process you would, you would do say X equals X + 1, and you'd be like X equals X + 1 is actually 3 different instructions, right? Um, and then you would say hopefully each of these individual instructions are atomic actions, right, but because, because they're all individual actions, they're the smallest actions that you can do, which is, you know, I think moving one thing from one, you know, register to another is about as atomic as you can get. But you've gotta hope that that's how the system actually does it, it doesn't like have a fake secret register that you don't know about or something like that. Um, But basically what you would say there, an atomic action is this set of actions cannot be broken apart and we can do that by mutexes, so yes. Yeah, it's done or not done, so the example of using locks is a good example. I can use locks to enforce that these, all these 3 operations can only ever occur if and because there are locks, it now becomes an atomic action. Would be a reasonable answer to that question. Uh, race condition. Uh, I get lots of weird answers to race conditions in exams. I'm just gonna sug suggest, oh yes, sorry. It Oh, X equals X + 1 is not atomic. Right? Because X equals X + 1 is, I shall load X from memory. I shall load 1 from somewhere, I shall add the 1 to the X, and I shall put the X back into memory. Right, right, and that's 3 steps, give or take, right? Yeah, it like uh in a hardware system an atomic action is basically going to be, I think, right, like it, if you think about it, it's gotta be like wires in one part of memory transferring something to other part of memory, or I think you can just increment a number like so like, um, for those of you who done computer systems, right, like when you do add I or something like that, right, where you're like, oh I'm just gonna make this number too bigger. I reckon you can do that pretty atomically because you're just like register, change value, right, you know what I mean like it on one clock cycle it's gonna come through and go through, you know, like the, the value will go somewhere and the addition will happen as one big um action, yes. Yes, if you were writing in C, it pretty much there is nothing you can, well, I mean there probably is a few things that you can do, but like I, I don't know what they are. Like I'd have to think really, really hard of an example of something that's in something that is C code, that is, is definitely atomic. And I would not be able to guarantee that because it goes through a compiler that could screw you on the process of getting there. Um Yes.

SPEAKER 1
Yep. Yeah. Yeah.

SPEAKER 0
Well, OK, so the, the, the key, the key takeaway of atomic is that what I wanna say is I want, there are, in order to, in order to get some functionality to work, I might need it to be atomic, right? And most things are not. So I need to force it to be atomic, and hence I need locks semaphores or condition variables in order to achieve that goal. Right, so that's sort of the, the way that I think about it, it's like. I have some purpose where I, you know, like the algorithm demands atomicity, right, cos that's what it really is, it's like, I can't, you know, the, the, the logical thing I'm trying to do must be atomic in order to work, if it's not atomic it will not work. The tools I have are not atomic, therefore I need to use atomic tools to turn the tools I have into atomic, um, things, and that's why all these fun, you know, test and set and all of those, um. Unnecessary. Alright, alright, alright, alright, where are we up to? Um, race conditions. Oh, for race conditions, I suggest that you just memorize a really simple one, like, you know, I have one thread, and it's trying to add 1 to this number, and I have this other thread and it's trying to multiply it by 2, and then you'd be like, well, if I multiply first, or I add first, the result will be different. Excellent. Um, I often, because, um, I remember in systems programming, the example I used to use was always like, I have 100 threads all incrementing X by 1, and you're like, I understand what you're getting at, but trying to write that in the exam is really, really annoying cause they're like, well, actually technically, if I have 100 threads and you're like, OK, OK, OK, I get the idea, but like much easier to just go, I have the value 5 in a register. And I want, I want, I have one thread that wants to multiply it by 2, and another one that wants to add 1, and then you're like, it will either be 6 times 2 or 10 + 1, right? Um. Spin lock, here code, so there could be an example I've given you some code, it's got a spin lock in it, and I'm like, hey, is this atomic? Yeah, right? And then you can be like, oh, but what if something happens between the spin lock, right? Um.

SPEAKER 1
Yes.

SPEAKER 0
Generally just theory. I do not think I have any questions where I explicitly ask you what is the null pointer in or the void pointer as the fourth parameter of P thread create 4, and why does it exist? I mean, at this stage you should all be able to answer that question, I think, right, because of assignment 3, but I, I don't ask questions like that, um, usually, unless it's a subject in which being able to program in C is a direct outcome of the course. Yes. Yes. Oh no, no, no, no, no, no, if I've written code like this, it's gonna be like concurrency broken, right, if it's in the concurrency section, it'll really be a case of like, or like, you know, like um. no no I'd draw some locks, right, and then you'd be like, OK, so will this cause deadlock, right, is a, is a good example. And you'd be like, oh OK, well if this is this and this is this, then this will, this, this thread will have something, that thread will have something else and it'll all go to hell in a handbasket. Yes. You should be able to write a minimal version of a conditional variable producer consumer. Yeah, or a semaphore, right, like so you should be able to basically go, this is how I would set it up in order to write a conditioned variable, this is how I would set it up in order to write a, a pro a simple program with a semaphore. Um Ah, OK, so it will all be pseudocode, right, so don't worry about initializing variables, and don't worry about saying I have defined this lock, but you might want to say I have a, you know, like, Oh, like, don't worry about like if if if you have a variable or something like that, don't, don't worry about giving it a type, just, you know, like. If there's a lock and you need more than one lock, it's useful to say I have two locks and they're called A and B, right? You know what I mean, right? Like there's a level where you're like, in order to convey the minimal information, you kind of do need to initialize some parts of it, right? Like as in, but it doesn't have to be syntactically correct, you don't have to be like I. Nah, nah, nah nah, none of that stuff, it would just be like I have lock A, B, you know, lock A, unlock B, right, and then put it in my code, right, and then write to processors and they have to try and exchange a variable or something. Um. Here's some code where there's a break, please fix. Disable interrupts, does it work, why bad? Alright, so like like could you achieve ethnicity by disabling interrupts? If you did, would it be good, would it be bad? Peterism's algorithm, how does it work? Um, basically. Um What is a memory barrier and why is that useful, um. Yes. A memory barrier is basically where, You have an instruction and a piece of code that says, compiler, no matter what goes on, you must execute everything before this, before you do anything after this. Right, and so the compiler can't be like, well, actually technically I could do it faster if I, right, you know, uh, and then give you code that would violate one of the ideas behind your code, right, cos compilers try to optimize, and they will rearrange instructions if they think they can do it all faster. Theoretically they shouldn't be breaking a code, right, but a memory barrier is just a very explicit way of saying. All the code up until this point must be executed, every machine instruction associated with this code must be executed prior to anything after this being executed. Um, and so you could use that to kind of enforce some kinds of atomicity in a really kind of ugly way, but it wouldn't work for multi, multi-threaded programs, right, it would just, it would work well for a single threaded program, um. Testing set, I expect you to know what it does. And maybe be able to do something with it. Same thing for compare and swap, right? I don't think this is particularly onerous, um, cause test and set says what it does, and compare and swap also says what it does. Um, how can it be, what it, how can it be used to make good? You can see at this point in time I had lost grammar. Um, ticket locks, what are they and what problem are they trying to solve? Um, why do sometimes we have an extra lock, right? Like, so the guard lock in a lot of the examples, being able to explain what the need of a guard lock is. And this sort of goes into this idea of, you know, like, well, can I have these like multi-locks where I have some lock that controls all the other locks and then you're like, oh, how many locks do I really have? Um. Which is better, a spin locker or a blocking a process? Um, and then what's the trade-off between those two? There is an explicit answer to that, which is to do with how long does it take to do a context switch versus how long do you expect to wait. Um, condition variables, I expect you to be able to basically make a condition variable something, right? So, uh, you know, someone is dumping information into a thing and you are reading off, how would you set up the condition variables? Um. Write a simple multi-threaded program which is a mutual exclusion of some form in pseudocode, so that would be the, the coding question. I can guarantee you there is at least one of these questions in the exam. Uh, produced, huh? At least one coding question. Alright, um, you can determine from the rest of the questions that I asked throughout the thing whether there would be reasonable coding questions associated with them. But, um, yes. Um, producers and consumers, what's going on here? Like what are producers, what are consumers, what is the problem that could occur? What happens when you have multiple producers, what happens when you have multiple consumers? How could that be a problem? How could you manage it? What would you do in order to achieve this, right? Um. Any more questions about week 5? Excellent. Semaphores, yeah, they have numbers, woo, that's it, right, um, this lecture also covers, you know, like, Sort of what is the difference between semaphores, locks, and mutexes and condition variables? Also what is deadlock and what is livelock? What are the four conditions of deadlock? Real question, um. There's also the do a table. If you go back to my lecture, oh sorry. No, that's, that's unreasonable, um, it's more a case of like being able to articulate the fact that you could, and what the difference between them is, but going through the effort of like one of those is basically a research level question. So that, that, that seems a bit Mickey Mouse to me in order to get you to do it. It's not, it's not like, not every conversion is obviously straightforward, so it's not makes, it doesn't really make sense for me to ask that question because then you could just prepare that question and you're just regurgitating nonsense. Well just saying that, you know, like, you know, uh what is the difference between them, and then you can, you know, articulately describe the fact that, actually, they're pretty much equivalent and you can build them out of each other, right? You know, it'd be the sort of piece of information that. That question is meant to evoke, um. Yeah, here are some code, deadlock, not deadlock, yeah, yeah, right. Maybe how deadlock. Um, and then do table, right? Does everyone remember what this table is? This is the, you know, you've got some allocations, you've got some, a maximum thing that it's gonna use, you've got some available resources and you just work through banker's algorithm to um calculate a thing. This is another potential calculation question. Yeah, I would give you pretty much everything that you would need um for this kind of question as posed in one of the tutorials essentially, right, cos I think there's a tutorial with the bankers in it, if not the one from the lecture, cos there's definitely one in the lecture. Yeah, and then it would just be filling the table, right, and give me the right numbers. Um, to see if you understood how this works, ah. Alright, end of week 6. We're nearly there, no, not really, um. That's 2 sections done, I think, right? Um, I own and hard drives. Polling and interrupts versus polling versus interrupts for input output, what does that mean? What is the advantages of each, which one should we use? What context would it be sensible to use it for? Would we poll a process like a piece of hardware that is, you know, usually available? Would we poll one that is very rarely available? Would we require inters, that kind of stuff. What is the difference between port mapped IO and memory mapped IO? Um, good old, super technical. What is direct memory access and why is it good? Right, like, so what is the DMA for, how does it work? Give a run-through of what happens when DMA does DMA. Um, device drivers, what are they, what do you need in a device driver? Um, like what, why do they exist? Um, I can tell you for the, I'm not gonna ask you for a detailed recreation of this weird diagram that I drew where it was going through hundreds of flow charts to go through the process of a device driver talking to something cause that is again something that I wouldn't expect anyone to know. Um, what does everything as a file mean? Um, give an example of a non-file as a file and how it is a file, or how you can treat something that's not intuitively obviously a file as a file. Uh, how can we communicate with IO devices, blocking, non-blocking, or asynchronous communication, so this is. Um, just for revision purposes, you know, um, it's a question of, you know, like if I'm talking to something, do I stop, or, and, uh, you know, like you can have something where it's like I stop and wait for it to finish and then it gives me something. Or I can just keep on asking it, how close are you to doing stuff, and then I keep doing stuff and are you nearly done, are you nearly done? Are you nearly done? And I just take stuff off a buffer, for example, um, depending on how much there is. Uh. What are the access patterns of IO and what design decisions could this impact? So for example, you know, um, what is the difference between a, uh, a batch job and a, and a mouse, right, for example, like what kinds of activities does each do? Does one have mostly, um, IO? Does, uh, you know, is one of them really, really, um, Care about response time or turnaround time, that kind of stuff. Um, hard disks, HDD's, how do they work, basic description of, you know, platters and spinning and. An arm and seek time and um rotation time and reading time, just knowing those things. I'm not gonna ask you to do that calculation because I think it's kind of pointless, but I might ask you some questions similar to those that you would see in the multiple choice questions and that's sort of at that level. Why might an HDD have a buffer, what are the benefits or drawbacks of having a buffer on an HDD and it's all about, well if I have a buffer then I can read the information right now and then I can do batch rights. Um, solid state drives, what problems do they fix? How do they work broadly? You don't need to go through the physics. I did cover that in the exam, but not in the exam. I did cover that in the lectures, but I don't have any physics questions in the exam. That's just, you know, uh, for learning purposes, I guess. Um, how does an SDD work? So I do expect you to know. You know, the nuances of how can you, you know, like you have to write a whole page at once, you can read from anywhere, you can like read whole pages, but then you start deleting pages and having to rewrite whole pages. That stuff with the STD, um, what is we're leveling and how does it occur and how might we mitigate it, um. Um, so I expect you to know that, uh, each, each page has a limited number of rights, for example, before it, um, becomes shitty. Uh. What? Oh yeah, like this is, if I have to write many, many things to a hard drive, um, what techniques can I use in order to accelerate that? So let's assume that I have a buffer and I want to write, you know, 10 things to a hard drive. What algorithms might I use and, you know, first come first. The first canvas. I can't remember what that stands for, it's it, but it's basically first come first served or FIFO, um, scan, which is where you're going up and down and then there's also look and how to order the requests, so just um being familiar with um those. And any questions about week 7? Yes. Sorry, I'm gonna have to get closer, you have a quiet voice. Yes There are questions in the workshop. Which calculation questions are we asking about? Oh yeah, no, no, there's no HDD calculation question in the exam. Like I've just made that decision because I, like I, either I say there is, and then everyone memorizes something that is broadly pointless, or I say there's not and then no one memorizes something that is broadly pointless. Um, all I really care about is that like. You know, like the, the piece of information that's relevant to that is really knowing that a hard drive has 3 components to it, um, and some of them are faster than others, and you might want to optimize for some rather than others, right? And so that informs how you might design SEQ, or is it SEQ? Scan, sorry, scan, right, that's how you would design scan, like why would you have, you know, I can ask you a question about scan, like why would you, you know, like why is scan a good idea, right? Um it goes from, you know, like it basically uh tries to put them in order within the hard drive, right? Um, I could also ask you about like the layout of hard drives in terms of, you know, like, um, you know, sectors and so forth, right? And be like oh well why is it bad to have all the sectors. You know, all in a row, that that kind of thing is the thing I think is more important to understand about hard drives than can you do the simple calculations, so. Any other questions about week 7 and hard drives and STDs? Oh, all right, um, raid. 0145. Um, what are they, what are the benefits that they grant, when do they fail? Yeah, unfortunately I'm going to expect you to know all these random numbers associated with them, so, you know, a quite a reasonable question that I might ask is in grade 4. How long does it take me to write relative to the number of hard drives I've got, which is a rather annoying question. Um, but I do expect those numbers to be known, right? Like most of them it's pretty like, how would I put it, they're pretty easy to remember because they're very logical, right? Like, so for example, you know, with mirroring, you can have, you can have one hard drive failure, and the number of space you have is half the number of hard drives you have. All good. The only one that's kind of annoying is raid 4, and the reason I expect you to know the numbers for raid 4, which is that when you do like random writes, it's, Um, in on 2 or whatever it is because you've got to write it to 2 hard drives and each time you've got to write twice to do parity, it's because I need you to understand parity, right, like that's the only reason I'm sort of expecting you to know that number. Um, so yes, uh, what benefits do they grant, what do they fail, how best to lay out. So with raid zero you can ask questions about striping, essentially, you know, striping versus non-striping. For grade one, how does it affect read-write times, and I think I've got the same thing here. You know, grade 4 is what is parity, how to calculate it efficiently, additive versus neg uh positive versus negative parity, whatever it is. Additive, subtractive parity, however you want to describe it. Uh, why is writing so slow, um, would be a question that I would ask, right? Um, and then grade 5, what is the difference to grade 4, and what advantage does that provide to reading and writing, right? Um, and being able to explain why. Not having everything on one parody disc is a good thing, and when that's true, when that's actually a good thing. Um, Where are we? Yeah, what is a file, what is a file path, file permissions, what are they? How do they work? Access control lists, what are they, what advantages do they convey? And then hard links, soft links. What is a hard link, what is a soft link? These kinds of questions are kind of like, I create a file, and then I create another file, and then I make a hard link at the first file, and then I make a hard link at the second file, and then I delete the second file and then I add a soft link to them. That kind of question, right? Um. And then being able to sort of, you know, um, reason your way through that kind of logic, um. File descriptors, what are they, how do they work with forking, I nodes, what are they, what's inside, what do they store, how are they arranged? What happens with big files, directories and I nodes, so like. What do directories contain, how do directories relate to I nodes, oh yeah, directories have a list of I nodes associated with the files that they've got, right? Um, and what does mounting mean for the purposes of mounting something to a, File system, right, so you know, classic question, I mean that's pretty much verbatim, the kind of question that would get asked in the exam, I'm not saying it's in the exam, but, you know, like, what is mounting in the context of file systems? Makes sense? Yes.

SPEAKER 1
Yes. Yes.

SPEAKER 0
Yeah, so for random writes, in order to randomly write to raid 4, you need to know what the existing value was, so you can do subtractive parody in both the parody machine and the, or the parody drive and the drive you want to write to. Which means for each of them, you need to read once, right, and if it's a hard drive, that takes some time. And then for each of them you have to write once, right, to update the parody. Right, and as a consequence, um, your right time is basically the hard drive time divided by 2, right, so you're half as fast, right? Um, cause you can do both of them at the same time, that's fine cause they're in parallel, but you have to do one read and one write for each one. Great Um, uh, for non-random for raid 4. OK, so when you're doing non-random writes, the difference is I'm gonna be writing because of striping to every single hard drive at once. And because I'm gonna write all of them, I can pre-comput my parody on the computer. And I'm just gonna write the parody, I don't have to read, cause I know what they are, right, like cause I'm basically going, I want to write 110, and so that must be 0, right? Yeah, you're gonna write like for sequential writing, you're basically always going to be writing to every drive. Right, it's just sort of. Yeah, and you can calculate the parity before you ask for the right request, right, but if you're doing a random one where you're only updating one, it's actually easier to update 3 than to update one, if that makes sense.

SPEAKER 1
Alright, alright, alright, alright, week 90 wait, no, there's week

SPEAKER 0
10 week 8 continued. What? Hm. Alright, uh, contiguous allocation, extent allocation, linked list allocation file, yeah, right. Familiarize yourself with each of these things and why they're good and why they are bad, right? Like, so, you know, for example, you know, if I organize my file by linked list, so every, you know, page links to the next page in a series of like why would that be awful, right? You know what I mean? Um. What's the layout of the fat architecture, um. Yeah, I, I mean, I don't know. There are questions associated with this, it would be sort of like, give a brief explanation of um this architecture and where it would be good or what's wrong with it, why would we change it to something else. Um. Like contiguous allocation, you can start talking about um. Fragmentation amongst other things, um. Oh yeah, here is the, there's the question, here's the design for a file system, what problems are there with this style of file system? That would be basically the kind of question. Um, or like, yeah, explain how it works, um. Alright, uh, that's the end of week 8. Alright, week 10. Fast file system and crash recovery, right, so this is gonna be, this one's actually pretty brief because there's not a lot to file fast file system, right, like as in, cause it's really just like what's the structure and how does it differ, right? So we're just gonna have these segments rather than one, you know, like when you lay out a file system you've got the, the um, What's it called? That first bit, logical thingy that tells you everything about the hard drive, and then you've got some maps, and then you've got some Iodes, and then you've got some data, right? And the only difference really is for the fast file system is that we've got lots of little versions of that. Um, Yeah, what's the best way to distribute data between groups in the fast file system, so that's where like, OK, assuming that I've got all these segments and I want to try and break things up between the segments, what's going to be in each segment? Um, how do I deal with big files in fast file system, right, so that again is breaking things up between the different segments in a fast file system. What are subblocks and fragments, why are they good or bad, what problem are they attempting to solve? So this is where you can break pages up into mini pages, right? It's an idea, um. Why is having all memory blocks laid out in contiguous order bad for our HDD? See, there's that question, I knew I had it here somewhere, um. What is FSCK? So what is it doing, um, how does it work? How do you know the computer has crashed? And here's an example of an inconsistency. So I could ask you the question, my computer has crashed, and I have this file with this, it's pointing at this I node, and I have this I node and it's pointing at nothing. What should I do in order to fix this, right? Um. And then journaling. Yeah, what are transactions, what are checkpoints, like what is, what's the process of journaling, give or take, right, like as in what are we actually doing? Um, here is a scenario, there is a crash, what can be fixed, what must be discarded. And so that'll be a case of like I'm halfway through writing something and then the computer crashes, what, what will I lose, is a reasonable question there. Um, data journaling, order journaling, write-back journaling. When you're designing a system and this is an option, which one would you use, maybe here's a scenario, which one is the better one to use in this scenario. And then, wait, wait, wait. Uh Week 10, any other questions about week 10? Week 1011 and 10 and 11 are quite short, so there's not really a huge amount um that I can ask you about it. That's not like really nitty gritty pointless details, so just having a high level understanding. So like log structured file system. Again, what is it trying to solve? Like what, like what's the main takeaway from what the log file, um, log file, uh, log structured file system is, um, should the segments be big or small? What advantages, disadvantages for log log structured file system LFS? What is the big advantages and disadvantages of the LFS? Um, what governs that decision? How do you handle I nodes, where are the I nodes gonna be? What is the I map, um. What is the checkpoint region, right, um, so like sort of how would you, um, you know, like how does the operating system know where the I map is, then it has to know where each of the parts of all the I nodes are stored, so then it can look at all those bits of I nodes. Um, and when a file's updated in the LFS what happens? Um, so being able to talk about like the old files might have to change, or they might just stay there and then we've gotta try and collect them via garbage. That, that would be an implicit question where I'm sort of trying to ask you to elicit the word garbage collection. And then I might ask you explicitly what garbage collection is and how would you administer it, like, how is that, and specifically in the case of log structured file systems where it's, you know, like each segment has a little bit in at the start of data to tell you stuff about the, The log so you can compare and see whether it should belong there or not. Uh Good luck Um, hopefully that I don't know, I, I, if, if you're not exhausted by this, then I, you, you're, you're better than me, like my brain's like fried now. Um, maybe I was just talking too quickly. Um, you can always watch this back on one time speed. I know, I, I've been told that I'm the only lecturer, well, one of the few lecturers people actually watch on one time speed. Everyone else watches everyone else on 1.5. Um, presumably some people watch me on like 0.7, I don't know. Uh, if there are any other questions, feel free to ask them now, or I can, I'll wait for a couple of minutes and then I'll turn my mic off. I have consulting after this. I am busy at 4 because I'm seeing another student about their imminently due master's thesis, um, at 4, but I, I have time next week that I've blocked out for this subject. I'm available most of Monday and I think it's Tuesday and Thursday afternoon, um. So I'll be available for a long period of time, but um I live in a locked corridor um. I'll get to you in a second. Um, I, I lived in a locked corridor, um, so if you want to see me, you have to email me in advance, right, because otherwise I will, you will get to a door and then you'll be stuck. And some students are like, Oh, but I could go through the door and go after someone, which you can totally do. It's totally fine. But then you'll find me in a meeting with someone else, and I'll be like, Yeah, yeah. Come back later. Yes. Yes, hex question, yes, yes, yes, yes, yes, yes, yes, yes, yes, yes. Let's make a hex question. I like it. All right, a hex question. A hex question. All right, so what is a hex question gonna look like? Insert. Able The next question is gonna look like something like, hey, there's a segment, right? And there's a 00. Or like 01 and 02, right? And we, we, we might um insert, insert left. And said Left Right, um, and then we might say that this is the stack, and this is, oh wait, no, that's, that, that seems wrong. This would be. They, uh, what's it, Data and heap. Data in heap ah code, there we go, there we go, stack and then heap slash data, right, that's usually what it is, um, name, right? And then we're gonna have another one insert, insert to the right. And it will have like page and frame, right? Uh, uh, uh, and this one might be like offset, I guess, off, offset. Right, and so, you know, if I get a insert. Uh, I really should just get Chachi PT to do this, it'll make my life a lot easier. Um, I have a 16-bit system. And I want. Uh, what do you call it, and I have the following, right? And this is where we get into the, the tricky bit, right? And then we uh and then I might say, uh sorry, you know, like a page is 250 56 bytes. Right, OK, so that's what it, it, and I have the following and I'll, I'll give you like a magical address and the, the address would be um 55555 or something like that, right? Um, or make this a bit more interesting, 5 ABC. Yeah. OK, so how would I deal with this, right? And it'd be like, OK, so we'll say the, for this case, the offset is like 1000, and then maybe 2000, and then maybe 3000. OK, so we're gonna be a bit careful with this, right? So this is gonna be in hex, and then. I'm not gonna bother with this just for the moment, we'll just, uh, we'll, we'll get to that bit when we want to get to that bit. But that's kind of the structure of the kind of question that we would get. OK, so how are we gonna approach such a question? Well, the standard burner way of doing this is, I'd be, I'd be like, I need to really understand my data, right? So. 5 ABC. So the first thing that I would do is I go 0101, um 1010, 1011, 1100, right? So I'd do my conversion into HECS, right? Um, I don't know about you guys, but I, I, I, I do HECS, right? So, great, right? So now I've got this more useful number. Right? And now I can start to analyze it and be like, OK, well, it says segment, right, and segment for in the case of segmentation, it's gonna be the first two bits. If it was just an address, I might have to start going, oh OK, well, you know, like maybe the 1st 6 bits count as the, the page or something like that or the page table, but for this case it's the segment one, so it's in the stack, right? And so I'm gonna go, oh, OK, so now I need to add 2000 to it, this. So whatever this address is here, I need to add 2000 to it, right? So what 2000 looks like is if I grab 2000. Right, and, and so what I can do then is I can go, OK, so I'll grab that number and I'll just go XX, right, because the first two bits don't count, right? Um, and I guess I should really write it as 00, so just to make it a bit more obvious, maybe. These don't count, right, so that's the actual number, right, that I'm going to be looking at. And so now to find this one I have to offset it. And uh I have to offset it by 3, what is it? 3000, 2000. 2000, so I would write this as 20,000,100,000,000,000. Right? And it would be totally fine to write this in hex as well. So you could just be like, this is ABC and this is what, uh, 1 and 31 and 2. So it'd be, I guess the answer was going to be in this case. 3 ABC. Any objections?

SPEAKER 1
Yes. Yeah, yeah.

SPEAKER 0
That's where in memory it will be. I'd, I'd be like, I have ABC find the stack address. I, I sorry, the, the frame, the stack, uh the, the, the frame address of this thing, right? Um, so that's where in memory it would be, yeah. Oh, because, um, basically, um, those two bits don't represent anything, they just represent uh which segment that you're in. It's in the case of segmentation, it's, you are either stack or, you know, 01 means. So like for example, um, what this means, this is where it's a little bit nasty, right, like really tricky, because you can be like, I, I used the number 5, and I used the number 5 intentionally, because you can imagine that you could also have like 7. Right, and you're like, OK, so that would be 0 111, OK, that's fine because I can still add, you know, I could change that to a 1, and that would become 11, and then this would become. You know, 100. Yeah, and I'd be like, OK, yeah, that's fine, I can change, uh I can add, oh no, sorry, yeah, that would still be. No, that would still be, that would still be 3, sorry, 2, 2000. Right? Um. And then so I would get an address, in this case, which is 4, so I'd get like 4 ABC, so that'd be fine, right? Like that I'd be totally fine with. The issue is that like if this number was to get like larger, like 8 or something like that, right? You know what I mean? Well then that would become, here, it would just become 1000. Yeah? And then I'd be like.

SPEAKER 1
Who, right?

SPEAKER 0
Like, I like that doesn't make any sense, right, cause I don't have two bits at the start to decode it, and I'd be like this is like a segmentation fault or something, right? Like it's, uh, cause that doesn't make, that doesn't decode to anything useful, right? So this only makes sense when this number is less than um 8, right? And it also wouldn't work for, sorry, did I? It would work, sorry, cause there's no 02, I'm retarded. That should be 10. I'm sorry if that was a completely confusing example because 2 is 10, it's not 02. I wrote it in decimal and I should have written it in binary. If it was 8, then it would become 10 and we'd still be fine. The problem would be is if we wrote, A C, if we wrote C, then we'd be in trouble, because then this would be 11, and then we would not be able to get a 1111 would not mean anything, yes.

SPEAKER 1
Get the first two bits to zero.

SPEAKER 0
Yeah. So why is the one in the 3rd position for the offset? Because it is in this case 2000, so that's 10. 1000 Cause it's in HECS. 10 is 2, this, this number here. Yeah, so this is, this is 2000 in HECS. Alright, now I'm gonna show you the nastier one, right, so this is the easier one. Here is the nastier one.

SPEAKER 1
Who knows?

SPEAKER 0
I know. Alright, so in this case, right, we're gonna have a nastier one, right? And so the nastier one is gonna be like. Um 11 AB 33 CD. Um, 4 or 5. Is that the nasty one? No, this is the easier version of the nastier one, but we'll do, we'll go through the easier version of the nasty one here, right? So this is the one where like the question would be something along the lines of, you know, I have a, I have a 16-bit system and a page is 256 bytes of. I mean this 11 wouldn't say a page, right, like that's a bit misconceived miscon for this one I wouldn't actually ask for a page, I would just go like. I have a big system which has this table, right, it would be like it has a stack heap and and a thing. This one is gonna be more relevant. If I say a page of 256 bytes, what I am saying is that the amount of offset is, is 8 bits worth, right? Um, 8 bits worth of bytes, yeah, bite addressed. OK. So what that means is now I'm gonna maybe, uh, well. B A B C is not gonna be here, right? This one's gonna be more along the lines of like this, a 11 BC, right? And I'd be like, turn that into something useful, right? And this is where I go to the table and I'm like 11 BC. Well, 11 is A B and so the answer is. A BBC, right? More straightforward, right? Do we, do we get what happened there? Right, like basically I went, I'm looking for this number, right, so I'm just going to, uh sorry, I'll make this a bit bigger. I'm going to grab this part of it. Which is the red part. I'm going to find it, and this is going to be the page, not the offset page. I'm going to find it in this table. And then I am going to mark it as red, and then I'm basically gonna replace, It with the frame number, so the 11 will just become AB so this becomes BC and just to make it even more clear I'm going to change this to an ENF. There we go, ABEF, right, that makes it slightly, uh no, there's also an EEF there, right, I'll change it to a 99, so there's no like overlap. 99 99. There we go, see. So 11 becomes AB, so. 1199 becomes ABE 99, right? This is the nice version of it. The nasty version of it is. And this is gonna take me a little bit more uh time to come up on the fly, but I can show you what it looks like. The nasty version is where it's like a page is actually 1,024 bytes. Yeah? The reason this one is nastier is because the math becomes mean, right? Um, and the reason for that is because, is this going to work? I think this is still going to work. And the reason is, is because if we look at the HEC version of each of these numbers, this becomes 001,0001. Right? So the first one is fine, yeah. But actually, because there are 10 bits, 10 bits for the offset. The page becomes 6 bits, which in hex is misleading, right, because, you know, it's basically this is 01 and then that's 0001, right? That's, that's, that's annoying, right? And then you would have something like 33 which would be 1000 0011, and then 45 which just will not work. Yeah, that won't work, so I guess I would do 25, right, 10. 0101, right? So that would be the The, the, what do you call it, the, the, the thing that you have to replace, and then on this side I'd have to replace it with something that would work, so you know, like 35. Let's say um and 20 F, 2 F and 1 E, something like that. And then when I'm looking for a number like. And this is where it becomes really messy and nasty, what number am I going to look for? I'm going to look for. 9 And then 5. And I'm just going to change this to CC because we haven't used Cs yet. Alright. So why is this not uh uh. Why is this nasty? OK, the underlying principle for why this is nasty is because we've got a bit of like bit bit bits moving around, right, like in a really awkward, annoying kind of way. Because if I think about what 99995 CC is, 95 CC we convert this into binary, right? 1001. 0101 11,001,100. OK. So far so good. Which one would we use? Are we gonna vote for? Who votes for? Ahead of time. Who votes for? Option number one. Who votes for option number 2? Who votes for option number 3? Yeah, there's a few. It is option number 3, so, causes like this one's not obvious cause you're like 95, 1195, 33, 95, 25. What the hell? I don't understand what's going on here. But when you take these 6 bits which represent the page. And then you go to here and you're like, well actually, that could also be read as. 20 5 Then you're like, oh OK, yeah, I can see how that would work, right, so it's 25.

SPEAKER 1
Yeah. So it's this one.

SPEAKER 0
Yeah, and then you're like, I have to place that with one E. Right, so if I'm going to replace that with one E. OK, 1 E. So 1 would be 01 and E would be. Uh 1110, right? And then if I put it back into normal HECS land. The actual answer in normal hex land would be. 7. I'm CC There we go. That's the nasty version.

SPEAKER 1
Yeah.

SPEAKER 0
Yeah, exactly.

SPEAKER 1
Yes. Which step? Um. Uh, so the page size, the size of the page obviously determines. Yes. I looked at it's like you got a calculate two of the. Yes. Is there any other way to do that?

SPEAKER 0
Yeah, that's a good point. Alright, alright, alright, so I'm gonna, I'm gonna enlighten everyone here. You know when you were in primary school and they were teaching you your timetables? Um, as a computer scientist, you need to learn your binary timetables. I suggest that you play a lot of 2048, right, like it's in to get these numbers stuck in your head. Um, knowing that 1,024 is the 10 is, is like knowing that 3 x 3 is 9 in computer science. Like it is, it's just a. A pointless fact that you just have to kind of know. And it's the same thing when someone says 32,768, you mean like, oh, you mean the range of a, a 16 bit integer, yeah. Right, like it's, it sounds stupid, but like it, yeah. Um, the other way that you can do it is you get your calculator and divide it by 2 and go 123456789, 10, and you're like, yes, 10 times. Um, but yeah, yes. So it was on frame 79 cc. The reason this doesn't make any sense is because basically if you, oh wait, did I do this right? Yeah. The, the reason it's so horrible, right, is if I write this number out again, and I say 11. Yes, no. All right. I'll show you, uh, this is the, this is the explanation for why, right? Um, Red. So if I read these two red numbers, the first one is 01, which is 1, and the second one is 1110, which is E. Yeah, so the reason why this one is really mean, right, like this is just unnecessarily nasty, is because the way that you, when there are 6 bits, if you interpret it as a big, the 1st 6 bits of a big number, you get a different hex than if you interpret it from the low end, low end upwards, right, so it just changes the numbers, right, so it relies on you understanding that actually hex is a representation of binary and it's just a convenience. So this is a really good exam question because I can basically like go, hey, does everyone understand the binary underneath? And yeah, like the naive, like cos otherwise, the otherwise the problem with this kind of question is you're like, oh, can you find 11 in a table? And I'm like yes, can you find 11 in a table. That's like the, the shortcut way of understanding this question. You just replace the 11 with the AB. But in this question you actually have to understand the binary, right? Um, I'm not saying that this is necessarily in the exam, but it could definitely be in the exam. Um. So it's, it's something that is worth at least devoting some level of cognitive load to, or at least working, it's definitely one where I would suggest that you do practice. um. In terms of um broad examiner, oh yeah, sorry, are there any other questions, does, does anyone want one more example of this, or are we, have we got to the end of this? I mean I could do a, A two-level page table if you want, but it's basically the same thing. This is a brief thing, if I were to do a 2 page level uh 2 page level table thingy, right, um. I don't know if I can actually do one. I've, I've, I've no, I, yeah, that basically I'd have to give you like a lot of different frames, right? Like as in, um, for each of those different addresses. So yeah, uh, but single level is, is definitely more approachable. Indeed. Any other questions? I will upload this extra bit to the end. Um, I'll consider this a recording of it, um, unless I get a massive amount of demands for any um. Videos. If, uh, what I'm gonna suggest, um, if there is something that you would like to see like a worked through example for that doesn't exist in the universe, um, could you post to Piazza, and then could you get like 15 friends to upvote it, and then I will consider making a video about it. Yes.

SPEAKER 1
Yes. Yes, sure.

SPEAKER 0
Oh, it's it's best 3 or 4, sorry, it's they're 2% each and they're 6% for the total course. If I said best of 4, then I'm. Yeah, it's best of 3. Alright, I'll go back to this slide. See, positive vibes everyone, positive vibes. Alright, I'm gonna pause and then you know, whatever. Uh, uh, thank you everyone for coming. Um, hope you do well in your exams generally, and for those of you who are graduate graduating this semester, congratulations, yeah.
