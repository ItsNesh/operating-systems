SPEAKER 0
Huh? Microphones are docked. Undock the microphones from the charging dock to power them. What? Right. All right, hello. Are you happy now, machine? Alright, oh no, maybe it is recording. I don't know, it's just being stupid. This one feels not as loud as the other one. Is it not as loud as the other one? I feel like the other one's. Go. Alright, uh, that sounds slightly better. Hi everyone, I'm back from holiday, woo. Thanks for coming. I'm glad. There was a point I was thinking this, like at 10:51 where I'm like, did I, should I send out a reminder that there's actually a lecture today, but apparently my students are not completely silly. Um, let's start with housekeeping, housekeeping. Uh, first bit of housekeeping. Um, if you have sent me an email over the last two weeks, and I have not responded, just send it to me again. I have tried to reply to everything that everyone has sent me, I think, give or take, um, there might be a couple of posts on the, Discussion board, which I, I, I tend to leave them for a little bit, cos they're on the discussion or piazza or whatever it is, um, because, you know, sometimes a helpful student will answer the question instead. Um, so that's that. Um, assignment 3, I have posted. I haven't posted anything. I've, I've, I've changed the thing so it has grade scope, I think. Grade, there is a grade scope for assignment 3 now, um, I have tested it, it seems to work broadly. Um, it's not gonna be particularly helpful. Um, you're in 3rd year now, so you should be able to write test scripts to test your own merge sort pretty easily, I think. Um, I don't think you should need grade scope at this point for the purpose of debugging. Um The timetable for the presentations for the grade scope thing will be up soon. Annaavav is organizing all of that, so that's cool. So assignment 3 is under control, I think assignment 2 is in the process of getting marked now, so hopefully the results of that will come back soon. That leaves workshop 5, which is up very late, sorry, you've got 4 days to do it or something, I don't know, it shouldn't be particularly onerous. I haven't written the in-class question for workshop 5 yet. Hopefully I'll get that done in the next 2 days. Uh, workshop 5, assignment 30, exam. There's an exam for this subject. I have, I have received many emails about the exam. What's in the exam? There is now on, on the website, on week 12, there is sort of the really lazy version of the answer to that question, I guess. Where is it? So, um, if we go to. Operating systems. Modules. Week 12, revision, right, I think it's all posted. It's got the basic structure of the exam and the basic topics of the exam. A lot of people are sending me emails about what's in the exam, and I feel like at this point it's almost fishing rather than actually like. Sensibly asking what's in the exam. But basically, if it was in a lecture, it could be in the exam, give or take, right, that's sort of the structure of it. I think yeah, there's 8 MCQs and then there's 92 short answer coding slash theory questions. When I say coding, I think the only coding questions are really like a, Um Sort of pseudocode, write some pseudocode to do some things, um. Um, OK, so that's the exam. Um, I'll go through that in week 12. Next week we have one last lecture that's content which will be on, Log-based file systems, I think, um, I haven't got that up yet but I'll get that up early next week. Uh, today we're doing fast file systems at journaling and FCSK FSCK FSCK. Um Any other questions about the course, housekeeping wise? If I seem a little vague today, I, I actually got sick while I was away, so the first half of this week I've been working while having quite a severe virus and basically when not working, coughing. And not sleeping, right? So, so, so basically I've had no sleep this week, so I'm, I'm a little bit out of it. But so if you have any questions and I just drift off partway through the lecture, that is, that's probably why. Um, but if there are no other questions, I, I will, I will, I will get started. So today we're talking about fast file system. Right, so if we recall from last term, which is like a month ago, we briefly went over some stuff about file systems, which was really just about I nodes, give or take, right, like cause that's what it does under the hood, and then some stuff about path names and links, um, So what happens now is we go, OK, so that was attempt number 1, and then we invent attempt number 2, and, and to be honest, like there's a, there's a point here at which like, how do I put it, like this is meant to be almost demonstrative of like the kind of thinking needed for trying to solve these problems. But if you were to really dig into it, like file systems are so advanced now. Or like, you know, like operating systems are so advanced now, there's lots of like, lots of technical little details that aren't worth anyone knowing, but you sort of need to know vaguely, kind of the broad, You know, paintbrush strokes of what's going on. Anyway, so fast, fast, fast file system is one of these like, you know, early-ish upgrades to how file systems work that make it a little bit more interesting than I knows I guess. Um, and then we're gonna talk about file system checking and journaling which are both really just about crash recovery. So like, like, how do you deal with a situation where your computer just power turns off randomly and everything stuffs up. And that's really just another like, like, it's kind of a weird. Combination of like persistence and concurrency, if you think about it, right, like what that's gonna end up looking like. So, if we recall from last month or whatever it was, um, if we have like a hard drive, we're gonna divide it into a bunch of different parts, we're gonna have the superb block, the superblock is gonna have just stuff about stuff, right, like it's, it's like, I don't know, uh, you know, what kind of operating system is this, like where is everything mapped, you know, all that kind of like, Really administrative, it's like a table of contents almost in a way, like where is stuff, what, what file system, how big are my blocks, all those kinds of things. Um, and then we have a couple of bitmaps, and the bitmaps are basically saying which bits of my hard drive am I using and which ones am I not, and likewise for Iodes, which of my i nodes am I using and which ones am I not. Then I have all my Iodes and the Iodes are basically little files that point at blocks or point at other I nodes and then you have data blocks that contain actual data, right, so this is how we're gonna, you know, I don't know, um, describe our. Hard drive, I guess, right? Or like it's it's a bit more vague than hard drive, memory, long-term storage. Um, and yeah, so that's actual data, right? I nodes, which I nodes are free, which data blocks are free, and then where are the I nodes, how many are there, how much data, all that kind of stuff. Um, alright, so what went wrong? OK, so, so like in order to motivate the fact that we have to do, you know, like we already have the solution, why are we getting a new solution? Um, what went wrong, um, the performance. So any guesses why the performance of this was not so good? Oh, everyone's asleep like I am. Uh, it's gonna be one of those lectures. Alright, so. One of the things about this, that's like, again, I don't know whether this is as relevant but like it, you know, informs the history of how this all went together. Or you know like what what kind of hard drives did we have back in the day, right, when we're developing all this stuff, right? Hard drives were like disc hard drives, right? And so when you're looking at a structure like this, you need to think like if I'm using a disk, what could go wrong, right? And the answer is, you know, like, The the I nodes and the data can have absolutely nothing to do with each other like contiguously, right, like or spatially, right? So what you could do is you could have an I node and it says oh I'm an Iode, my data's over there, and then I have some data and that points over there and another I node that points over there, right, and if you've got a hard drive, Right, when you, when you start up your file system, everything's like going really well and you're like huh, new operating system, everything's great. Right? And then, then what happens is you're like, I, I add a couple of files and I delete a couple of files and I add a couple of files, and right, and this is not about fragmentation, right, like cause with fragmentation you're like oh my space, I can't find things to put in. No, no, you've still got plenty of space. In the hard drive, it's just, you know, like when you, when you try and open a file, it's like, OK, so where's the file? Oh wait, it's over there. Alright, let me just go and get that file, right? So it goes from one side of the hard drive to the other just to get the same file, right? And it happens every time because the I nodes and the and the data are really far away from each other, right? Within the space of the, you know, the hard drive, right? Um, because the I nodes can point anywhere. And so you end up with these hard, you know, like, it was, it was a really common thing, like we, we don't have this now, like normally when you have a computer, right, and you open it and it just turns on, right, because you have SSD. But when I was a kid, what would happen is you'd get a new computer and you'd be like, oh my God, this is the fastest computer I've ever used, because you open it up and it just starts and stuff happens, right? And then you have it for like 3 weeks and then you're like you open it up and it's like, OK, what is my computer doing? Why is it not opening anything? Why is it so slow all of a sudden? All I've done is installed 5 games, right? And it's because of this, it's basically the hard drive was the bottleneck in performance, and the hard drive's waiting to get, you know, I've got to find a little bit and, you know, run across to this bit of the disk and then run across to that bit of the disk and then run across to this bit of the disk, and then it takes forever to do anything, um. Yeah, so I, I, I think. I think I copied this from the previous year's lecture, and it doesn't really make sense in context. Other than to remind ourselves that the word locality exists, and what we're really wanting to do is we want to have the locality on the right, not the locality on the left. So we, we basically wanna have a, a case of like on the, on the right, we wanna make it so that whenever we're accessing something, we're sort of accessing something that is at the same time, in the same place, as often as possible, right? Rather than in different places and different times. Um. And so what ends up happening as part of the file system is that like, The logic is, it's like, OK, I have hardware, maybe I should design my storage system. With the hardware in mind, right, like I'd be like, OK, so what does the hardware look like, and the hardware is these, you know. Um You know, lots of discs, right? But if I think about it in terms of like, OK, so where is the bottleneck, like where is it, where does it suck? And the bit where it sucks is not that like the discs run around at a billion miles an hour, so that's not too bad, right? The um the part where it sucks is that the little arm has to go in and out of the discs, right, so it sort of like drives in and then it drives back, and it drives in and it drives back. And that requires a motor, and that requires it to accelerate, you know, it has to stop and start and stuff like that. When it's the discs are spinning, they're just going the whole time, and you just wait and then read and then read and then read and then read, so that can be quite quick. But the going in and out of disk is quite slow. And so what they do is they're like, OK, well why don't we like divide the thing into cylinders rather than sectors, right? And we're like, OK, so we've got different cylinder groups, so we've got the inner cylinder, we've got the middle cylinder, we've got the next middle cylinder, and then we've got the outer cylinder or something like that, right? So now I've divided it and I've said these places on the hard drive, I'm going to conceive of as being really far away from each other because I don't wanna have my little arm driving in and out, right? And so we have cylinder groups, ah yeah, OK. Ready for teams. I hate you teams. Um, so we have one of these, you know, block groups, right, and basically what we do is we divide the disk into groups and then long story short, what we do is in each, each cylinder we make a little block with its own little super block and its own little bitmap and its own I nodes and its own duds. So all we're doing is we're taking one big hard drive and dividing it up into lots of little hard drives. Right, and each of the little hard drives has its own, you know, sectors and, and, and stuff, right? So we've got groups, and this way, what we can say is that the data associated with the data block is close to its Iode, right? Right, because now it's in a smaller, like, I don't know, I've, I've divided it, I've I've divided and conquered, and now I've got these little, little, um, group block things and if I look at the bitmap and the iNote and the data block, they, they're gonna be in the same cylinder, so they're gonna be kind of close to each other. Hooray! What a success. Yeah. Um. Yeah, and that's it. Like, wow, that was, that was, that was amazing. I learnt. But Did I just hallucinate that? No, OK, so there was a guy who just walked in and then walked out for no reason. I had no idea. I said I'm tired, jeez, I'm just checking. Alright. OK, and yeah, um, there is a secondary advantage to this, which is this idea that like if you have more than one superb block, right, so if you divide your hard drive into sectors, you could have a thing where like one of those sectors dies and then the. The rest of it's still kind of there. Whereas on a regular hard drive, if your super block dies, which contains all the information that's like the, I don't know, how to get in, it's like the doorway to the hard drive. If you break that doorway, that hard drive is gone. Whereas now we've got a couple of little doors, right, we can, you know, save little bits of the data occasionally. So yeah, it's um, a little bit more reliable. But what's interesting is, oh yeah, that's the other thing is that, You would think, you would think, like when I write Superblock, right, you're sort of sitting there going, oh, the superblock is unique and special for each, each, um. For they group for each group? And the answer is no, it's just this, it's just they basically went, you know what, this super block is so vital to being able to do anything that will just like duplicate it multiple times. So instead of using one page for a superb block, you end up using 4 pages or 8 pages or whatever. Um, and you just have copies of it, right, um, cos it's, it's that like intrinsic to have, you, you so need this piece of information in order for this, um, Data structure to function. Um, cool, uh, and then, yeah. You know, like the bitmaps stayed the same, they're just bitmaps, but now they refer to the data blocks within that group, um, the I nodes, nothing new, the data blocks, nothing new, you just basically have the same structure repeated multiple times within a single um. Assistant storage device. Cool, um, OK, so that sounds broadly good. I have no idea what the answer to this question is, by the way, like I'm, I'm, I'm that out of it, we'll, we'll find out. What is the issue with this? There's, there's obviously something what. Oh, yes, OK, so here's the, yes, yes, I know this one. OK, so what's the problem here, right, so the problem here is, the problem here is that, I've said something and, and hopefully you're all gone, uh-huh, uh-huh, uh-huh, that totally makes sense. Right, um, maybe not, I don't know. How do we know, how do we know what? OK, so how do we know, If I give you two files, how do I know they should be on the same, in the same group? Right? You know, like, it's like, OK, it's all very well for me to say I'm gonna divide everything into 4 groups. I'm like, how do you divide the, the, the everything into 4 groups, right? Like that's actually a genuine question. You're like, OK, like it is all very well and good for me to divide everything into groups, but if I were to say, put 2 files that are always accessed together in different groups, that would be really dumb, because basically now I'd be constantly like changing groups, so I'd be like, I want this file, I'll wait, and then I want that file, right? So you can imagine that. Like, I don't know, I, it, it doesn't really work with a header and a uh and a and a C file, but if you can imagine like, as an analogy, you have a header and a C file, you've got these two files that are always buddies, right? Um, and if you store them in different groups, you've made a big mistake, right? Um, so the question is like how do we, how do we do that, right? Um. So There are some simple things, you know, the, the data block should be in the same group as its I node. That is easy, right? So you're like if, if my I node is in this group, then the data associated with that I node should be in the same group, right? Like I mean that was sort of a tacit assumption we were making to begin with, um. The second one is that a file should be grouped with every other file that's in the same directory. And this is quite reasonable as in a like as a as a strategy, where you say, OK, well, you know, humans are not completely scatterbrained, right? When they're operating systems and when they write programs, they tend to have programs that access things that are all close together within the directory structure, like the directory structure is kind of how humans think about the computer in general. And because humans tend to think in these, you know, like they have small working memories, so they tend to think of like 4 to 10 things, right? The things that they tend to think about are all in the same place, and if they're in very different places, they tend to move them so they're all in the same place because otherwise they otherwise humans will get confused about where all the data is, right? And so if we as a computer scientist go, OK, well we'll try and make the computer think like a human. Well, in that case what we want is we want all of those files also to be in the same location. So this is a reasonable assumption, I think, right, where you're like, OK, all the files in one folder should be in the same place, um. This is a more controversial one, a file should be grouped differently from files it doesn't share a parent or a grandparent with, right? And so the idea is that like OK, If I have two files, and they, they aren't in the same directory, and they're not even in the same directory of a directory, then probably they should be in different groups, right? And that, that's a more reasonable assumption, right? And so the way that I like to sort of describe it visually is you've got this kind of colorfulness where color is kind of relatedness, if two colors are similar to each other. Right, they should be grouped together, right, and you can sort of see kind of the vague idea that I've been trying to get here, right, where you're like, the further apart they are, you've got like the blue ones, the green ones, and the warm color ones, um, it would make sense to group them like this, right? Like as in I could put all the blue ones in one group, I could put all the green ones in one group, and I could put all the red orange ones in one group. Now this is a very simplified example because you can imagine with a real tree, a lot of these directory structures would be really, really deep. There are some fold, you know, not all folders are created equally. I'm sure you know like if you have a movies directory somewhere on your computer, it is one directory that is just filled with lots of movies, right? um, and takes up a large amount of data, but there aren't actually a lot of files. Whereas if you've got like, I don't know, some kind of set of config files that have directories and directories with directories within directories within directories, like games and stuff are very um good at doing this where you've got like hundreds of directories and they go down forever and there's log files and there's, you know, bin files and all this other kind of stuff, um, you have to be able to deal with that, right, so you know the number of folders deep is not always a good indication of how you should divide things, right? Um, the tree is not balanced. So, um, so. One of the things that immediately comes out of this, and this was like the movie analogy that I just gave, is that if you have a particularly large file, right, large files use large numbers of data blocks, right, they use large number of frames, they use large amount of space, um, and so, If you have 3 big files right next to each other, they'll take out the entire group if you're not careful. And if you've got like 1 big file next to a whole bunch of small files that are all, you know, related to each other, again they could just take out a whole group with the big file and then the other little files that are associated with it might actually be, you know, far away, and that would be bad, right? And so the strategy is that like what we could do is we could take the big, the large file and then distribute it across all the groups, and you'd be like, Is that what we wanna do? Does that sound like a good idea? Like how often is it that we have a large file that we open and we want to go to every sector of our hard drive, that feels like a bad idea. Um. Seem reasonable, like that, that, that seems like a, could be dangerous, at least, um. So the compromise that we, we, we get to is the idea is that like, It's not a problem if the file is so big that reading it takes about as long as finding it. Makes sense, right, so if it takes us a long time to read the file, we don't, Really care if it takes a long time to find the file, right? Because if, you know, if you take, uh, like 10 seconds to read a file, Into memory from the hard drive, even if you're already at the right spot, if you take like 5 seconds to go and find that file, that doesn't annoy you that much, right, because you're gonna spend 10 seconds anyway. What really bothers people is when you're spending 5 seconds to get a file that takes you half a second to read, right, because then you're like, oh well, you know, 90% of the time was finding the file, let alone, you know, reading it was 10%. That, that sucks, but if, you know, like it's roughly even. Then people, you know, and in general, and from a performance perspective, people don't mind that much cos they know it's gonna take time anyway, like, so the way that we think about it, we're like, oh this is a longish task rather than a fast task. I don't want to turn fast tasks into slow tasks, but I don't mind slow tasks being slow. Um, And so here's the fun part. Is that a really easy way to do this, Is that you use your I nodes, right? So within your I nodes, normally if you have no indirect blocks in an I node, you can put all of those files together in the same block, right, so if I've got a lot of files and they're in the same directory, they each have an I node and they each point to like one data block, I'll be like, yeah, it's fine, I can have like one. Right, I can have one, and then they're all small so I can have lots of them together and it's great. But if I have a big file, I'm going to by definition have some indirect links, and what I can do is I can put each of those indirect links in a different group. Right? And so this is a really easy rule to follow, because you can just be like, oh OK. If it's big, lots of indirect links, indirect links I can distribute out. If it's small, no indirect links, I don't distribute out, right? Um, and so yeah, that's one of the ways that you can do it, right, so you can store those locally but you can split all the indirect links up. Yay. Um, Another thing of the fast file system, which I don't even know whether this was a good idea, like if you read about it and you're like, this sounds like, sounds like a like a a so so idea. But uh and it's definitely not as relevant now because we've got like space is basically free. But when, you know, when I was a kid, space was expensive, you know, like my original computer had 3.25 inch floppies and they had 779K of memory, including the operating system, so you know, like less than a meg. Um, So this would have mattered with space, but now we've got like 1 trillion terabytes on a, I don't know, the size of a thimble or something, um, but basically, you know, we've got our fragmentation problem, we have internal and external fragmentation, but, We've now got to the point where we're like, hang on a second, look at these blocks, they're 4 kilobytes. How big are my actual files? Are my files actually 4 kilobytes big? The answer is, in the early days, especially, not so much, right? Most files are actually really, really tiny, um, especially anything to do with code, coding files are all tiny, right? The only time you get something big is when you're doing sound or video or images or, That's about it, those are the only things that are actually really, really big. Everything else is, it's a lie. Um, if you had data that was more than 4K, then you're like, that's more data than a human can actually understand, so. Must be in the form of an image or a sound, otherwise it's kind of meaningless. Um, anyway, so how big are they? So what they did is they were like, OK, well, what if we, what if we, uh, we break the blocks into mini blocks, right? So we basically take our blocks of memory and then we divide them by 4 and then we got little subblocks that go within the blocks. And then you can like have a little file and it goes in the first fragment of a block, and you're like, and then I've got another file and it goes in the second fragment of a block. Um, this is really dumb, broadly, um, it does work, you can, you know, save a little bit of space. Specifically nowadays it makes no sense because we've got more space than we could ever know what to do with, um, because the problem is like when you start, Growing files, then things become really awkward because then you're like, oh OK, wait, hm, alright, it's slightly bigger now. It needs 22 fragments within a block, I need two little subblocks. Um, or, you know, like, oh wait, now it's gone from needing 2 to 3, so I need to break it out into its own data block. And then I've got to move some files from one place in the hard drive to another place in the hard drive. Right, um, and so once they grow, you have to like make sure that it all adds up into, you know, proper data blocks once they're above a certain size. Um, so, you know, moving all of these files around means that your hard drive is doing busy work, which in specifically the case of a hard drive, means that it's copying something from one part of the hard drive to another part of the hard drive, and you never want your operating system to be doing that for no reason. Um, so yeah, it's, it's kind of OK. Um, the other one that they found, which was kind of, you know, like this is actually one of the more interesting kinds of like, I don't know, like minor details, I guess, right? So if we think about hard drives, right, they're little discs, right? And so one of the things that happened originally is people would store it like you would have it on the left, right, so if I had 12 blocks on a hard drive, you would store them 1 to 12, right? Um, but this is actually the worst possible way of storing data on a hard drive, and the reason is, is because if I want to read block zero, right, I run along the disk to the end of block 0, and then I go, I want to read block 1. But the problem is, I've probably taken one step too far. And now block 1 is as far away as you possibly can, so I've got to run all the way around the disk like. Do my little lap and then I get to block 1 and I'm like, OK, I'm at block 1, read block 1 now read block. Oh damn it, read block 2. Alright, alright, alright, alright, oh, here we go. That is read block 2, woo, read block, ah damn it, right, and then it would just go round in circles. So what you do is you, um, you space them out. So basically you have enough time between block 0 and block 1 to commit the read instructions so that you, by the time you get to block 1. Um, or, you know, little sector one or whatever you wanna call it, um. You have enough time where there is a 6, between 0 and 1 in order to actually get ready to read from 1, after you've read 0. Now, one other thing that I think I, I should point out. Is a lot of this stuff, a lot of this stuff relies on things that are not true anymore. Right, so for example, where's this? OK, so this assumes that the operating system knows the physical layout of the hard drive, right? And hard drives go out of their way to not let the operating system know what their physical layout are, right, there's a level of abstraction now, right? So this is the kind of stuff that you can't even know, right? So a lot of, you know, like, based on this, right, like so, so you know, like, the cylindrical nature of it, right, so in, in practice what they do is they just do it like that, so when they, if we're gonna do the blocks, we, we don't even know. If these blocks actually mean anything and that the hard drive has set these blocks up in ways that make sense. So we, we've got sort of like a tacit assumption that, well if I go from address 0 to 256, please hard drive, could you make 0 to 256 in vaguely the same place on your device? Right, so that's one of the like sort of underlying assumptions. Um, anyway, where are we? Yeah, um, and then this is, this is where you get into like crazy business where it's like, well actually, I don't need to know, I don't need to know how you're laid out if I can just measure how crappy it is if I do it. Right, like, so, so what you can do is you can be like OK well I'll try and access the hard drive and then I'll see how long it takes, and then I'll make my own scheme for how far away everything is, um. And there's some other things you can do, you know, like. Offering and stuff like that, but anyway, I think we're getting close to the end. Of this, what's left. Uh, fixed that. I had a fixed length. Oh yeah, alright, yeah, OK. This, now we're getting into like weeds, right? Like just fun, fun weeds, right? Like, so in original operating systems, the, like it makes sense that this is true, right? Um, and I have, has anyone been a victim of this, by the way, like of, OK, um, just to. Contextualize, it turns out in operating systems, early operating systems, in fact, pretty much all operating systems, um, there is finite space. And so the names of files are finite, right? Like as in you need to choose a buffer. How long is my file going to be? How many, how many bytes do I have per file name, right? Has anyone worked in a file system where they got in trouble because their their file name was too long? Ah, only me. Oh, wait, what, 2, yes, 30 yeah, alright. This is a real thing, right, like as in I was working on a VMS system um for defense at one point in time, and basically we had, you know, there was this thing where we're like trying to save our log files and everything was crashing and we're just like, why is nothing working, right, cause this is the kind of error that's not obvious when you are like layers deep in different kinds of tools and you're just like, and then I tried to save the file and it wouldn't let me save the file halfway through the, the trial, and you're like, where's the bug in the code, why would it, you know, where's my code, oh here's my code, why would it stop letting me save something mid, At trial 113, that makes no sense, right? And you're like, oh OK, it's because the date or the time, was slightly too long and there are too many directories, and then you've got to take stuff and then have less directories, because otherwise it stuffs up. Um. So yeah, FFS adds a length field so that you can make your names as long as you want. Um, and in classic computer science, um, style, what you do is like if you have a whole bunch of things that have short names, you write the long name in the space that the short name is not using, right? Um, because you're that like obsessed with space, um. Oh, and the other, the other thing that's kind of um. And we'll, we'll deal with this a bit when we're talking about journaling. And um FSCK is um the other thing it introduces is atomic renaming, which, because apparently there was a period where the, you know, you would change the name of the file and you'd be like, I'm going to change, rename this file from this name to that name. And then the power would go out, and then you were doomed, right? Because It would like create, it would like delete the old file and then create the new file and you could break it in between and the the old file would be gone and you'd be like ah, right, so like the old file would be in memory or something like that, so it would, it would take the old file and it would put it into memory or something like this and then you create a new file, and then the power goes out, memory dies, and then the, the new file is never there. Um, and so the in it introduced this atomic renaming which is basically, You know, you make sure that all the directories are happy and locked, and then you, you know, update Iodes and you update file extensions and you update everything in the correct order, right? Um, and you do it all at once, and then you commit the changes, right, so you change the names of everything simultaneously and that way you don't lose the file. So that's another little, I don't know, bonus add-on, um. So if I had to summarize it, we have symbolic links, we have divided into these blocks or groups, um, You get common files together, you split up big files, and long file names, and yeah, it, it's, it's, you know, um, for those of you who don't know, I like, I only learned that in this subject, that the, when you install Linux, it could be EX2, EXT3, sorry, EXT2, EXT3, EXT4. I had not learnt about the names of Linux operating systems, like vaguely, you know, like I knew there was Windows 10 and Windows 11, there's like OS 10 and OS 11. It's like for me it's just Ubuntu versions 20.04, right, but you know like that's how I think about it, right? But apparently there are these, you know, EXT2s and EXT3s and you can look them up and see what they change from operating system to operating system and it's interesting some of the variations between them and EXT4 obviously cause that's the slightly more newer one. cool. Any questions about any of that? Yeah, I didn't think so. Alright, so last thing we're gonna cover today is all about crash consistency. OK, I love AI art by the way, cos you can make it do things now, right, where I don't even have to like, I don't have to get me a little art tool out and try and draw something, I'll be like, lightning bolt coming out of a hard drive, and it's like, yeah, you can do it. Not great, but good enough, um. You can read this. Basically, you know, like we've been, we've been laboring under the delusion that our hardware works, right? You know, um, basically, uh, It is, it is interesting that if you make the assumption that the power can die at any point. In a computer's lifetime, the number of problems that can be caused is enormous. There are an enormous number of problems that can be caused, right? Um, basically everything will break, um. If you don't plan for it, right, um, so, Basically, the rest of this lecture is all about, we're going to assume at any given point in time, there is this evil person who will zap your computer and turn the power off at every step. Of operation, so that we know that regardless of when they do that, we're OK, right? Like so that's, that's our like, I don't know, goal. Um, so it doesn't matter when you're doing it, right? This, the, you know, the lightning bolt or you know, the power outage can occur at any step, right, on any line of instruction, halfway through an instruction if you want. Um. And the two methods we're going to look about, look at. To Ameliorate, I won't say solve, ameliorate, that's a fancy word for make slightly better, um, uh FSCK and journaling. OK, so, To explain what's going on here. We covered raid in week 8, I think, right? And in raid, we, we set up the notion of something like mirroring, right? Where we would have two hard drives with exactly the same data on both hard drives. So we're not talking about the hard drive dying, and we, oh, it's fine, we have a backup. Right? All this does is say, say if the hard drive were to just spontaneously explode, everything would be still fine because I have a backup hard drive with everything on it. What we're doing now is we're doing sort of like, imagine that we have a bitmap, right? So this is within our hard drive, right, so this is the bitmap, we're saying that, you know, I have the green, the orangey pink color. RG What color is that? Flesh tone, I don't know, light orange. Um, and then we have blue, right? And this bitmap represents what the hard drive thinks we have as data, right? And then we have the data in the block, the equivalent blocks, right, so this bitmap is actually a lot smaller than the actual data. Each, each actual data block is like a page of data, whereas the bitmap is just like a 1 or a 0 saying I think there is some data here, and then the actual data is the actual data that's there. OK. I have a power outage, and the power outage occurs after I update the bitmap, but before I write the data, right? So now the hard drive thinks I've used this little red bit of data, but I haven't actually copied anything in there, right? Cause all I did is I said, I'm going to use this bit, this bit, I've reserved this bit, I've, you know, like, Uh, what do you call it? It's like, I have reserved a locker at the airport, but I put nothing in it, right? And so, and so no one can use it now, right? Um. It's sort of the analogy, I guess, or like maybe it's locked, but I don't have the key, I don't know. Anyway, um, so this is the problem that we've got, right? And having a backup isn't going to solve this problem because if I have a backup, I'll just have two versions of this crappy situation, right? Um, and the question is, what do I do, right, because I turn my machine on, right, and I look at this and I'll be like, oh OK, I have data here, I guess I can read from it. And I go to the data and it's just random ones and zeros, yeah? Or I'd be like, oh well, yeah, but I know that I didn't write the data somehow by magic. And I know that data is wrong, right? What is it supposed to be? Do I, have I not used it? How do I tell if that data's crap? Well I can't tell the data's crap cos it's just random data. OK. Same thing applies to iNotes, right, like, so, you know, you can have, you know, like we've got to write the bitmap. I've got my I nodes, the I nodes are pointing at the data blocks. I could have not written the Iode, or I could have the I node and not wri written the data, or I could have the the I node and the data but not written the bitmap, right? So all of these things are possible, yeah? Um, and yeah, with raid you can have this similar kind of problem, right? Like if I have a raid 1 drive or a raid 5 drive, I could, you know, potentially update one, the power goes out and I don't update the other. So now my parity bit is out for the raid 5 or my mirror is wrong, right? Like as in I've got 22 different hard drives, even though I've got a mirror, right? Um. So, if we think about it, whenever we do anything with data, when we're ever changing data, what we're doing, we're doing three things. One, we have to update the bitmap. Which bit of data are we modifying? Then we have to do the Iode bitmap as well, right, like which I nodes are we using? It's also in the bitmap. Um, but we also have to update the Iodes, so the Iodes, you know, they have the right directories, they have the right, you know, like I'm a child with the right directory. I, I point at these data blocks, and then you need to have the data itself, the data blocks with actual data in it. Um, and so what could happen is you could have any of these situations. You could also have it so none of them get updated and I don't care, or all of them get updated and I don't care. But if I have only the bitmap updated or only the iNodees updated or only the data updated or I have the bitmap and the iNode or the bitmap and the data or the iNode and the data, all of those situations are bad, right? And I have to do something about them. So, And this is just a description of kinds of what, what it kind of means to have, like, if I only have the bitmap, it means that I don't have any data in this bit of, like, there is data there obviously because there's bits there, but it doesn't mean anything, so it's useless data. Um, there's no I node there, but I'm saying that this block is being used by somebody, right, um, and no-one knows who's using it, right? Um, I nodes. Yeah, um, it's not as bad. Uh, if I only have data, it means that the data is there, but like I could easily overwrite it because I haven't told myself that I shouldn't overwrite it. Um, and so the data could still be there and maybe I can, I don't know, retrieve it somehow. Um, what is it? BitMap and iNode. So if I have the Bitmap and the iNode, it means I've used, you know, like, I've said I've used data but I'm not actually using it and the data there is crap. Um, if I have the bitmap and the data, it could just be pointing to garbage, and what's INode and data? Another file may overwrite. Oh yeah, yeah, same, same as before. OK. So, here's the logic, we have the FSCK. So the FSCK is basically saying, and this is, this is one of those, um, I don't know if you've ever seen it, right, cos, um, I don't know, computers don't crash as much as they used to, but. Basically speaking, when you shutdown your computer, right, who has seen their computer go, hey, hey, hey, hey, before you shutdown, would you like to shutdown everything properly, right? Every everyone's done this, right, like, literally everyone I'm sure, right? I, you haven't shut down properly, right? And the, the logic behind it is that basically, when a computer turns on, what you wanna do is you want to set a flag that says, did you shutdown properly? No. So it'll set that to false, you have not shutdown properly. And when you do the shutdown, when you shutdown, it'll go, yes, I shutdown properly, right? So as soon as you turn on, you, you basically set a flag saying, I've stuffed up, right? And then before you shut down, you say, no, no, I didn't actually stuff up, it was a lie, right? So if you crash anytime between. Starting up and, you know, actually shutting down, it means that the computer knows that you stuffed up, right, like as in it's basically saying a flag going, you, you need to check, you need to check, you need to, no you don't need to check. Right, um, and if you crash while it's got its little flag up, then you're gonna have to check. Alright, so what are we gonna do? What we're gonna do is that in the event that the flag is up, we know that there's been a crash. And we're going to try and use the power of logic to overcome the crash. Um, not too bad. OK, so what can we fix, right? Like after the crash, we scan the whole disc for the contradictions, and then we fix them, fix them. Right, and then we keep the file system offline until FSCK completes, right? So we're basically like, oh, something went wrong, excuse me, can you give me a minute? I need to fix your hard drive, right? Um, and now we're gonna go and off and fix the hard drive. OK, well let's, let's see what we can get away with, right? There are a few things that we can check, right? Um. Generic things, like if I'm an I node, I can be like, hey, do I have a parent, does my parent have a parent, does my parent have a parent, does my parent have a parent? Is one of those parents the root node? Alright, we're all good, right, because you can have a situation where an I node's like I have a parent, but my parent doesn't have a parent. I'm just a floating I node in the middle of nowhere, right? Um, and so that would be something where you can be like, ah, ah, that's, that's not right. Um, you can check that every every directory has a dot dot and a, you know, a, a dot and a slash dot dot, right, like all of those files are there, um. Uh, what do you call it, with the Iode you can test if you know where it's pointing, you have an I node and you know where it points, you know where the data block is, you can then go to the bitmap and be like, hey, is the data block that I, the Iode said I am using. Currently being used by the bitmap, you'd be like, OK, so that's another thing I can check. So you get the general idea, is that like it's like, it's kind of a Sherlock Holmes moment where you're like, oh what do I know, and what do I not know, so what can I deduce, um. And directories, you know, like you can look, go into a directory and be like, I have all these files in the directory. Do they point at things that are meaningful? And if they don't, you know, if I have a directory and it's got a file and that file doesn't exist or doesn't point to anything, um, then I can be like, hey, maybe this is where the problem occurred, right? So there are a couple of things like this where you can be like, hey, I have 2 directories and they both point at the same I know because I've got two kinds of links, and I'd be like, hang on, no, no, no, no, no, I can update the link count to 2, and that's fine, right, like as in that would be my solution. I've got, I've, I've got 2 links. I say I've only got 1, maybe I didn't update this value. I think it makes sense, I can update it to 2. So far so good, um. I have an I node. It's got a link count of one, so it thinks someone's pointing at it, but nobody is, right? So what can I do then? Um. Do I delete it? Do I, do I do what? The standard method is that on most systems there is a place called lost and found, and it's basically like, I found this file, I don't know where it was supposed to be, so I put it in this random directory called lost and found. And so when you reboot your computer, it can be like, I checked, I couldn't find anything, you might want to check your lost and found directory to see things that I have just discovered that were there, maybe something to do with something you were doing. Um. If you have a problem with the the bitmap and it's not matching the data, um, you could fix it, right, and you could say well actually I have data, the bitmap should be a one, right? So that one's not too bad, um. You can have two I nodes pointing to one bit of data and then you'd be like home. I've got 2 I nodes and they're pointing at the same bit of data. I could Just give the second Iode its own bit of data to point out. Who finds this a satisfactory solution? Who finds it an unsatisfactory solution. Yeah, 1, alright, that's enough. Uh, that, that seems reasonable. I think, I think like, uh, I think it is a bit unsatisfactory because there's a level where you're like, I had an I node and I have two things and they were originally pointing at the same thing, and now, now why are they pointing at the same block of data? Like why do I have two I nodes pointing at the same block of data? Are they supposed to point at the same block of data? Where, if they aren't, which one? Which one do I give a new block of data to, right? Like which one? And which, what's in that data block? Like I'll just give you some, you know I've got an Iode. I, I was supposed to have some data and I don't have my own data. I'm, I'm trying to pretend that someone else's data is my data, but you'll just give me some new data. Like that's not gonna cause any problems, yeah, that's a lie, that's definitely gonna cause some problems. Um. Yeah, exactly, right, and it's very suspicious, suspicious hell. Um, you can have like bad pointers that just don't point anywhere and you can just be like, alright, fine, die. Um So the fundamental problem with FSCK as like a paradigm for solving the problem is that while there are some situations where it is logical to fix, where you can be like, oh I'm missing this part, I'm missing that part, I have this and that, and there is an action that you can take that kind of makes sense, there are circumstances where it just doesn't make sense, where it's ambiguous, you don't know actually what went wrong. And you, you can have a symptom where two, there are two possibilities of what the problem was, and you can't really decide between the two, right? Um, and so it achieves consistency, but it doesn't achieve correctness, like you can definitely make it so that the hard drive is now a hard drive and it is consistent and everything makes sense, for every Iode there is data, for every data there is an Iode, for every bitmap there is data, for every, Data, there is a bitmap for every I know there's data and blah blah blah blah blah, right, um, and the other problem is that it's kind of slow, right, because whenever your computer crashes, when it reboots, it's gonna be like, excuse me, I'm just checking every file just in case, right, because it's gonna be checking a lot, right? um and because in back in the day computers used to crash a lot, this was very annoying, um. That Wait what? Oh God, I don't even wanna think about that, um. No, it should be fine, right, because when it, when it, when, OK, so when FSCK is running, when the computer turns on, it'll go into I might crash mode, right? And so while FSCK is running, if it crashes, when you reboot it, it'll go back straight into FSCK mode and try again. Right, and that you, that's a, that's a fair question. I'm sure there's an edge case. I'm sure there's an edge case where when that happens it makes it worse, right, because it's trying to fix something and in the process it crashes halfway through the fix, and now it's in an even more broken state than it was before it tried to do the fix. That is, I love that. That is a good question. Any other questions for me before I? Alright, so the next one we're gonna look at is journaling, right? And journaling is where someone said, you know what, it's not good enough to try and fix the problem after it's already occurred, I should just try and prevent the problem from occurring in the first place. Um, and this is the logic, right, so. We want to perform recovery, we don't want to read the whole disc, we want to be correct, um. And the strategy is what we need to do is achieve essentially atomicity, right, so we need to get back to this idea of, well, when I write something for the disk, I need to update. The bitmap, I need to update the iNote, I need to update the data, and I can't do half of that. I would rather be at the start where I've done none of it, or at the end where I have done all of it. But I do not want to be halfway through under any circumstances, right? Rule number one is we never delete anything, goddamn it, right? All new data has to be where it is supposed to be before we delete anything. Right? So we're gonna, we're gonna make sure that, but you know, like if we're gonna copy and paste or move something, the new thing emerges prior to the old thing disappearing, right? Um, and rule number 2 is what we're gonna do is we're gonna come up with a system where we basically say what we're gonna do before we do it. So what I'll do is I'll say, you know what I'm gonna do? I'm going to update. The iNote, I'm going to update the bitmap, and then I'm going to update the data, right? Then I crash. And I come back and it goes, oh, you said you were going to update the iNote, the bitmap and the data. But they weren't updated. Ah, so I can just rerun that instruction, right? And this is how we're gonna sort of basically get the idea of it. If I do 12 and 3, we're all good, right? I'm going to say what I will do before I do it. Um, as an example, you can imagine I wanna update A to A, B to B, and C to C, and I have a power failure, which basically means I end up with A to A, B to B, and C to C, right? No good, right, this is the old paradigm, right? What we're gonna do is we're gonna create the concept of a transaction, right, and I'm going to write out a transaction. I'm gonna say, and the, the B and the E here, TXB and TXE just mean beginning and end, I think, right, like that was my assumption, right? Um, transaction beginning, transaction end. So this is gonna be one little bit block of text and it's gonna have A, B, C, and I'm gonna mark both ends. So now what's gonna happen is you can um basically, Oh yeah, and so the other thing is, we've checkpointing, right, so the, the logic behind this is that after I've done A, B, and C, I'm going to send a checkpoint, like a basically a mark is complete, to say that I've done this thing, right? Like as in, so part of the process is I do the, the data copy, and then once I finish the data copy, then I go, I did the data copy, right? Um, and that's it, right? So this is broadly what journaling consists of. So let's have a look at some of the problems, um. Problem number one is I hate hard drives, right? As we've discussed before, It turns out, gloriously, that you can write something to a hard drive, and the hard drive will be like, just a second, I think it would be much smarter to put this bit here and then put that bit here, and then put this bit here and then go back and then put this bit here. And as a consequence, you can actually end up with problems within your transactions, where you write out the transaction. But you haven't actually written the transaction, right? So you've written the start so it looks good and the end so it looks good, but the thing in the middle could just be garbage, right? Because it's, you know, a hard drive. Um, and this, uh, I guess I, I've kind of skipped over as a fact, is this, these, these transactions, where are the trans transactions going to be stored? They're gonna be stored on a hard drive somewhere, right? So, we need to make sure that when we store a transaction it's actually stored. OK, so that's cool and it's gonna be in a little journaling section of our hard drive, but yeah, so this is problem number 1, right? And so the solution here is what we do is we basically say, I'm going to store everything up until C as one transaction. Right, so I'm gonna go, hey, this is what I'm gonna do. And then as a second supplementary thing, I'm going to add the little tag at the end, the TXE. Now hard drives can guarantee the atomicity of a single right like this, right? So the TXE on the end is either going to be there or it is not going to be there. You can't have a half TXE. You can have a half ABC, right, like you can lose half a B, right? But these are the two possibilities. Either, right, there's a there's a power failure when I lose the B and there's no TXE at the end, or, um, basically I've done TXB and then A, B, and C, and then I've added the TXE on the end as a single step after I've done the other stuff, and I can guarantee if I can see the TXE then A, B, and C have to be there, right? So I'm just gonna break it up into two sections. OK, cool, so we do separate it into what I call most and the tail. Yeah. Um, just out of, you know, we're gonna add another block to our glorious hard drive paradigm, right, so we're gonna have the super block, and then we're gonna have the journal, and then we have groups, right? Um, so it's basically just another part of the hard drive. Believe it or not, in the journal, right, in early journaling systems, I don't think it's in all journaling systems now, but in certainly in early journaling systems, they actually wrote all the data into the journal. So they like wrote the data they want to write into the journal that they were gonna write. So they're like, I will copy all the data into the journal, and then I will copy all the data back into the hard drive. Hopefully everyone is immediately going, hang on a second, that sounds like a garbage solution, right? You're like, hang on. Am I really going to write every bit of data twice? Once in the journal and once not in the journal, are you serious? Uh, and that is one of the problems with journaling. Um, but we'll see how we can sort of overcome a little bit of that. Um, but you can see here that basically now to make it look a bit more in uh less generic, I've got TXB and then update iNote, update Bitmap, update data. So how does this work in the case of recovery? Well, let's think about it here, right? So we write the journal most, we write the journal end or the tail, and then we write stuff, and then we do the checkpoint, right? So if we crash after writing the beginning of the journal, but not before um we crash before, before we write the little TXE at the end, um, we can just discard the journal entry and say, oh we tried to do something and it didn't work, right? Like we were going to do something, but we never got to the end of that instruction, so I don't have to do it. Um, and as a user it's not too bad because then you can go back into your like logs and be like oh I tried to do the thing and it never actually happened, right? But the hard drive is still consistent. The downside is I might lose a little bit of work, I guess. Um. The other option is that we crash after we've written the journal end, right? But what's really cool about that is that if we've just, we crash after we've written the end of the journal, like the little tail bit, then we can just write the journal. We we boot the computer up and we were like, I was gonna do this and I didn't do it. So now I'm just gonna do it. Right? So I can just replay that instruction, right? So it'll just copy the data to the disk. Um, if it crashes after I write stuff, this is probably a little bit inefficient because after I've written stuff, but before I've told the system that I've finished writing, I've written the data. But the thing is I can just replay again the updates and even though the data's already there, I'll just copy the data twice, right, so I'll just be like, oh I crashed. So I'll just, I'll just make sure, I'll write it out all again. Um, There's a possibility that you only wrote half the data, so it would make sense to do it this way. Um, but you just redo the, um. The journal entry and then we're all good, and then if it crashes after the checkpoint, we don't care. So I've already illustrated, OK. You audience participation. Somebody answer this question, what's the problem with journaling? I've already given you the answer. Overhead, yeah, it's, it's slow, right? I've got, I've got to organize the journal, yay. Oh, it's great. OK, so everything, there are 3 kinds, right? So I'm gonna go through 3 kinds of journaling, right? One's called data journaling, and that is where you literally write everything to the journal. So this sounds awful, right? On the bright side, it is always correct, right, so even though it's nominally basically twice as slow, right, because every time you write anything to the hard drive, you're basically writing it twice, once to the journal, and once to the actual hard drive. It means that you will never have a problem, right? This, this computer. Will never be inconsistent, 1, and #2 is, as soon as you've said that you're going to do something, you will end up doing it, right? So the only time that you can lose data is if you, you crash halfway through saying what you want to do. Um, so it's pretty good, um, but it is quite slow, right, because we're basically halving our throughput, which nowadays again is not that much of an issue. There are big issues for SSDs. Um, there's order journaling, OK, so this is the, A funny, kind of weird way. Um, one of the things that you might want to do, cause they're both of these two next ones, write back and ordered, um, they make the assumption that you're not going to write the data into the journal. You're just gonna write the I node and the bitmap, right? Now this is dangerous, right, we can see why this is dangerous because we're not keeping a copy of the data. In ordered journaling, what we do is we write the data first. Yeah. So basically the way that it works is you're like, OK, I want to copy something to the hard drive. The first thing I'm gonna do is gonna write the the the data. And then the next thing I'm gonna do is write the journal, and then I'm going to do the rest of the stuff, right? Now the advantage of this process is that like basically if it crashes, Early, the data is still there, right, so that's cool, um. And you never get the situation where you've journaled something but the data wasn't there, right, like that's the problem, like, like you can imagine a situation where you're like, well I said I was gonna update the the Bitmap and the iNoe. And I was gonna do that and I copied that, but I didn't actually do the data for it. Um, and so you copy it, but like nothing actually happens and you don't have any data to copy, so you just copy make the changes to the Iode and the, the bitmap and there's no data there, right? Um, so technically you can still lose some of the new data, but again, it's kind of, you know, it's a single transaction, it's not that bad. Um, the last one is, um, and it's faster than data journaling. Uh, the last one is write back journaling, which is technically the fastest because it basically goes, hey, hard drive, do it in whatever order you think is the fastest, right? Um, and occasionally that order will be, oh, I'll write the journal and then I won't write the data, and then I'll crash, and then I'll do the data and I what I'll, so I'll, I'll execute the journal because I crashed mid-journal and I, and, and there's no data there, right? Um. And so you can end up with corrupted and nonsense data, but it is definitely the fastest. Um, and it can save you sometimes, right, like as in as a general rule it will save you sometimes, so, um, different systems will employ different journaling schemas, I guess, in order, depending on what their performance requirements are. If they wanna be really fast and they don't care about the data that much, they'll use writeback. If they're very like methodical and they, you know, every bit of data matters, then they'll use data generally. Um, The HDD, you know, like. Hard drives, you're more likely or like tempted to use right-back journaling because it is faster, um. The SSD we do have one problem, right, which is a very different problem, it's nothing to do with speed. It is basically that that we've now decided that we've got this one bit of memory called the journal, and we're going to write every transaction we do on the computer into the journal first. Before we copy it somewhere else in the computer, which means that that bit of memory is going to die, right? Because you know, like, we know from lectures on SSDs, we're not allowed to do 10,000 operations on any um frame within an SSD because if we do, that frame will die, right? Well, if we have a frame. That contains a journal. Instead of being able to write to each frame 10,000 times, we can write a total of 10,000 frames, right? Which means that we're going to have to work out a way of moving our journal around like a nutcase, right? Um, because basically it's going to double the wear labeling because we're gonna be, you know, for every time we do a write, we're gonna be doing a journaling, right. Which is not great, but not the end of the world, but what we do need to do is make sure the journal is not being persistently written into the same location, over and over and over again, um, because, yeah, it'll get destroyed really quickly and then the journal will become corrupt, and then the whole hard drive will become useless. Um, Uh, yeah, this is kind of minor again, like if you can imagine the journal, we use a circular buffer because, because obviously, right, it's, it's a finite length page thing, so we've got all these little journal entries and we're just gonna, you know, keep appending them to the end, we'll keep track of where the, the end of the, the buffer is and we'll just keep going around and then once we've checkpointed them, we'll remove the old ones and we go around in a circular queue. Um, Oh yeah, and there's one other optimization that you can do because you can imagine that like it's kind of efficient, inefficient to be like, write the journal, write the data, write the journal, write the data for really, really small files, and so sometimes it makes sense for a hard drive that might be like, OK, give me like 10 things, and then I'll do them all at once, right? Um, so there is some batching that can go on. Um, obviously, if you start batching, Then you can start losing more data, right, because you're like, oh well there's these 10 things I didn't do, right? Um, depending on which kind you're doing, if you were doing like data batching, uh, data journaling, I guess you wouldn't lose anything, but it would mean that when you reboot, you have to like redo a whole bunch of stuff. But if you were doing write-back journaling, you would end up losing a lot. Uh Yeah, there's some other things as well, like I remember like this, this one was a bit weird, right, like, so basically the idea is that like, OK, now we're getting to the point where we have to think about, you know, like is my journal correct or not? Right? Like is in because one of the other issues is that computers sometimes suck. Um, and so you might want to add a checksum to the end of your journal, especially if it's a long circular buffer of journal entries, right? Just to make sure that the, the buffer makes sense. So like if the journal is corrupted, what do you do? Um, one of the things is you apply a checksum. You can imagine that like, It is possible that one bit on a computer can stuff up, right, and if that bit is your journal, then that can be really bad, right, like, um, and so having a um a checksum to detect when the journal is corrupt, um, is very important. Um. Yeah, there's This is where we get into like some high-level opttimisations, which is like, well, what if what you're trying to do is just update the size of the file, and you're not actually trying to update the data. Um, what you can do is you can create a high-level logical journaling language so that instead of just saying what you're going to do sort of in an explicit way, you sort of say it in a high level way. And the advantage of that is that like if you say I want to just change like a file size, then I don't have to like. Recopy all the data for the file, I don't have to re-update all the Ios, I don't have to re-update all the blocks, I can just change one number in one file, right? Um, so, what you can do is you can make it so that the journal can express this kind of minor change in a very small amount of space rather than basically copying all of the data associated with that file. Um, and there's a bunch of things you can do with logical journaling. Um, in terms of how it plays into the system, the journaling system is usually part of the file system. Um, And The journal itself is aware from an abstraction point of view, the journal's not like a completely independent system. The journal should know how the file system works, right, so it is, you know, like it, there's some um. Coupling that goes on here, right, because the journal kind of needs to know stuff about the operating system, which means it's not like an independent, you know, like I work for any operating system journal, it's like I work for this operating system journal, um, And so, you know, um. Yeah, so like you you can see here it says the entries can can contain transaction IDs, which is fine, whatever. But like it can contain block numbers and operation types and a bunch of stuff that kind of implies that it knows a lot about the um file system itself, um. And then, yeah. The last little bit is that, so what we're doing is we're fixing data inconsistency in the sense that we tried to copy something and we, we're keeping like sort of redundant information of things that need to be synced up, I nodes, data and bitmaps. But if we get a bit flip in the, in the hard drive, we cannot fix that with journaling, right, because it's basically I try, try to, firstly, does everyone know what I mean when I say bit flip? OK, so a bit flip is I have a bit of hard drive and because of physics, a 1 turns to a 0 for no obvious reason. Yeah. Huh? Yeah, cosmic rays, you know, like, basically gremlins did it. But yeah, yeah, you know, like, uh, the physics of, you know, like all of these systems are designed to be tuned to like, you know, to 99.999%, but occasionally everything will wobble in the wrong way or, you know, like, I don't know, some neutrino somewhere will interact with something, who knows. Um, and a bit in a computer will occasionally be wrong. It'll just change from the positive state to the negative state, um. And journaling cannot fix that problem, right, like it, so that's the kind of problem that you could fix with Raid, because you'd get a bit flip in one computer and it wouldn't happen in the other computer, and you'd be like, hey, hey, hey, something's wrong. Right, you would detect it, I don't know whether you'd be able to fix it with single parody, um. Cos you wouldn't know whether the bit flip was in the um. The uh the parody machine or in the actual machine, if you ever go on to study, you guys are all computer scientists, right? Let's assume that you go on to study communications theory, um, you can actually generate like more complicated things like check sums and stuff, um, that have multiple parity bits that allow you to actually fix a single error that you find, um, and that might be a way that you could get around that. Um. And that's it, I think we're at the end. Yeah. Any questions? I will assume that the questions will come at the end. Um, have a good weekend everybody and, um, I don't know, good luck for your, oh, housekeeping. There's a quiz today. Yeah, I knew there was a thing. Has, has anyone done the quiz? Alright, good, alright, that's all I wanted to know, like cause like I, I sort of get to this point of like. Um, sometimes it's not open or something, right, it's the kind of thing that I would do. All right. Um, have a good weekend and good luck with your quiz if you haven't done it, and if you have done it, I hope you did well. Um, see you guys later.
