SPEAKER 0
Uh, what do you call it for, who, who here has done their workshop prep for next week? OK, cool. Um, I, oh, the recording's about to start, so I'll be able to do the actual official recording, um. In a minute. I had, OK, here we go. Alright. Hi everyone, welcome to operating systems. Um, OK, so just a few things on housekeeping. Uh, number one, assignment 2 is out. I'm going to do the final cutoff for groups this afternoon. I've added some extra pair groups, so if you want to be in a pair explicitly, I suggest you move from wherever you are to a pair group, um, because otherwise I'm just gonna click a button that could like randomly assign everyone, um. If, if, uh, what do you call it, uh, yeah, so, so, yeah, I guess just warning, I don't know if you, if you're at this lecture, I get the impression that you're probably already in a group, right? Like that seems to be like a, a sensible kind of assumption. Um, the other thing that I got a question on Piazza, but I thought I'd just repeat it here so people actually pay attention to it. OK, so. This is so nice. Why, why do I, what? OK, um, I'm gonna, I'm gonna break this today I reckon I just walked past it and not paying attention. Um, so, uh, for the workshops, right, so there is this difference between the idea of preparation and participation, right? So I got a question on the piazza, right, which was like, OK, I don't understand how this is working, right, so let let me explain how I, I view this and how I think of this. So the purpose of the. Preparation component of the workshops is so that you come to the workshops prepared having done something right, um, at university, if I don't have a like a little piece of assessment associated with preparation, then the vast majority of students will come to the workshop unprepared and so when they're in the workshop they will not know what they're doing, right? So that that's part of it. The second part is, uh, participation, right, so preparation I think makes sense to everyone, right, there are some questions. You try and do the questions, if you can do the questions, you do them, and if you can't do the questions you go, you write, I tried this, but it was really hard and I didn't know what to do, right? And then you upload that to my uni. For participation it's a bit more complicated because there are again two kinds of students. One is the kind of student who's like, I didn't understand what I was doing, right? And for them it's pretty straightforward. What you do is you get a piece of paper out and you take notes of the tutor's solution, you take a photo of those notes and the tutor at the same time, and then you upload it to my uni, not very complicated. If you have already done all of the questions and you're just sitting there going, I'm bored, I already know all of this, the tutor has officially a bonus question, right? So there is a bonus question for these students. So just ask the student, uh, the tutor to put the bonus question up. They'll put the bonus question up and while you're not paying attention to them explaining all the answers to the questions that you already know the answers to. Um, you can do that bonu question. Alternatively, you can, I don't know, take your part your original preparation and write, yeah, hey, I was right, I did it exactly how the tutor said I would. I am the greatest and draw a picture or do something. I don't really care what, something to indicate that you participated. The reason that I am doing it this way rather than just taking a photo of. The room is because all that taking a photo of the room does is demonstrated that you attended, right? And I've been in many tutorials giving many workshops, um, and I am very familiar with the student who's like, I'm on my phone, I'm on my phone, I'm here to get a mark for doing nothing, and they don't pay attention to the entire, um, workshop, and I don't think that that is a behaviour that I should encourage, right? And I think that the amount of effort it takes to write on a piece of paper is quite low and take a photo is also quite low, so that is. An explanation of what it means by preparation participation, I will also answer this on the forum. Um, any, oh yes. No, I, I've got to give everyone the benefit of the doubt for workshop 1 and 2, right, like as in, because if you've been giving silly instructions, I don't expect you to go back and change work that you've done in the past, right? Um, All right. Uh, right, uh, so assignments, workshops, quiz, there's gonna be another quiz next week on Friday, same deal as the quiz last week on Friday, um. This time it's going to have a uh a due date so that it appears more readily in your My Uni. So um hopefully it's already visible. Has anyone seen their version of that quiz says there's gonna be a quiz next Friday? Yeah, alright, cool. Uh, and I think that's it. Alright, so let's get on to our lecture for today. Um, today we're gonna be talking about semaphores. I don't think you're gonna learn anything in this lecture, maybe, I don't know. I shouldn't, I shouldn't premise it this way. Everything in this lecture is pretty obvious if you understood the last lecture, right? Because all I'm gonna say is what a semaphore is, and you're gonna be like, oh yeah, alright, um. Ah, first things first, I have to advertise, this is Ravi's study programme, um, basically there's an information session. In 2 weeks I guess, what what's the dated like the 3rd or the 4th, um, in Braggs, um, for those of you who don't know about Ravi's study programme, basically Ravi is a former student of mine. I taught him ADSA back in 2015. Um, so, uh, basically, and he's a, he was one of those students who asked questions and asked me to do things differently, so it's a good student. Um, basically, Ravi's study programme is all about, I guess, job interviews, is the best way of describing it, so it's basically a training programme to understand how to get jobs, right? Um, and people who have done Ravi's study programme have gone on to work at places like Google and Microsoft and Facebook and. A whole bunch of other really high-end places, so if you are interested in getting those kinds of jobs, uh, at Lassian, um, then I suggest that you just go to Ravi's study. It says there's free pizza and drinks, so I don't know why you wouldn't be going, you're a university students, it's free pizza and drinks. OK, um. Yes, and those are the those are the companies they are I I I know people have done Ravi study programme. It's actually real. OK, um, so today we're gonna be talking about semiphors, deadlock, LiveLock, and the banker's algorithm, boring. Alright, last week we talked about, um, concurrency, so we were doing locks and then condition variables, so. What's our main objective today? The main objectives of concurrency, as we recall, are one, mutual exclusion, right? We, we were trying to implement the idea of atomic logic, that is to say, I want to do a bunch of things all at once, and I don't want it to be interrupted so that I can have parallel processes also doing things. And then number 2 was with convictition variables, we weren't just interested in keeping these ideas separate, we were also interested in the order in which they occurred. So if one of them, You know, like, I don't know, you put your shoes on before your socks, no, wait, you put your socks on before your shoes, right? Um, there are many systems like real-time systems and robots that, you know, they'll pick things up and then put things down. You want to make sure that the order in which these activities occur are correct, right? And you want them to do whatever task they're doing as quickly as they can, so the robot arm is picking something up as quickly and putting it down as quickly as it can, but you don't do anything with it before you pick up again, right, like if I if I put something down, I want the next person to pick it up at the right time. Um, cool. Alright, so semaphores, alright. It's interesting, last, last year's lecturer does not know what did not know what a semaphore was, right? Um, but, um, so why are we talking about semaphorres, OK, um. Well, it's basically we're gonna come into some shortfalls of condition variables, right, like basically we, we, we have so far we've looked at locks and we've looked at condition variables, and then, you know, in order to create semaphores, there must be some like use case for semaphores, right? Um, like, like, why, what, you know, what is the problem that we're trying to solve? Um, one of the things that was kind of annoying about condition variables is that let's say you've got a thread and you've, you know, at some point in time you've decided to make it wait and you've got this other thread and it's gonna signal it, right? When it signals, all that happens is the first thread just simply becomes ready, right, so now it's ready, but it's not actually running, right? So there's no guarantee. That after you've, you know, it's sort of like imagine you're running a relay race and you're like, OK, I'll run, I'm, I'll run and I've given you the, the baton, and the second person's picked up the baton and they're like, no, no, but I'm not scheduled yet, right? Um, and they're just sitting there going, I've just gotta wait for some other process that's running on my computer, right? Um, and so you lose that race, you know, um, so there is one weakness which is, you know, signals don't make the other thread run, they just make it ready, um, so that might be something that we want to uh fiddle with, um, and so this actually, you know. Uh, might not run. Oh, that should say running. I forgot about the animation. I changed it this morning from I was looking through my slides to review and I was like, oh, that used to say running, but I forgot that it animated to make it look like it's running. OK, it is nominally ready. Um, the second one is that like for some use cases, locks are annoying, right? Like, so I want you to imagine that you have like a car park, right? And you're like trying to design a car park where you can only go into the car park if there are spaces in the car park, right, and cars can go in and out and. Find spaces, right, and while the car is in the car park, maybe they still have to find a space, but like you can see in this situation that like, or maybe you can't, I don't know, let's try. Um, you have a car park with 4 spots, right, in pairs, discuss how would you manage this using mutexes, right? So you're using what we had from last week with, you know, this idea of locks, what are we gonna do in order to try and, how would we do 44 car park spaces, and I'll just, you know, do my usual cantter around the lecture theatre and you can guys can start talking. How do we go? Like, is is there a sensible, easy, obvious answer to this question? Alright. I don't think there's a like a really, really straightforward answer to this question. Do we have any ideas of like things that we think are definitely necessary? How many, OK, here's a question, how many mutexes do you think we're gonna need? At least 4, right? I think everyone, I don't think anyone's gonna claim that you can do it with less than 4, yeah. You reckon we probably would want more than 4? Oh, everyone's really scared of this question. I'm not surprised. Um, this is a scary question, right, let me get my little mouse out. OK, no, I don't need a mouse. OK, well, let's think about like what, what, what do we need at a very basic level, right? So for each car park, we're gonna need a mutex of some kind, right, because, well, we're gonna need something to say that like, OK, now I'm in a spot. I we could do it with less than 4 mutexes I guess. Like you could have a a mutex that just does the gate or something like that, you know what I mean, or you'd need a mutex to drive your car, you'd be like, only 1 person may drive at any given point in time, right? Um, and then you're like, OK, well, OK, if I have, if I have the mutex, then I can change the value of one of the car parks, um, potentially, and then I can check, you know, which car parks are free, and then I'll grab the key, you know, the mutex and then try and grab the car park. It's kind of annoying to do, right? Like it's not, it's not a really obvious straightforward kind of solution. So what we're gonna learn here about semiphors is the big difference between a semaphore and a condition variable or a lock, is that a semaphore has a state, right? And um it has one state and it is a non-negative integer, right, so you can almost already sort of see what how a semaphore is gonna solve our problem because basically a semapho is going, oh OK, it's a non-negative integer, is for this purpose the number going to be 4, right, like, um, because basically it's just gonna store a number, right? um. In terms of semaphores, this is the anecdote I was trying to say, last year's lecturer was like, oh no, no semaphores are the things on train stations, right, the train signals, and I'm like, no, it's not, semaphore is a language, semaphore is this language, where you go, this is S, that's O, and that's S, um. Right, uh, that's the only bit of. Oh wait, is that right? This to that, to this? Yeah, something like that, right, um, I just remember that just in case, you know, like I'm, I'm on an island, right, and there's someone flying over and I'm in trouble instead of going. Right, I'll be like, no, no, I'm doing this, this is uh it's specifically SOS. Now, um, so it's, it's a kind of um visual language of flags, right, and the semaphors and the train station are those little um switch things to tell you which way, whether you can go or not. And so we're gonna use that as our sort of like language to describe we're gonna create virtual semaphores. Um, so this is basically. The entire like substance of it, right, you have a weight and a post, so instead of having like lock and unlock, we have weight and post. So if you wait, right, um, You wait until the number is positive, so if it's not 0, if it's above 0 and it can't go below 0, then you will wait until it is above 0, at which point you decrement it, and if it is, if you do post, you're going to increment the semi 4 by 1, waking up at least one of the waiting threads, and that's it, right, like and then we're like, OK, so this is just locks and condition variables again, right, and it pretty much is. Um, the complication. Right, um, is that Dijkstra, who invented this is Dutch, right, and so sometimes it's referred to V and P, right? And when I saw this I was like, oh, OK, B and P, right, so we will be, you know, like for vain or something like that, right, cause you know in in um Dutch. Well, in German it's to wait, right, and then he would be like post and I was like oh for posting, but it's the other way around, right, right, so it's um to increase, right, and to probe, right? Um, so the right, which is the to increase one which is post, so post is not P, right? Post is the V, right, and then weight is the P. So if you ever see these like they'll have them as functions, they'll literally have them written down as functions uh the P function and the V function. You might get a bit confused, right, so this is just a thing to, to note, and probear just means to probe, right, which is a bit more, um, I don't know, intuitively obvious. I don't know, it's better cognate in English. Alright, so basically the idea is what we're gonna do is we're gonna have, like if we think of it like visually, we're gonna have 0, right, and then we post and we'd go to 1 and we'll wait and we'll wait until it's at least 1 and then decrement it, and that's it, right, like that's the entire function of a. I've said before and then it's, you know, guaranteed by magical functions under the the hood, right, um, so it's these are atomic kind of actions. You can't, you know, you wait and someone will wake you up and be like, hey, it's 1, and you'll be like, oh it's 1, excellent, I'll decrement it to 0, and I have and the act of taking it from 1 to 0 is the act of taking the nominal semaphore, and the ad of putting it back post is the act of returning the semaphore. But it's basically the same, right, so um uh basically the same as a mutex. Um, and there are no negative values, right, so you can't take more than there is, right, like, and that kind of makes sense, you wouldn't want to have a thing where I will take one of the car spots that doesn't exist, yeah, um, that would be really bad. Um, and yeah, each of these is atomic. OK, cool, um. Yeah, that's about it, right, then we've got code, right, so send in it, so we've got, you know, set it to its initial value, right, so now we can start thinking about our car park and saying, oh well I could set it to 4. Every time someone parks they can call um wait, right? And if it's greater than 0, then they can park, right? So they go and like oh it's 3. OK, there must be a spot, they park their car and they reduce it by 1, so now it's 2, and every time someone leaves they can post and they can increment it by 1, right? And so like you can see how this is a very, Elegant solution to our problem, like it's, it's, it becomes really, really simple, um it means that we don't need to keep track of the individual car parks either, right, like as in the in the other system, you might be like, oh well, Now I need variables for each of the car parks, and yeah, you probably do need variables for each of the car parks, but I don't need like special architecture for each of the, the different car parks, right? So yeah, OK, so we've solved that problem. We've got, you know, weight, test and P or signal post and V, yes, it's gonna be confusing. I, I suggest that you basically try and think of it, not in terms of any of these, but in terms of number goes up or number goes down, right? So you just go into the documentation and be like, oh if number goes up, that means I'm leaving and if number goes down, that means I'm taking something, right? Um. So let's have a look at this um code, what have we got? Yeah, so what what we're gonna do is, um, this is the condition variable version of it, right? So we're locking the mutex, we're doing some stuff, we're saying done is true, so done is the remember from the, the last lecture, we've got to try and indicate in some way that we finished the work that we're supposed to do, um, and then we send our condition, right, and if we are the, uh, the equivalent function for like taking stuff out, so basically the stuff that's dragging stuff out of this condition variable, so we're waiting for someone to do some work. We're saying if it's not done, we'll wait and then we'll, you know, do stuff to the stuff once um we've been woken up and then we'll use a separate mutex in order to lock it all and then with 74s we can do the whole thing with two functions, right? Um, and obviously we need to, you know, in it to something, right, so we need to initiate our semaphor, but basically what we've done is we've taken code that previously looked a little bit complicated and therefore a little bit more prone to bugs and we've replaced it with a one liner, right, so you're like, OK, cool, 74s. I guess better than condition variables and locks, right, um, sort of, um. Semiphors and fairness, OK, so, before we move on, we need to like convince ourselves, right, you know, are semiphors good, right, like as in do they do everything that we want? um. And, um, you know, the issue of fairness was one that came up before we had that with condition variables, you know, like, OK, so there there's a mutex, or you've got, you know, like you you're doing your condition variable thing with your baton, right, and you're like, OK, I'm going, I'm going, I'm going, and I, I'm like, I released the thing and I'm like, someone wake up and then. Someone's like, hey, hey, hey, wait, wait, wait, wait, that's mine, right? Um, so you can still have the same kind of problem that you have with mutexes where there could be starvation, but some implementations of semaphores will provide a list which has, you know, an overhead, but basically it means that like the order in which you request, you know, like it's sort of like if you think of it in the car park analogy, there's a queue of cars, and you know the first car to get to the boom gate is the first car that gets to park. Um, if anyone's ever gone to a car park before, this is totally not true. um. I've never been to a real car park, or like, you know, like a shopping car park where like if you're the first to arrive, you'll be the first person to find a park, um but um in, in, in this case it's more like one of those boom gate car park kind of places where you have to pay to get in. Um, So, alright, cool, lecture over, that's basically semaphores, right? Um, all of it. No, um, so the next part of this lecture is really just going, hang on a second, I've taught you nothing, right, because these things are the same thing, right? So, you know, um, basically we have, you know, pick your team, which one you like the best. Who gets this reference, who gets it? Yeah, alright, I'm not that old. Who here actually played Pokemon Go? I, I don't know if this actually extends beyond Pokemon Go, maybe it's also in the Pokemon games, I have no idea, um. A mystic represent yes, no, um, basically the only difference between them is sort of um sort of uh in implementation, right, so the difference between a mutex, a condition variable, and a semaphore is really all down to the implementation, which means it's all down to the veneer of how easy it is to read. So for different applications, these different tools will be differently useful, right, because if it better maps to the problem space that you're trying to create, then you use whichever one of them looks the nicest in your context, right, whichever one like basically produces the code that is the least buggy, right, where you're least likely to make a mistake. Um, and just to uh convince you of this, it's actually possible to make every single one of these structures using the other one. So once you've got one, you've basically got them all, right? Um, yeah, more, more memes. OK, yeah, they're all the same thing, right? OK, so, um, this is how we could build a lock from a semaphore, so basically what we could do is be like, OK, we want to build a lock from a semaphore, what we're gonna do is we're just gonna build this code, right? So you know it's like, oh OK, so we're gonna create a lock and it's gonna have a semaphore in it, and then when you in it you in it the semaphore, and then when you acquire you wait for the semaphore and when you release you post the semaphore and it's basically a lock. So you've created a mutex from a semaphore. Wow, I mean that was pretty obvious, right, like it's basically just a semaphore with a value of one in it, right, like that's what a lock is, um. Building a condition variable from a semaphore can be done, but it does not fit in a lecture. Like it's, it's one of those things you're like, oh, they're they're mathematically equivalent, except this one requires like a 15 page proof, um, so you can do it, um, at least theoretically, um, but yeah, it's, it's kind of a pain, right? So, um, uh, I'm not gonna show you how to do it, I'm just gonna say that you can. Um, you can build a semaphore using a lock and a CV, right? Like as in, so what we're doing here is, uh, do I have it? Yep, cool. So what we're gonna do is we're gonna start with the condition and we're gonna start with a lock for our semaphore, so we're gonna create this semaphore thing out of locks and conditions. Um, we're gonna initial initialise all of the values for them. So now we're gonna ask ourselves what's gonna go in weight and then what's gonna go in post, so. What am I gonna put there? Well, in, wait. Oh, I have these in the wrong order, no wonder, I was confused, let me just rearrange them so they're not like, I was, I thought there was one that where they were all blank. And they, there is not. There we go, alright. Yeah, OK, so first we populate the boring stuff, right? OK, so. OK Hello. My laptop is not connected. Next HCI table to laptop. Make magic noise. Hello? Oh God. Mid lecture too. Laptop not connected. All right, let me. Just check that the installed PCs, OK, so that's the, oh wait. Oh, it's gonna be one of those lectures. Right, OK, right, OK, so, uh, I'm just gonna um go back to the install PC. I'm gonna pause the lecture. You guys can have a break for like 5 minutes while I email myself my own lecture and then try and run it. Record. Yes, OK, we're back on. Alright. Thank you for everyone for your patience while I was incompetent with my own laptop. Um, where were we up to? We were up to, OK, previous, we're trying to create a 74 out of a lock and a condition variable, and I am telling you, Oh, I really have them in the wrong order. Oh, this is really disappointing. OK, let me just, I should have fixed that while I was ah. Really? OK. Yes. OK, there we go. So first things first, I'm gonna tell you that you need a lock and a condition variable. Second thing is I'm going to set those things to their default, you know, like the initializers. You need, you definitely need initializers, that much is like pretty obvious and boring. Alright, so the next one is, come on, be, be we, be weight. Yeah, OK, wait and post. OK, cool. Um, so, conceptually, conceptually, um, It makes sense that if we're gonna replicate, you know, we're gonna make a semaphore, right, um, from a lock and condition variable, that we're going to use the lock part in order to make it mutually exclusive, right? Like that seems like a pretty obvious component to this construction, right, so we're basically gonna say if we're calling weight or we're calling posts, the first thing that we're going to do is acquire this lock that we've created and now while we're within these um functions, we don't have to worry about anything stuffing up, um. On the weight side, what we're gonna do is basically say while the value is less than or equal to 0, we're gonna wait, right, and then after we've weighted, we're going to decrement the value, right, and that describes what the weight function does, right, so we're basically going if the number is 0, we will wait, if it is positive, we won't wait anymore, and then we'll decrement the value, right, so once we get out of this while loop, right, or nominally, um, Even if we're woken up, we're gonna go and check again, we're gonna be like, is it, you know, is it greater than 1, sorry, is it one or greater, right, and if it gets out of that while loop, we can guarantee that S value is going to be able to be decremented to zero at the in the worst case, right, um, so it's gonna be at least 1. so yeah, that's pretty simple, and then on the post side, um, basically what we're gonna do is increment the value, right, and then we're going to signal one of the, um, sleeping threads, basically, so um, yeah. That was easy. Um, I don't know, there's nothing particularly complicated here, kind of unsurprisingly, right, they're basically the same thing. The only difference is that there's like one value, so it's, it's really just a lock with an extra value, and we've got a condition, um, variable in order to make it sort of work nicely so it um doesn't spin lock or anything like that. Um, OK, so that was all very good. Um, next thing we're gonna try and do is gonna try and build something out of 74s, so, uh, one of the cool things that we're gonna try and do is we did a buffer last week, right, we were building a buffer out of, you know, mutexes, uh, we're gonna do exactly the same thing, um. Yes, I still have the same name. um. How many 74s will we need? Any guesses, who votes for one? 3 OK, who has a left arm? OK, cool, just checking if people have left arms. OK, so I'll give you a choice, we're gonna do 12 or 3, we'll do it again, alright, 12. Hey. Yeah, alright, I don't care who got it right. Um, how many constraints? OK, and alright, so we're gonna, we're basically gonna, in this particular implementation we're gonna go with 3, right? So one of them is going to be, uh, to indicate that it is full, right, one is going to be to indicate that it is empty, and one that is going to basically just exist for the purposes of being a mutex and preventing us from stuffing up, right? Um, and you'll see this a lot with these kinds of implementations, right, where you're like, oh, I have one mutex to represent something, but then I just have a generic mutex to like stop me breaking things, right, the I'm doing stuff for mutex to manipulate my other mutexes without causing new race conditions. Um, And so what we'll do is we'll set one of them to the buff size, we'll set one of them to 0, and then we'll, you know, basically just have MT mutex equal to 1, so, Why did we choose 0? Why did we choose these other numbers? Well, you think about it, whenever, if we say the full size is full slots is 0, then we're saying we have no full slots, so we can't, um, take stuff out of the buffer to begin with. But if someone posts two full slots, it means that they put something in the buffer and then you could take something out. Um, empty slots is the buffer slot size, so we've got lots and lots of empty slots. If someone were to wait on, Empty slots a lot, then eventually it will become zero and then we won't be able to do anything with it, and mutex is just gonna be used as sort of a guard condition like we saw last lecture with a guard. Alright. Um, Let me just so I can read this code myself, right, so we have our producer, right, so we're gonna do our producer consumer kind of thing and it means we can have as many producers and consumers as we want. Um, we have our seweight empty slots, uh sem weight mutex, uh se weight, um, mm mutex and uh post full slots, right, so we're basically we're gonna say. Until there are some empty slots, right, which we're gonna start with a lot of empty slots, right, um, we will wait, right, at which point now that there are some slots, we will take the mutex, um, the what what's it called, called mutex, the mutex called mutex, which gives me the right to put things in and take things out of the buffer, right? And then I'm going to put an item onto the queue and then I'm going to give back the mutex that says I'm allowed to do stuff with the um. With a buffer and then I'm going to post that because I have put something on the queue, there must be at least one full slot, right, so, um, yeah, avoids overfilling, signals that the queue is not empty and avoids concurrency. Right, um, so yeah, pretty, pretty straightforward, right, so like if someone was waiting nominally, um, for there to be something on the queue, they would be waiting and when I did send posts, they would wake up, so that will work, that will work if there are no empty slots and someone else takes something off the queue, hopefully they'll do a post and I'll wake up. So so far so good. Um, in reality, I don't know if I really need to use a semaphore to do the mutex, I could do that using regular mutex, right? I like, but I guess using a semmaphors makes the code a little bit more the same, so a little um less confusing. Um, and then we have a consumer and the consumer is basically exactly the same, right, like, um, the difference is, is we've just swapped empty slots and full slots, right, if you just watch carefully, we've swapped NQ with DQ and then we return the item at the end because obviously it's a queue and we actually want the thing, the consumer wants the thing and then it can return that value, give it to someone and they can do something with it. And did I swap the, I did, I did, I did swap the text around. OK, so yeah. Great for this pretty, pretty straightforward, right, like it's kind of clean, which is a nice thing because you, you sort of go, oh, OK, wait for full slots, wait for mutex, wait for empty slots return item, yeah, OK. Um, so one of the advantages of semiphores compared to what we were doing before with locks is I think that they're a little bit closer to how we think about these problems, um, but yeah. And this is safe, cause there's symmetry, right? This, this should be safe, nothing can go wrong here. Um, the order is important, right? Why is this wrong? Any guesses? How could this stuff up, how can we make this break? Alright, alright, I'll give you everyone that you can chat with the the person next to you, try and work out why this would break, and I'll do a little lap and then I'll come back. Alrighty, alrighty, does anyone have an answer now? Or at least a guess? What is the scenario? Yeah, alright, so let's let's look at it, so I'm gonna grab the mutex by having the mutex, No consumer is allowed to do anything, do we agree? If I have the new text. Yeah, I'm the producer, right, I'm like, I wanna make something, I wanna add something to this queue. As soon as I grab the mutex. We go to consumer, consumer can't do anything, right? They can't deque any items. If the list is full, and I am a producer and I take the mutex, the first thing I'll do is, I got the mutex, no. Alright, can I do anything? No. Well, I'm just gonna wait. Meanwhile, the consumer is gonna be there going, right. Cool, there are empty slots, I wanna do something, but someone else has the mutex, so I will wait until I get the mutex. And this is what is called deadlock, right? It kind of makes sense, right, so they're both waiting on something that the other person has, and they will wait forever, right? So. If we do it in pictures, right, the buffer is full, right, and the producer is gonna grab mutex one. The consumer is going to grab full 10, right, because I'm gonna say, you know, there are 10 items in this buffer or something like that, right, um, and that's fine. Yeah, and now the producer's gonna be like, well I need empty. But I can't get empty, right? Well, sorry, I'm sorry, I need. Does that even make sense? Have I done this right? Exactly, right? In order for consumer to get, make empty one, they first need mutex. And in order to give up the mutex, I need to um what do you call it, first get empty. So there's no way that it's gonna happen, right, like this, we are, we're done, it's over, right? Um, so I don't know. If we're looking at this as a, a general kind of rule, um. I think this is a summary of all the semaphorre stuff, right, like we've got all these crazy names. I think the one thing I do hate about this is that condition variables, locks and semaphores all have different names for the functions that they call, even though ostensibly they're doing basically the same thing, right, like as in like post is not a particularly informative name for me, right? I, I like lock and unlock that I get, right? Or take and give might have even been better, right? um. But yeah, they're all equivalent to each other, um, that's the summary of what that one does, and then, yeah, um, for producer, consumer and reader writer kind of functions, semaphors are like a cleaner version of the code. OK, so let's talk about timing because we just gave you an example of deadlock, right? So I guess we need to talk about, oh. No, I think we just need to talk about people dying first, OK, who here has heard of TA 25? Yeah, OK, who here has done like a software engineering subject? No? OK, yes. Where did we hear about Th A 25? Were we just googling on the internet, or is this just the example that was like morbidly, how did they kill people? Um, no, um, this is used in pretty much every time someone wants to say software can break. Um, so I've heard of this lots and lots of times, but because I've heard of it so many times, I was like, but what actually happened, right, like, like what, what actually happened, right, cos you hear this, oh there was a timing issue, right? And it took me a while to work it out, right? OK, so this machine has two ways it can kill you, right, well, not kill you, um, kill cancer, right? One is, A high dose over a wide area, so basically it's just like I'm going to use a big aperture and I'm gonna spray huge amounts of radiation. But it's distributed over a wide area and so what that means is that like in general, it goes deeper, so it's good for like deeper cancers, right, um, and bigger cancers, right, but if you do low dose and a narrow area, right, so there's less power, right, but you, you make the beam. Thinner, it's more concentrated, so it's more likely to burn the surface, right? And so depending on the kind of cancer that you've got, right, you change the setting, right, to make it as like it's either a wide aperture or it's a narrow aperture, and I was like, OK, cool, what has this got to do with like concurrency? OK. So the way that it worked is that you've got a beam, right, you have this beam and you shoot this beam and the beam itself is the same beam in both cases, right? And so what they do for one of the things they have what's called a metal target, which I don't understand the the the wording of, I don't know why they would call it a target, but basically they take this metal thing and they put it in this in front of the beam, right, and the beam will absorb some of the energy and then re-radiate it out and, For one of the settings, which I think is a low dose setting, they instead put a foil shield, which sounds like a metal target to me because, you know, it's a, it's foil is made out of metal and, I, they both sound like shields, but basically the idea is you've got a thin one and a thick one, right, and the thin one, I think more stuff goes through and the thick one, like the thin one, it reduces the dosage, but I don't know, it doesn't really matter. What matters is, Is that the way that this machine worked is that it basically had these two things, it has the foil shield and it's got the, the metal target, and it moves one in front and then takes one out and then moves the other one back, right? So how would we get a concurrency error with this, right? Well. We don't have proper semaphores, right, so what we're doing is we're going to say, oh, OK, how, how does this actually work? Well, what happens is the operator's like, oh, I'm doing, you know, a high dose one, right? And they're like, oh wait, no, I'm doing a low dose one and so basically in rapid succession on the GUI, they go from high dose to low dose, so they go click high dose and then they click low dose, right? And what happens is because of the timing condition. Basically, the high dose by pressing high dose and then low dose, what they do is go high dose, OK, well I'm doing high dose, so the shield that's there currently, which would be the low dose one, moves out of the way, right? And then they click the low dose one and the low dose one thinks that the high dose one is still there, but the high dose one is still pulling itself out, right, so the low dose one's like nah, I'm not gonna move, right? And so what you end up with is you end up with a beam with no shield at all and then you kill people, right? Um, and they, they described it as like this is their agony worse than death, and then they all die three days later. Well, not all of them, but some of them die 3 days later from radiation poisoning, right? Um, so traditionally the way that this worked is they were like mechanical interlocks rather than software interlocks, and this was a case of like, well we could just replace it with software and it would be easier, right, and um they replaced it with software and they killed people, right? So this is where we're like, ah, in currency, important, might accidentally kill cancer patients. Um, but yeah, alright, so. Punsies, let's try. This is called the something problem, I don't know, like. I've, I've heard it called different things. Basically Chinese restaurant like problem I guess because there are chopsticks, right? Like I've seen one where it was like pasta with forks and I'm like, who eats with two forks, that makes no sense. Two chopsticks though, I totally can get behind, right? Like if you're eating noodles with one chopstick, I feel sorry for you, right? But the idea is that you need 2 chopsticks. Now we've got these 5 guys and they're not allowed to talk to each other. There's no secret communication. All you can do is each of them can concurrently take a chopstick, and you can't take two chopsticks at once, you can only take one at a time, right, so you have to be like, I'll take the left and then the right, and then I've got 2 chopsticks and I can eat, right? And the goal is to get all of these people to eat and it doesn't matter which order that they eat in, what matters is you just don't want to get them into a situation where they're trying to grab chopsticks and they can't grab chopsticks and all of them are there going, I have the right to chopstick, excellent. Damn it. I'll put it back and then I'll take the left chopstick, damn it, right, um, try and devise a, OK, so the activity is to try and devise an algorithm to try and solve this problem, it's, it's good fun. I'll do my pauses and I'm nearly up to 10,000 steps. I'm actually. Yes, you can communicate beforehand to agree upon an algorithm, so like you're, you're the person who's trying to create these 5 agents who can't communicate, who independently can take chopsticks and then behave depending on whether they take chopsticks or not. All right, right, right. Do we have, OK, let's start with the easy the easy question and see if people have arms, right, right, right, who found a very easy solution to this? Oh, a few, OK, wow, OK, who did not find a very easy solution to this? Does your solution work all the time? All right. All right, I'll get my microphone. All right, then I get, get you, get your price out. All right. Tell me, tell me about this. Oh God, oh God, feedback time.

SPEAKER 1
So here's my very easy solution. You just start at the first person, select them as they're gonna get 2 chopsticks, skip the next person, then the person after that will get 2 chopsticks. Keep going around until you finish everybody. They eat their noodles and then pass it to the person to their right. So everybody will then get a turn, except for if it's an odd number of people, the last remaining person, you'll have to switch one more time. And you don't give it to the person next to you if they've already had it.

SPEAKER 0
Yeah, I'm, I'm gonna ask you the question, how do you determine who the first person is?

SPEAKER 1
Arbitrarily based on if I like them.

SPEAKER 0
Yeah, no, no, basically like the, the, the problem, oh God, oh my god, the sea. Sorry, it does weird things when I walk past there with a microphone. I should go up through the middle. Um, yeah, so that part of the solution, I think it makes sense. Like if you are able to establish some kind of ordering, right, that is to say that you can be like, you know, like in order to make this question really fair, like I have to be like, OK, so you're in a round room that's completely symmetrical and everyone is blindfolded, right, you know what I mean? And all they can do is they're like, I'll reach for the chopstick. And then, yeah, and it's either there or it's not right, you know, like to really get the emphasis across, but establishing who is first in your like logic is actually kind of hard, right, like because there is no first. Now if you were in a square room, you'd be like, oh I'll get up my compass, whoever's most aligned with North goes first. I can work out, you know, based on the list, I can see everyone else. Um, should, where should I be in this list? Alright, do we have any other, other, yes. Do you want to talk loudly or do you want to make? So Yep. Yeah. Yeah Yes, OK, right, so, so the, the broad solution is everyone picks up a random chopstick. If everyone picks up a random chopstick, you can now look to your left or to your right, and if no one has picked up, because some of the people will have picked up no chopsticks cos they'll be, I'll go for the right, and the other person will be, I'll go for the left, and the person who grabbed the one on the left will have grabbed it slightly faster than the one on the right. This person will come up with nothing and they'll be like, right, um, but what that does is it means that there must be this elusive chopstick to the right. Now this solution relies on what, where, where does it break? Yeah. Yeah, if everyone goes left, right, so we really need to have, like, in order for this algorithm to work, we need to really have some concept of randomness, right, like, like in a very, very unsynced randomness, right? Cause you can imagine that if you had um a bunch of these um things and they had random number generators and they accidentally picked all the same seed, right, then you'd end up in this infinite loop of them going, oh, pick the left, damn it. I'll pick the right, damn it, I'll pick the right, damn it, I'll pick the left, damn it. Right? Um, but broadly, That's one of the ways that you can do it, um, do we have any other takers? So the other solution that we had was like you just take a chopstick and then you try and take another chopstick, and if you can't take a chopstick, you just wait a random amount of time and then you just try and take another chopstick and that's all you do, right? So the like the ethernet solution to it which is it's just like, oh yeah, wait, no, alright, yeah, no, no, no, you hold on to it for a random time and eventually it will sort itself out. Um, I don't know if this actually has a formal solution. Um, I probably should look it up, um, but it's mostly just there as an activity, um. But let's discuss this idea of deadlock, right, so this is an example of deadlock, the the situation where basically what you're trying to avoid is everyone picks up the left one, everyone's trying to pick up the right one, but they can't because someone else has their right one and so they're just sitting there forever doing nothing, um. And basically deadlock occurs when you have a situation like this, right, where you know like I need lock A. And thread 2 needs lock B, and now thread 1 needs lock B and thread 1 needs lock A, right? Like it's kind of obvious that this is never gonna work, right, um, because, you know, thread 1 will never give up Lock A until it gets lock B, and thread will never give up thread 2 will never give up Lo B until it gets lock A, right, and so we're stuck here forever in deadlock, OK. So, oh yes. 01 more solution, excellent, alright, do you want a microphone on? OK. Alright, the best solution is what you do is you take the chopstick, you break it into two, and then you use 2 half chopsticks. I agree, this is the, the best solution to this problem. Other than the killing someone at the table, right, you know, it was like, and then you can eat 5 bowls, right? Um. That's the solution to all life's problems, right? No, OK, so how do we think about this problem, right, like, one of the ways that we can think about this problem is try and pose it as a graph problem, right, so because deadlock is a kind of, you can imagine that like, A cycle feels like a way of like detecting a deadlock, that is to say, you know, if one of you know if I'm pointing at A and someone else is pointing at me and we're trying to do it as a priority graph, neither of us have priority because we're in a sort of cyclic directed graph, um, so can we pose it that way, right? So. We could say that thread 1 holds, you know, uh, mutex A or lock A, and then we can say thread 2 holds mutex B, and then we could say thread 1 wants mutex B and then no, that's not how we think about it, right, because we can already see that this is not going to do what we want. The way that we do think about it is we say wanted by. Thread B is wanted by. Um, oh sorry, Lock B is wanted by thread 1, right, and you can imagine then if we complete this, we have, Thread A is also wanted by thread, sorry, lock A is wanted by thread 2, we end up with a cycle, right, and so we can come up with a sort of a graph definition of deadlock, right? And once we have a graph definition of deadlock, then we can start analysing all of these conditions with all of our threads and ask ourselves. Deadlock possible and then that will allow us to try and work out which, you know, like if you have a, you know, every, every example that we've looked at so far has been pretty trivial, right, you know, there's like two threads, but you can imagine if you have like 10 resources and 15 threads and they're trying to like negotiate over who has what, you could end up with deadlock that you wouldn't necessarily like see at the outset. Um, but basically you create a circular dependency and at that point in time we're done. Um, and that's the example there, right? Now, if I swap it around, right, so basically, Um, I change it so it's locked, you know, I lock A and then I lock B for both of those threads. I basically get rid of that red one, yeah, and the cyclic dependency is defeated, right, like as in that's, that never exists, so we're all good. Um, Oh, here's a fun one. Alright, so let's, let's let's, let's paint a picture. Alright, there's another class activity, right? OK, so we have this function called set T set intersections, right, so we're gonna try and calculate the intersection of two sets, right? And so what we're gonna do is we're gonna have set 1, S1, and set 2, S2, right, and we're going to, I don't know, Mao something to make memory for our new set, right, whatever, it doesn't really matter. um, and then we're going to lock S1, we're gonna lock S2, and then we're gonna loop over S1 and if it contains, you know, they're they're in the same set, right, we're doing, you know, like Venn diagram stuff, right, calculating intersections, right, we're gonna add it to our list and then we'll unlock S2 and then we'll unlock S1. Right, this is subtle, there is a problem here, right, this seems on the surface. To be exactly what we would expect, right, so far we're seeing this sort of mirror symmetric, that is to say, you know, it's uh what uh has anyone here ever seen Get Smart? This is like a really old 1980s show. Alright, what I want you to imagine is that like I have a, I have a box, and inside the box I have another box, and inside the box I have another box, and I want to get inside to the middle box, right? With, with these locks, so far what we've seen is the logic is that you know you have to unlock the top box and then you get the second box out and then you unlock the second box and then you get the 3rd box out and then likewise you can lock them and you, you basically put them in in the same order or like the reverse order. The way that you take them out, right, so you take the middle one, you know, like you have to do it in a particular order and then you have to, you know, open them in particular orders and close them in particular orders in order for it to work, otherwise, like one of the boxes will end up outside your other boxes. Um, it's a similar kind of logic here. We have S1, S2, S2, S1, right? That's very similar to what we're expecting. The lock order is the opposite of the unlock order, right, so I'll pause and. I'm telling you that there's a problem with this code and I'll see if anyone can figure it out or can cheat from the notes, um, and I'll do one more lap and I'll get up to my 10,000 steps. I, I always like talking really, really fast, um. So, Here's the, here's here's the issue, right? The, the clue is at the top, encapsulation gone wrong, right? The problem is that we're we're sending these things as pointers, right, pointers to logs, yeah, and so we're like, hang on a sec, what if, what if I called the set intersection of set A set B and the set intersection of set B set A at the same time, right? Yeah. So what is that going to do? Well, Oh, this is how I solve it, right, but like, basically what that's gonna do here is we're gonna say, oh, OK, imagine that we have one of them which is S1 S2, but now because I've reversed the order of the sets for the second time that I'm calling it, I have S2 S1. And so one of them grabs S1 and one of them grabs S2 and then the other one waits for S1 and the other one waits for S2 and now we're stuck in a deadlock, right? So even if you've got everything set up perfectly and you're like, oh yeah, this function should totally work, now that we're throwing things around with encapsulation. Things become complicated, right, so again, Even if you think you've got it right, as soon as you start abstracting things, there's a chance that you could get things wrong, and once you've got a system that's big like this that's throwing around pointers to different things, It's a big thing, right? So, one of the ways that we can avoid this. And it sounds pretty crazy, is that you can have it so that you basically enforce some kind of ridiculous structured order, right? And one of the orders that is used in some operating system environments is, You just do it based on the address of where the mutex is in memory, right, so the mutex refers to some little bit of thing in memory and you're just like, OK, right, um, I'm just gonna do it if like I'm gonna grab them and I'm gonna grab them, if I'm grabbing two things at the same time, I will compare the addresses of both of them and I'll I'll unlock them in ascending order and I will, sorry, I will lock them in descending order and I will unlock them in descending order or vice versa, it doesn't really matter which, right, um, so that it's guaranteed. That like, if I go back to this example here, that basically when I grab, you know, when I'm trying to lock S1 and S2, S1 is the one that has the lower address and S2 is the one that has the higher address, and it doesn't matter if I put in S1 S2 or I put in S2S S1, I'm going to lock them and unlock them in the correct order. Alright. But Ah, yeah, right. I'm gonna put in the Kelly bracket because that would drive me nuts too, I agree. And then I never actually returned the set. Yeah, no, that's true. It's, it's. That is true, Avi. All right. Excellent. Many things. Part of me's like, should I just leave that in every year and then see if students notice that I don't have brackets, and they'll be like, I found something. um, no, um, OK, cool. Uh, enforced ordering, yeah, enforced ordering, OK, cool. So let's talk about deadlock theory. OK, so in order for deadlock to occur, I'm going to claim these four things are necessary, right? We need to have mutual exclusion, so there needs to be these weird atomic parts of the thing where you know, two things, one thing sort of blocks another thing from progressing, right? We need to have hold and wait, right? So what that refers to is that you know, like you basically I'm going to. Take the mutex and then I have it and I'm holding it and I'm waiting a bit, right? Um, we have no preemption, so it's not like someone can be like, wait a second, no, I want that mutex and snatch it from you, right? Um, and then we have circular weight, right, so where you just sort of like I'm waiting, I'm waiting, I'm waiting. Alright, so let's have a look at how we could like solve this problem. The example here that I'm gonna use is like you've got cars and they want to get through a, Um, intersection, you know, and there are no stop signs, you know, which car goes, which car does not. OK, so, mutual exclusion, you know, like basically, you know, the purple car's gonna be like, no, I want these two parts of the intersection so I can drive through the intersection without hitting any other cars, um. OK, hold and wait as a sort of definition is, is, is what I'm gonna do is I'm gonna grab the mutex and then I'm gonna drive my car forward a little bit, and I'm just gonna sit there forever. Um, and I can't like back out, right, so preemption in this case would be like, oh, I have made an error. I took, I took, you know, like this mutex and now I need to like undo it, right, essentially, um, um, and then give someone else access to that mutex, um, and then circular was is we need to have like some kind of circular dependency, right, in order for deadlock to occur, right, so we need to have a situation where all of them are stuck because. Um, in the graph that is the dependency of all the mutexes, there has to be a cycle. OK. So one of the options is we could just get rid of the lock, yay, right? um. If we don't have a mutex, what we could do is we could just like, I don't know, build it out of compare and swaps, right, so we could actually build our, you know, logic using the function upon which all of this rests so we could use test and set or we could use um compare and swap and then basically we could, you know, have something like this where we're constantly checking things and, you know, um, we don't have any locks, so we're not gonna have um any problems, right? We don't, we don't have a lock, OK, yeah. Um, and there's a bunch of other options that you can do, so like, where are we? So there's that one and then there's, that one for the lists, right, you can get rid of a lock with uh, Link list by using more primitives um so that we're not really using new taxes in their existing form, um. For hold and wait, one of the things that we can do is what we could do is create what's called a metal lock, right? And we sort of saw that with the uh the list example, right? So there is some grand lock, right, that you lock first, then grab all the mutexes that you need. Right, and then now I have all of those mutexes I unlock, and that way we can't like lock things sequentially. So if, if you can imagine you had lock me abo above and below unlock for like these, you know, lock A, lock B, Lock Block A examples, right, you wouldn't be able to do that because you need the metal lock in order just to lock A and then lock B. So basically you grab the metal lock and then you're like, I'm going to lock A, then I'm gonna lock B, and then I'm unlock that and someone else would be like, oh, I don't have the metal lock, so I can't have stolen B while you were waiting. Um, so one of the problems is that like you sort of gotta ask yourself if you can do this. Why do you not just have one lock? Like, like, cos it feels like you've got one lock, right? Um, and if you, if you can do everything with one lock, why can't you just do everything with one lock? And the other thing is that it's like, it creates a bottleneck, so everyone needs this lock all the time, and it means that like for some tasks it slows it down because everyone's waiting for this, you know, like it's almost like you're trying to pretend that you've got one processor where you're like, OK, I have the grand lock, OK, now I have the processor, I will do stuff, and then you don't have things um operating in parallel as much. Um, another option is that you can add preemption, right? So basically, and I was like, when I read this code, I was like, this is clearly the wrong answer, cause it's got a go to statement in it. Like, I don't know, right? Like, maybe, maybe whoever came up with this idea did a lot of assembly where jumps are like a lot less frowned upon, but like, seriously, go to top, are you serious? All right, but basically you can see what's going on here. You can go, I will lock it and then I'll try and get lock B, but if Lock B is not there, And I will give back lock A and go back up to the top and then try again and try and lock grablock A. So you're like, grablock A and this is kind of like the chopstick example. You're like, OK, I'll get this chopstick and then I'll try and get that chopstick and if I can't, I'll put this one back. And then I'll try and grab it again and I'll then just do it forever. Um, Obviously there are problems with this like busy waiting and no guarantee of progress, right, so statistically, like it probably would work, but you know like theoretically there are situations where it won't work. Um, but one of the things that this creates is the concept of LiveLock, right? So I'm sure you've all heard of deadlock. Has anyone ever heard of LiveLock? No, 01, right. So in deadlock, right, and the difference between deadlock and LiveLock is when something's dead, it doesn't move, but when something is alive, it does, right? So the only real difference is that of it conceptually is that in deadlock, nothing is changing, so you get to a point in the system where all of the processes that are running are now waiting and doing nothing. But in LiveLock, you're in a situation where everyone is doing something but no one is making progress, right? And so you can imagine the case with the um Chinese restaurant with the 5 people, and you can imagine them just going like this, right, and if they all had the same random seed, they'd be doing that forever. But there would be no deadlock because none of them are stopping, they're all, they're all like still going, they're just not achieving anything, and they're just stuck in this like trying to grab locks for all time, right? And live lock actually occurs, and it can occur over like massive cycles, right, because you can imagine you have a lot of. Different systems, right, and they're all grabbing things and putting them down and going, oh no, I can't do this. Alright, I'll grab that, I'll put that down. I'll give this to this and, and they'll go around this big cycle, but nothing ever happens, right, so they're they're they're constantly butting heads or like, um, who here has their driver's licence? Have you guys ever been at like a roundabout where you're like, no, you go, no, you go, no, you go, no, you go, right, or like one of those situations where you just, you're like, we're at a door and it's like, no you, no, no you, no, no, no you, right? And you're like there basically forever, um, because neither of you wants to actually go and then every time someone goes they move their car slightly and then you're like, oh no wait, oh wait, no, no, OK, right, that's an example of LiveLock, right, because it's not like you're waiting really for the other person, you're actually in this sort of negotiating the, the mutex. Um, And then the other one is you can like eliminate circular weight, which I think is the correct answer to this, that is to say that like if you have a system, right, where you have control over mutexes, there is probably a way that you can order your instructions so that you don't get deadlock, right, and this is hard, right, um. But, you know, like, uh, it, it feels like the the actual solution, right? Um, so, you know, you need to decide ordering of locks, right, you need to make sure that you don't have these any of these obvious uh circular weights, um. And yeah, the, this kind of approach works well in systems that are well architectured and, you know, structured in layers and things like that where you can be like, OK, you know, I can go, you know, like, if a, if a, if a system is structured like a tree, right, and the way that you conceive of it behaving is like a tree, it's much harder to have a cycle in a tree because trees don't have cycles. So yeah, in layered systems, um, it's pretty good. In systems where they have lots of things, talking to lots of things, then deadlock is really, really common or it's it's very easy to get deadlock, um. Uh, yeah, and yeah, that's basically that I think. Alright, so the last thing that we're gonna do today, um, is what's called banker's algorithm, right, and so this is the, I don't know, uh, mathematical part of the lecture, I guess that's what I would describe it as, um. What we're gonna do is we're gonna consider an example where we have a bunch of semaphores or resources and we have a bunch of processors and we're trying to work out the order in which we can run those processes, such that we can guarantee that they all get to run, right, to avoid deadlock, right? So. What we're gonna have is gonna have this concept of like the maximum resources, how much do you already have and how much is available, right, so we're gonna have three sets of numbers like the maximum resources that we require, how much each individual process has, and then how much is available, right, so how many extra ones are there? Uh, and the max sorry max maximum resources that you need, so like you can calculate over the course of your life or like as a process, how many car spots you need cause you're some kind of car spot algorithm I don't know, or how many um printers do you need or whatever it is, um. And then what this allows you to do is go, OK, I've got all these processes already running, how many of these resources are they already using and how many are left over? OK, and then, yeah. The idea, yeah, I mean this is just a fancy way of saying well we'll just go through the algorithm and then we'll see what this actually means in practise, cos I don't know, I didn't find this particularly informative. It's like it's being in a safe state, right? There's safe just means, oh, I can finish. OK, OK, let's let's just go through. OK, so let's see what this actually looks like. Um, I have allocation in blue, I have the maximum in red, and I have the available ones in green. Right, and like this is just convenient for the purposes of like I guess writing it down for an answer to a question that you might see in an exam. Um, basically I have 4 processes here, or 5 processes here, and each of them has a number of semaphore like things, right, resources A, B, C, and D, yeah. Yes. All right. I hope he's not actually watching the Leger yes. OK, cool, um, right, then we have Max, right, so what we're saying here is that process 0 in this case already has 1 C and 2 Ds at most during its run time from now until it finishes, it will only ever need 1 and 2, right? Um, process 1 only has one of A, but through its lifetime it will eventually need 7 B's, 5 Cs. It just No, OK, OK, 50 5 C's and zero D's, right, so that's what it will require, right? So, uh, one, like it's, it's fairly straightforward here I think it's like I'm going to need, I don't know what's a, I will need, I should have come up with a use case. Does anyone have an idea for a use case of things that people might need? I need apples and oranges, doesn't sound right. I'm drawing a mental blank here. I will need 7 pencils and 5 boards and 3. I don't know. Oh, I know, I know, I know, I know. I'll, I'll make it mediaeval, right? I need, I need one battering ram, 7 ladders and, and 5 knights or something like that to take this castle, right? Um, and so we're gonna work out what I, what I have currently. I have one battering ram, but I need 77 ladders or something like that, right? And then we have available which is the 1520. OK, cool. So that's relatively straightforward. OK, so are we safe? is the question that we're gonna ask. First thing we're gonna do is gonna calculate how much allocation do we have in total, right? So if I add all of the allocations in total, I get 3, 1412, and 12, right, so this is me adding all the things that are currently allocated, right? If I add that to the available, I should work out, you know, like how many resources the system has in total, right? Because like I've already allocated all of these, these processes actively really have these resources. I'm saying that I have 3 battering rams, plus 1 available, so there are 4 bat battering rams and there are 19 ladders and 14 knights and 12. Flags, I don't know, some other thing that you need for taking castles. Alright, so what we're gonna do first is we're gonna calculate, OK, well, if I know this, I know all of these numbers, what I can do is I can calculate how much I need, right, which is pretty simple, right, like. Max minus allocation, right, like as in like if I need 100, no sorry, if I need 1750 and I have one, then I need 750, right, so hopefully, This one does not need anything. This one needs 750, which is the example I gave. Right. What do we think the next number is gonna be? Is it gonna be 3? Is it gonna be one? Yeah, all right. It was a one, alright, cool, so, so far so good, pretty, pretty simple. This is how much I need in order to finish, and this is how much I have available. So, And we're using available satisfy the need. That's the question that we're gonna ask. And what we can do is we can be like, I have 1520 and I need zero. that was complicated. What am I going to do now? I'll run process zero, right? That, that seems fairly logical, right? Like you just you like I went to the first one and I, it, it doesn't need anything else, so I'll just let that one run first. Yes, OK, cool. So then I will Cause it doesn't need anything, right? I will check this one, can I run this one? No, I cannot because I need 7, but I've only got 5. Right. And then I'll go through the rest of them and I'll be like, ha, these are the ones that I could potentially run. Yeah, so I could run process 4. It needs 6 632, sorry, it will eventually need 652 as its max, right? It's already got 632, so I've got two Cs available, right, cause I have two C's available, I could totally do this one. So this one's fine, right, so this 2 is less than that. This one I can't do because I need 6, but I've only got 5, right? So what I'm gonna do is I could pick either of these to just immediately run, right, because I've basically gone through this list, found one that I could run, and I can just run it, right? Um, so I just pick one of them and because of arbitrary numbering, I'll pick 0, yeah. And then I will pick P3 because I can also run P3. Excellent. What No. By running P, I'll run P0. By running P0, what am I doing here? Wait, is that number right? 1352, 1352, 1532, 15, 1532? I feel like I put the wrong number there. Oh no, I did put the right number there, yeah, cool. So. Here's the logic, right, when I run P0, right? P0. I have 001 and 2. That's what it's allocated. And by completing P0 I can free up those resources, right? Now I can be like, hey, I will give back my night and two flags. I don't know why I need flags to take a castle, but I'm just gonna run with it. Um, and so if I add that to my current available, which is 1520, I'll get 1532, right? And so. This is where this table gets a little bit confusing, right, because I was like, wait, why does this go here? It goes here because these tables, you know, like it looks like a table, but it's kind of fake, like it's a fake table. Like this here is going to be like a list of like the algorithm going through time, right? And then this here is going to be like associated with P0 P1, P2, P3, P4. This is how people do it on the internet. And I was like, OK, that's confusing, but basically just take into account that this first row just refers to the fact that I have just decided to do, like that's what I start with with my available, and as I go through the algorithm, in this column it's just going to be how much available I have over time, right? Um, and that's it. So this is now having run 0012, like I've, and it required 0012. I can get those resources back, so now I have 1532. OK, cool. And I go through my list again. Except that one's now greyed out cos I don't need to do it anymore. And what I do is I go, I, I find the next. Thing right with the need that I can do with the resources that I have and in this case I can do P2, right, so previously I couldn't do P2 because I didn't have two Ds, but now because two Ds were freed up in doing P0 I can do PE2, right? And so I will add P2 and then I'll free up P2's resources which will give me 2886, right, so basically I add 135421532 which gives me 2886. Yes, those do add up, good, right? And then I go through my list again and I go, oh, OK, I can't, I still can't do P1 because why can't I do P1? Oh no, no, I could go P1, but the way that this works is you basically just keep scaling through the out like it doesn't really matter like how you would do it in a way because it like you could just keep going through until you find one that works and then you go back and start again and go through and find one that works. But basically this one is now. Available, right, cause I can do 0020, right? So I can do P3 after that. I can add that one to here, right? And then I free up P3's, um, resources, and then that one is done, and then I can look at P4, P4, can I do it? 04 0642. I should be able to do it. Yeah, it's green. And then I can do P4. And then eventually I'll, I'll loop back and then get to this one. I'll be like, All right, can I do this one? Yes, I can do that one and then I'll add it to my list, right? So the reason I've done in this order is it's going around in like a cycle, essentially, like I started with P0, right, so if you imagine going back to the start, I only actually need to calculate this first row before I decide I'm going to do P0. I've just shown you what the need calculations would be, right, um. Uh, because you can pre-calculate what the calculations are, um, but when I do the first one, I just do P0, right, and then I go through try P1, then I try P2, then I try P3, then I try P4, then I try P1, then I try P2, then I try P3, then I try P4. And that's why you end up with this ordering which is P0, P2, P3, P4, and then P1, right? But you can see here that like I could do P1 right now, right? Uh, I could do it in here, right? I could have done it back here. Yeah, because it only requires 7 and 5 for B and C, but I've got 8 and 8. but because I'm just like um cycling through, um, it means you can kind of get the order of it wrong, um, but you start at the top and you just try row 1, try row 2, try row 3, and then you just keep cycling it until you're done. Um, yeah, and then I can now say that I've done all of them, hooray. So if I were to summarise what this algorithm is, right, we set all the processes to not ready, right, so that's the first thing we do, we go to like, they're not good, we don't like them, right, we calculate all of their needs, their need is the max allocation they require minus the allocation they currently have. We find all the uh runable processes where the need is less than the available, we run the runable processes available plus equals allocation, and then we repeat from 3, right, so we just go around in a circle over and over and over again. Um, cycling through until we find something. To me, I'm surprised that this is an algorithm, right, because this, this doesn't really merit a name because it seems to me to be like the most obvious thing that you could ever write. It's like, I check if I can run something and then if I can run it I run it. And then I check something else and then I. Once I've run it, I can get those resources back. I don't know. I wish I was alive at the time that like people were doing, you know, like Dykstra was around because I feel like a lot of these really early algorithms, you know, they like, I, at least it's not another Dykstra's algorithm, but like, you know what I mean, where you're like, is this even a thing? I, I feel like this is a problem that you'd give to like, I don't know, 2 year programmers and they'd be able to solve and come up with this algorithm on their own. It's also known as the data algorithm. Um, cool, and I think that's it. I think we're all at the end. Uh, are there any other questions? Alright, I will pause the recording. If it's not already paused, it's not already paused, good. Um, have a good weekend and good luck with your workshop prep if you haven't done it and your assignment if you haven't done that either.
