SPEAKER 0
Yeah, no, no, just, just, just wait for the new uni. Uh, I'm, I'm currently working on the Masters of Artificial Intelligence Machine Learning. There's machine learning algorithms, there's programming for artificial intelligence and Machine Learning 1, programming for artificial intelligence Machine Learning 2, Applications of artificial intelligence and machine learning, Advanced applications of artificial learning machine. There's topics in it in machine learning topics, and then it would be toss. It, no, that's topics. Yeah. Yeah, no, no, I totally agree, like we, we name things in, in very frustrating, very frustrating ways.

SPEAKER 1
Yeah, oop, I, we had I, oop, I was I. Recognize.

SPEAKER 0
Yeah, yeah, no, no, that's true. Anyway, we've gotta get started, um. Welcome everyone, it is week 8, right? So we got holidays as of tomorrow? Yeah, alright, yeah, cool. Yeah, no, exactly, right, I'm, I'm, I'm psyched. Um, so I'm, I'm just gonna start with some housekeeping stuff first, as I usually do. Um, which I probably should have prepared in advance now that I think about it, but let's go to my uni. Um, I got bored, no, it isn't that I got bored, um, but it is partially I got a bit bored. Um. For fun, um, because, uh, I said I would. No, not modules, um, where is it? Where's Echo 360? Echo 360 back in the day, um. Very, I made a. Video, which is a workshop 10 God, is this right? We in Metalland, yeah, cool. So, um, there's basically just a video of, um, the, uh, this kind of question. Does everyone understand this kind of question? What is it, scheduling, essentially? All the scheduling things for Workshop one, for the bonus question that was nominally in workshop one, where I go through 6 different algorithms at length in detail, like in laborious detail. There's like 100 and something slides. Um, but hopefully, this will give you an idea of like how you would. Be able to do that kind of question. My plan is to do that for like all of the other sort of nitty gritty technical kinds of questions in the course, so like, You know, like, uh, stuff about like if it's mostly the calculation stuff. The reason is, is because, like, as in, or at least my rationale for it is because if I do that in a lecture and I try and do calculation, you really need to be in the mood right here and now to be writing things down, right? For that to be useful, right, because you know like if you're doing a calculation style question, most of the time, the way that I have learnt them traditionally is either I am looking at a textbook or I've got a video, and I've got a piece of paper and a pencil, and I'm going through the calculations myself. Now because no one really wants to do that in a lecture and, and. To a large extent during lectures, I'm encouraging people not to be doing that in a way by trying to be, you know, like entertaining. I'm gonna sep I'm gonna record those videos separately as online videos so that you can sort of just use them and go through them and um if there's any, any specific part about the process of it that you're confused, you should be able to just follow it in, as I said, quite a lot of detail. Um, second bit of housekeeping is, I think there's an assignment due soon. Is it? When's it due? Sunday, right? OK, yeah, so that's the coding part of the assignment. Um I've received 900 emails all about groups, and I want to die at this point in time. If anyone wants to send me an email now, from now on, about how they don't like their group or they want to change groups, like 2 days before the due date, I'm sorry, uh, it's the holidays, I'm not gonna be replying to those emails, um. Look, as per my announcement, I don't actually think this assignment, like the, the coding part of the, this assignment is particularly um, You know, like, I think this is a group assignment to save on marking rather than the total amount of effort it takes to complete, cause you basically just have to implement a bunch of algorithms, um, that we've gone through. Um, part two of the assignment I think is due during the holidays, it's like a week, the, the reporter's week after. Um, but here's the warning, Bernard's going on holidays. I'm gonna be in China as of next Friday, until the end of week 9, right? So at this stage, because I think I've gone through most of the material relatively quickly. Um, I think I can just not have a week 9, so there might just not be a week 9. There will still be workshops, right, so I've, I've got all the workshop stuff up, right, so the workshop stuff will be up, um. But I don't think I'm going, well, I'm definitely not going to be holding a lecture in week 9, right? And I don't think um I will be uploading uh uploaded recorded lecture in week 9 either. Um, I've had a look at the rest of what's in the course and I think I can get finished by week 12 without any trouble. So that's just a heads up. Um, while I'm in China, I will be trying to answer my emails, and I don't know how much the Chinese government is going to allow me to do that cause I've never gone to China with my uni email before. Um, I do have a VPN on my laptop, and I'm trying to organize. If anyone has any advice on which VPN I should get while I'm in China so I can actually still access like the, the rest of the world's internet, that would be really helpful. Um. I'm, I'm open to any suggestions at this point in time with experience of people who have been there relatively recently cause I, I, I've looked up a lot of stuff where it says, you know, you can go and you use this one and it's actually lying to you, it won't work. Um, so we've got covered workshops, covered assignments. Um, assignment 3 will be up at the end of the holidays, um. Basically I'm working with a colleague who's building the course for next year for the new university, and we've got an idea for building an assignment. If that pans out, then that will go up, otherwise I'll be using last year's assignment, but either way it's gonna go up at the end of next, at the end, before the end of the holidays, hopefully I'll have it before I actually leave, which is next week. Um I will also put out an announcement before I leave to this effect in terms of who you should communicate with if you can't get in contact with me. Um, then, what else is there, assignments, workshops. Uh, that's it, I think, right? Um, cool, alright, so let's, uh, any questions? Otherwise I'm just gonna get started. OK, excellent, alright, so let's get going. Today we're gonna be talking about RAID, ooh, as we previously discussed, it's an acronym. Uh it's a very cool sounding acronym and it's kind of a bit boring. And it's one of those things that I don't know how relevant it is anymore. Like, obviously, like, um, I have used a raid drive, right? And relatively recently, like within the last 3 years, I've used raid drives, um, but. You know, um, and maybe they still use ray drives when they're doing cloud stuff, but a lot of stuff's been doing on the cloud now, so it may eventually no longer become a relevant thing. Then we're gonna talk about file systems, Iodes and storage. Um, for those of you done computer, no systems programming, I'm just gonna be talking about Iodes again, so that's gonna be a lot of fun. Um, alright, so. Let's start. What if we had more discs, right? Um, is really what we're gonna talk about, right, so. Essentially, when we have hard drives, right, we've got a couple of things that we have to worry about, right, which are capacity, reliability and performance, right? So what do we mean by that? So capacity is like how much stuff can we store, reliability. Now when it comes to hard drives, oh, I, here's a, here's a quick question, who here has had their hard drive fail? Only a few, right? Um, it's not as bad as it used to be. I have had probably the better part of 5 to 10 hard drives fail, um. Yeah, right, I mean that that's partially cos I'm old and also partially because I kept on buying the wrong hard drive to be my like system hard drive back in the day, um. Cause there are different kinds that are good for different purposes. Um, and yeah, so I've had, you know, somewhere between 5 and 10 hard drives fail. Um, so it's actually like a real thing, um, and I have had them fail in ways that were a little bit, I, I, I, I don't wanna say catastrophic for my life, but like, you know, the kind of thing where you know like it's like your house burning down kind of level of frustration and uh inconvenience. Um, but yeah, so. The question then is, and performance is the last thing, it's like if I want to get my data out of my hard drive really quickly, that's the that's like the last part, you know, like, and we've talked about SSDs and you know, hard drives and stuff like that, um. So, one of the ways that we could, if we were like wealthy and we had lots of hard drives, is we could just use them as like lots of hard drives, I guess, or like a whole bunch of disks rather than just one. Right? Um, but once we have more than one hard drive, now we can start thinking about like how we could use it slightly differently, right? So. You know, what we could do is we could, and this is what RAID is, which is a redundant array of independent disks, but it's really just a way of saying, oh I can make a little like bit of hardware that you slot hard drives into and it sort of treats it as one big hard drive in some way, right? Like so basically if you think about it, you know, I could have, you know, 10 hard drives, and if they all connect to this one bit of kit, maybe I can cause that one bit of kit to do all the logic to make them think that they're one hard drive, right? And so then the question is like what kind of hard drive do I want? Um. Why would I do this, like I mean, cause it's really cheap, right? Like basically, like, it's one of the things it's like, it's, it's kind of solving a problem that I don't know if people have anymore, to a certain extent, like I mean, admittedly my laptop, I'm struggling, like I can't install Baldur's Gate 3 because it doesn't have like 120 gig spare or something like that, right? But like, that's the first time in like, I don't know, 5, 10 years where I've actually had to think about hard drives, right, and it's like, oh I can't put it on my personal laptop, um. Hard drives themselves, right, if you wanna have a small hard drive, right, that has a lot of memory, that is expensive. But if you wanna have like a lot of space, you could just have a whole bunch of really big crappy hard drives, right? And so like, you know, if you're a business and you wanna, you know, store, you know, ridiculous amounts of data, then there's this idea that you, what you want is you just want a whole bunch of cheap, kind of big, physically big, right, um, but you know, like relatively cheap hard drives, right? Um, and so that's what Raid is essentially doing, it's basically going, oh, OK, well how do I manage all these hard drives together? Um Option number one That option, really, that's my first option, is redundancy. OK, so one of the things that you could do is if you have multiple hard drives, what you could do is you could actually have the same information stored twice, right? And for those of you who've had a hard drive fail, this makes a lot of sense, right, like as in having your data stored twice is basically having a backup, and if you have a very sophisticated backup, whenever you, when, when one of your hard drives fails, you just get a new hard drive, plug in the new hard drive, and then it updates with all the new data, you're just like, I had a backup failure. And now all your data is still there, you've not lost anything, so that's one way that you can do it. Um, but the other way that you can do it is you just sort of extend your data. Um, OK, so. From a technical point of view, it's, it's pretty trivial, right? Like as in like the, the logic behind it, right, because you're just going, uh, OK, instead of from 1 to 5 gig and 5 to 10 gig, I'll just add 5GB to the second hard drive, done, right? Like it's, it's basically just arithmetic, there's very little like. Like you don't have to think very hard about a lot of these things. Like when we get to raid 5, that's where we've got to think a little bit more, um, about math, but the math is really, really straightforward because you can just like offset things. You just got, it's like a virtual memory. You just go, oh, it's start at + 10,000, right? Um, but one of the things that's interesting is that like with a raid drive again we're gonna create this level of, Sometimes they use the word transparency and it, it frustrates the crap out of me, right, right, because I'm like, that's not what the word transparent means, right? Like in, in an operating system, a lot of the time they're like, oh that means that, it's transparent to the operating system, you're like, but is it, is it transparent? Normally that would mean I could see what's on the inside. I'd like to think of it as more opaque. Basically, the idea is that it's abstract, right, the operating system doesn't actually see what's going on in the rate drive. It has an idea, an abstract idea of what's in the rate drive. What the rate drive actually does is up to the rate drive, but from the operating perspective, operating systems perspective, it just sees one big hard drive. Um, So, now we're gonna get into like how we do this manually cos we've got a coup, oh yes.

SPEAKER 1
No.

SPEAKER 0
Yeah, yeah, so like, you know, like the operating system might be like, I wanna, like, let's imagine I've got 22 hard drives, and one of them goes from 0 to 1000 and the second one goes from 1000 to 2000, and I say I want address number 1500, right? I need to know that that means put it in address 500 on hard drive too. Right, and so that's that mapping kind of process. Um And Raid does that and the operating system just goes, I have 2000, right? Um. So, um, yeah, redundancy, oh God, sorry. Whenever this happens, I'm just like. I've gotta fix it. Redundancy, there we go, redundancy. Not always, you'll see in the video I recorded last time, I did not change one thing cause I was just like, oh my God, that would be so much effort. Um, so, one of the things with redundancy is that like if we're gonna have two copies of something, it kind of implies we have to have two copies of it, right, which means when we write something, we need to write two copies of it, yeah, so like you know, one for the real one and one for the backup. One for the real 11 for the backup. Um. But one of the things that's kind of cute is that if we're reading from it, we can read from either of them, because both of them are true, right? Now, for us at you you're like, oh well I can read from two, how's that useful? Well, imagine if I have physical hard drives and I want to read two things from, My data, I can read one from one hard drive, like I can read address number 35 from one hard drive, and then. I could readdress number 71 from the other hard drive at the same time, right? Um, and I wouldn't have to have both hard drives, and we're thinking in slow hard drive land, right, where they've got discs and the discs are spinning. Both disks could be independently spinning to different locations, right? So I can actually, by having backups, increase my performance because I can read more things at a time, because I have more places to read stuff from. Obviously, I slow down my writing performance because I have to write to both at the same time, but when I read it's actually efficient, um. And yeah, the more duplicates I have, the more space I require physically, you know. OK. So when we're talking about raid, we need to think about, you know, what you know like we're gonna compare raids and say this raid good, that rate bad, um. Or different architectures for Raid, um, we need to think about like, like, again, it's, it's it's the same thing that we would have done for scheduling, or the same thing we did for memory, all of these kinds of things. What is the actual job? What's the workload, like what, you know, like if, if all we're doing, for example with the backup is taking huge sectors of data and then copying it and writing it to another huge section of data, that is a very different task from oh I want this bit and then I want that bit and then I want this bit and then I want that bit and then I want this bit. Right, you can imagine if I've got a disk there, it's spinning a lot, right? Um, if I'm doing sequential reads it's just going around in a circle very conveniently reading lots and lots of data. If I'm doing a lot of random access memory, I'm like, I don't know, like some kind of weird DJ um spinning disks. Um, but yeah, so we need to consider what the workload is gonna be. OK. I just said this, see, sequential and random, right? So sequential, I'm just gonna grab all the data in one big long train, random, I'm just gonna grab little bits of data all over the place. And you can imagine in a SSD these two numbers are not very different from each other, right, but in an H, ED they are, right, like as in so random access I'm gonna spin the disk a lot, sequential access I'm just gonna find the one location and then spin it once and then I'm all done. OK. Um, Considerations, how to do the mapping, yeah, we've talked about that, how do we use the extra blocks, we're about to talk about that, different raid levels, make different choices. OK, cool. That's all you need to know. There are different numbers after raids, so we, we'll use phrases like grade 0, raid 1, raid 2, raid 3, raid 4, raid 5. That indicates how we're using our data. That indicates whether we're gonna use more redundancy or we're gonna use more like extension, making big hard drives, that kind of thing. Um. We go back to our three design constraints which are capacity, more space, reliability, more failure, and performance, how fast it is to do certain jobs, and the numbers I'm gonna use here for all of these examples are these, which is N, C, S, R, and D, although this is gonna get a bit expanded and we'll see why in a bit. But basically it's the number of discs is N, the capacity of each disc is C. Um, and then we've got sequential throughput and random throughput, so those are going to be two different numbers, and we are going to assume that S is a lot bigger, Than R, right, so we're we're not talking about time, we're talking about throughput, so we're talking about speed, right, so S is a lot faster than R. If we were talking about time, then R would be a lot, lot longer than S. Um, and then we've got latency of one small eye operation, and that doesn't really come into it very much. Um, there are a few cases where the latency does matter, um, but it doesn't really matter as much in this, um, calculation. OK, so option number one is rate ro, right? And raid zero is actually striped, right? And this makes a lot of sense in some ways, right? So, you know, like the naive way of joining two hard drives together is, as I said in the first place, is you just like add them together. Like you literally take one and concatenate it with the next. If I have 1 gigabyte here, then I put the next gigabyte there. But that doesn't actually make a lot of sense, right? Um, any, any guesses why? Why would we not want to have one hard drive then the other hard drive? Oh yeah, yeah, yeah, so if you lose one disc you're you're gonna lose like a whole section of the I'll ask you the question, what happens if it's striped and you lose one disk? Yeah, yeah, yeah, which, uh, could almost be worse, right, like if that makes any sense, um, it's more to do with like when you read, right? Because, or if you're going to write stuff, right, because the goal is we're trying to distribute it between the hard drives, yeah. And so if it's striped and I wanna like read from a sequential bit of text, I can be like, I'll read this bit, then that bit, then this bit, then that bit, then this bit, then that bit, right? And it means I can be reading or writing to both hard drives at the same time, right? Um, if it's all on one hard drive, from the perspective of like reading speed, the chances are we're only gonna be reading from one hard drive, so we're not gonna really make any saving, right? So that's why we would use striping, right? The, the IO is evenly distributed, zero dis but. As we say here, 0 discs may fail. I would actually argue that having them concatenated would be like slightly less risky because then you'd be like, well, at least I saved some of my data, rather than every like second byte is now missing, which I, I don't know what you'd be able to do with that, um. In terms of the maths, um, I'm looking for chunk number 45, where is it? It's pretty easy, right? Um, we can just calculate it using, you know, integer arithmetic, modular arithmetic, you just like mod 2 and divide by 2, and that gives you, you know, like address 521 divided by 2 is 260, and mod is 1, so it'd be in disk one and it would be at location 260. Very easy. Very simple exam question. I don't know whether I'd ask that as an exam question cos it's so easy, but like maybe if I'm like, can you explain how striping works and you gave this as an example of how to do it, I would be impressed. Um, there you go. OK, Striping with higher counts, up here on the right, you can see that basically this is how you'd do it if you had like lots of discs, which is kind of trivially obvious that you'd stripe, you'd be like, oh, so in disc 0 I put the first one, and then disc 1 I put the next one, and then disc 2 I put the next one, right? So it's not particularly difficult to extend this idea to infinite discs. Um, but let's have a look. Um, if we do striping. Let's see if we can have a guess, right, if the capacity of one hard drive is C, and we have two hard drives, and we use striping. What do we think the final capacity is going to be? Yeah, to see. N times C where N is the number of discs, right, OK, yeah, sorry, I should have asked the correct question. Alright, what about how many discs can fail? We've already discussed this, right? How many discs? At all. If any of them fail, it's kind of, we're kind of stuffed, right? Half of our data is gone and it's a very inconvenient half. Uh, latency. Latency is just D because it's, we're still looking at the same bit of disc. Um, there is a level where you could argue that, you know, depending on where the discs are spun randomly. Um, sometimes it could be better and sometimes it could be worse, but basically it's gonna be D in this case. Um, throughput. We put N times S, we've got more discs, right? So we can nominally have more discs going at any given point in time. We can, we can have, you know, write more to one of them sequentially, we can write to two sequentially, you know, writing half the bits to one, half the bits to the other, um, and randomly it's gonna be N times R as well. So this is actually the highest performance that we're gonna get, right, like as in if we, we basically just assume that we've got one, we can write to many discs at once, we can read from many discs at once. Um, it's actually pretty cool. Uh, all right. We can also change the chunk size if we want to, like as in like we can stripe it however we want, so you can imagine that like you put every second page on the other hard drive, cause we're doing paging presumably, right, so we could do like 1 page or 2 pages or however many pages we want. OK. Is an an exercise for the audience. See whether you can think. Alright, I'm gonna do my little lap. Question number one is, what is an advantage of a small chunk size? So this is what a chunk size is. So the idea is why would we make the chunk size small? And what would be good and what would be bad about it, and I'm going to do a lap and get some exercise and then come back, because this will take a little bit of thinking, I think. Oh right. I do have. What, it says that I have sound. I can hear myself. OK, there we go. Alright, do we have any ideas? Small chunk size, advantage, yes, or disadvantage? Excellent.

SPEAKER 1
Yeah.

SPEAKER 0
Oh, OK, alright. OK, OK, OK, OK, so. Yes, I can. Alright, cool, um, do I have a slide? I have a mouse on Have I got the answer actually already written, or have I not? OK. Alright, let me, let me, let me explain. OK, so small chunk size makes sense, right? When you have a small chunk size, it means that every file, if you have a, a file of a reasonable size, it's gonna be spread across many disks, right? That much, that, that answer I think is fairly self-explanatory, like as in. You know, there's more discs. If the chunks are bigger, what it means in general is that like you're pretty much always gonna be running from one, you know, uh, reading or writing to one disc, yeah, right, and so you, you're gonna lose that um distributed sense of it. Right, but that's true if you're sort of doing random access stuff, right? If I'm randomly accessing stuff and I'm just randomly grabbing different bits of disk, you know, if I grab 2 and then 71 and then 33 and the trunks are really small, I'm grabbing one page from many discs and I'm parallelizing really, really well, right? So I've got lots of data coming in from lots of little disks. If I'm reading sequentially, it's, it's like less obviously good, right? Because if you think about it sequentially, right, the, the best way to read sequentially from a disk is that you find the spot that you want and then you just walk in a straight line and, and grab all that data, right? Like just immediately like read, woo, along the data, right? But. If I don't do that, and I'm like, oh, I would like to have every 10th thing, right, right, which is what's gonna happen with striping, like every, I want every, well let's say I want every 4th 1, I'm gonna be like, this bit, oh wait, no no no no no, now this bit, no no no no no no, wait, now this bit, right, and it's going to like not do that as well as if I just went, can I just have one long strip. Right, so basically what's gonna happen is the hard drive is gonna be like uh because I'm sending all these separate seek requests to it rather than going seek here and then go, right, um, and you would hope that it's smart enough not to have that as a problem, but like it, it could get to the point where like basically it's like I read this bit, oh wait, I'm gonna wait for it to go around another loop or something stupid like that, right? Uh, yes. Yeah. Yeah, exactly, right, so there's this extra, there's just all these, you know, like you're just going, get this, get this, get this, get this, get this rather than go get from 80 to 900, right? Um, so for sequential ones, right. Um, you're gonna end up with, you know, like, it's, it's like a fake game, right, um, because it, it's not gonna really be much faster than if you just read from one, Um, Yeah, yeah, and, and, you know, like, um. What do you call it with small chunks, the, yeah, positioning time bound by the maximum maximum multiple requests. I think that makes sense. Um, and yeah, big chunks, they're less likely to be cross drives, but you know, again, if it's sequential access you really don't care about that so much. Um, OK, option number 20 yes, sorry, yes. Yeah. that Um, so, can you, can you ask that question again? Well, normally, like if, if you can parallelize if you're mirroring, because I can read from this disk to that to that disc, right? Like as in there's two discs I can parallelize that, but if I am striping, I can't, right, like I can't, you know, like, normally, normally I would be reading like a big chunk of data, right? So only if I've got a lot of separate little read requests can I make that kind of parallel, right? Um. And the bigger the chunks are, just because of locality, the more likely that the things that I'm gonna ask are gonna be in different pages, right, and therefore in different chunks, um. But if I, you know, like, because of locality, if I make lots and lots of requests like I'm doing a full loop repetitively in a, in a thing, I'm gonna be making lots and lots of requests to the same bit of memory, and I'm gonna be asking for that same bit of memory over and over and over again, right? And so I can't like. Like I'm not actually asking for different hard drives, so I don't get any benefit of reading from two hard drives simultaneously. Does that make sense? OK, cool, alright. Uh, Next question, oh no, no, next question. Mirroring, next option is mirroring, right, like, has everyone heard of mirrors before? Like, who here has downloaded illegal software? Uh, no, legal software, legal software, right? They do mirrors, right? Um, so, uh, on the internet you'll often see, um, you know, for if you're downloading all kinds of things, they, they'll have that, well, I don't know if they do that that that much anymore, but you know, like they were used to have like country-based mirrors, so like if you're downloading, you wanted to download some large bit of software, you'd have a download location and then they would actually have explicitly like the one that you'd download if you're in Australia because it will be faster because it doesn't have to transfer stuff from the US, um, and they'd have multiple mirrors for download servers and some of them would be busy and so forth. Um, but yeah, mirror is what it is described. You make a mirror image, it's basically a carbon copy, exactly the same of two things, so each one is basically duplicated into two discs. OK, so this is annoying because it means whenever you write, you have to write twice, right, you have to write to disk nought and to, uh, disc 1 at the same time. Um, and you can see here is that like you can do mirror and striping at the same time, like this is nominally mirroring, you only have two, right? So even if you have 4 discs, you just mirror twice and then you sort of raid zero the rest, so you stripe the rest. So if you had 8 discs, you would still have 2 copies of everything, um, but you'd be striped 4 times, I guess. Um. Yeah, um, but we do have the advantage now that one disk may fail, right, and one of the things that is very important to understand about hard drives and the way they fail, the most common cause of failure in a hard drive is failure to hard drive. It is not failure of sector, right, so it's not like hard drives often like one little bit of the disk is corrupted. Usually when a hard drive fails, the entire disk is destroyed, right? Um, and so what that means is that like basically it's actually kind of convenient because you know like if everything is just on one disk, we're all good and we get rid of one disc and we replace it with a new disc. Um, but that's kind of how it's gonna fail. Um, alright, let's see if we can do capacity. What's the capacity of the new hard drive? Let's assume that we have N, Nisk. Oh, actually, let's assume that, hm, what have I written? Actually I've got to see what I've written, cos I might have gotten this wrong. Let's have a look. Nominally, if we had 2 hard drives and we've mirrored, what would our capacity be? Yeah. Yeah N times C on 2, I think is the correct answer. I might have just written C here. C on 2, there we go. Da da da. There we go. N times C on 2, N times C on 2. I've got to fix that up. Um, that makes sense, right, we've got, um. 2 hard drives, each has a capacity of C, so our capacity divided by 2 if we have any hard drives. Um The number of disk fails is somewhere between 1 and N on 2, right? Now, why does this make sense? Well, 1 can definitely fail, but if you can imagine. And I had like 16 hard drives, it is possible. That 8 of them could fail. As long as it's the correct 8, right, like as in, because if we think of like 16 hard drives, we could say that every odd hard drive is one half of the mirror, right, so we, you know, we'd, we'd have 13579, 15. 11 and 13 As one set, and that represents one bit of data, and the other bit of data would be 02468, 1012, 14, right, and that would be the other bit of the data. And so statistically, when one fails, that's fine, but there's a 50% chance that when the next one fails, we're also fine, right? And then a 50% chance when the next one fails, we're also fine and so forth and so forth, up until we could have potentially 8 failures. But, you know, like on average, that's bad, right, like as in, you know, there's a 50% chance that we're just done after 1, so. Um, but yeah, so we could have up to 2 on 2, the latency is still the same, um, sort of. Now we write that the latency is basically the same, but, We can read from both, right? And if we're gonna read from both. We could potentially read from the one that's closer to where we want it to be. So we've got a random disk, right, if you think about it. Two random disks, and they're randomly spun. One of those discs is gonna be slightly closer on average to the data that we want. And if we asked that one, we'd get there faster, right? Likewise when we're writing, because we have to write both. On average, one of them is gonna be further away. So normally we use the assumption that like the, the right, you know, the, the spin distance is the, the, the disk spinning speed, um, on two, cause on average, you know, like we're halfway away from where wherever we want to be. But when you've got two of them, actually the math works out that it's actually the lower of the two. So it's like rolling uh advantage or disadvantage in uh Dungeons and Dragons, similar kind of um. Logic. Is that, did that, did that work? Does anyone actually one person please enter to the drinks. Who here has played Borders Gate 3? 10 my god, what kind of computer scientist, no I'm kidding, um. So, throughput, uh, random read, OK, we've got N times up, we could, we can read from as many as there are drives, we can read very fast, right? So it's pretty good because, you know, we've got twice as many drives or 4 times as many drives. On average, if we have lots and lots of read requests, we can um grab them pretty well. Um, random, right, um. Here, here it has N on 2 and then R + um. Why is that the case? And not 2, well, because we have to write to 2 drives, right? Like as in, so we, you know, like that's, we're not going to, um, gain that much benefit. If we had 8 drives we could only really write, um, 8 times as fast, but we have to write twice as fast, so it ends up being 4 times as fast basically, up for, yeah, random writes. Um, and it is technically a little bit, a little bit faster, um, but not meaningfully. Um, for sequential reads we get N on 2 times the sequential read speed and for sequential write again we get N on 2 times, uh, the sequential write speed, and again we got a little, a little bit fast because it's, it is technically a little bit faster for fun reasons. Um, but we're basically splitting our reeds in both cases, um. But that's fine, where's the next one? OK. Who here has studied parody before? If I say the word parody, does anyone know what that even means? Cool, alright. So I did parody several times in my degree, but I was an engineer rather than a computer scientist, so I didn't do it in any of my computer science subjects, I did it in a whole bunch of other random subjects, um. Mostly I think in communications theory, right, because we use parity when we're sending messages to each other for a similar reason that we've got here. So, Maybe I should just explain what parity is. OK, has, oh, has anyone here heard of a cyclic redundancy check? 123. What about a checksum? Oh, more, OK, right. So here's the logic. The logic is, imagine that I'm sending a message from A to B, right? And I send a whole bunch of 0s and 1s. But I know for a fact that some of those 0s and 1s are going to be wrong, right? Because I'm sending it across a wire and the wire sucks, right? But on average I know that most of them are gonna be right. How could I demonstrate to someone who receives a message that something's gone wrong? Well, one of the ways that we do it is what's called a parody bit. So imagine that you send, I don't know. Let's say, how many bits do I have there? I have 8 bits, and I've sent 8 bits, right? And I send the 8 bits across, right? I'm going to send a 9th bit, right? And my 9th bit is going to be the sum of all the other bits, right? Um, so like, I mean I say sum, it's gonna be submod 2, right, so basically, if there, it adds to an odd number, I will send a 1, and if it adds to an even number, I'll send a 0. Right? So what happens now is that like basically you can see here it goes 01, 00, 1111, and then I add the parody bit, and if I add it all together, um mod 2, it should equal 0, it should add up to an even number, right? So I send a message. If I don't get an even number when I receive the message, I know that there has been a bit that's flipped, because all the bits, all of the messages always add to even numbers, right, it's basically the logic of it. Um, and so if I receive an odd one, I know one of them is wrong, right? And so that's what parody is, right, like basically, and there's very complicated ways of doing parody, you could have it so that you add every bit, you could have it so you add every like, What is it called, you add every second bit or every, you know, pair of bits, right, so you, you know, you add like you do a parity check but it's only gonna consider bit number 01. 0145. Uh, 89, or something like that, so you do them in pairs or you do every odd bit, or you do every even bit or whatever, right? There's lots of different ways that you could do parity bits and, um, things like cyclic redundancy checks and checksums are like more complicated versions of this, right, where you're basically going, oh well, I wanna be able to work out which bit is wrong, um, so I need to have a whole bunch of extra bits on the end. Long story short, what we're gonna do with the Raid 4 strategy is exactly the same thing but across entire hard drives. So the idea is that we've got 44 hard drives here, I'm going to add a 5th hard drive, and I'm gonna say for every bit individually on each of those hard drives, I will add them all together across all 4 hard drives, and then on my parody drive, I will add an extra bit and that bit will be a parody of the other 4, right? And that way I can tell if one of them has failed. So if this one is wrong, right, this hard drive has failed, right? And I know. That that hard drive has failed. I don't know what it was anymore. Can I, can I work out what it is? Right? And the answer is yes, I can work it out what it is, because I know that my parity is meant to add up to an even number, right? And 000 does not add up to 1, right? So I know that X in this case has to be 1, which means that if my parity drive is alive and my non-parody drive is dead, I can actually recreate the data. So what's the advantage here? Well, instead of mirroring, mirroring an entire drive, or in this case I guess mirroring 4 drives, I've kind of mirrored 4 drives using one drive, right? Because I can, regardless of which one fails, I can work out what was on that data because I've got this kind of copy on the parody drive, right? Interestingly, if the parody drive fails, I don't really care, right, because I don't have any data on the parody drive. Ironically though, I could recreate the parody drive, I put in a new drive, and I can recreate the parody drive, um. Not actually that useful, other than the fact that now I can continue to use my raid system. Um, but yeah, so that's how parody works. Uh, and likewise with this one. You can see here, oh let's let's see, let's see if people are paying attention. Is X 0 or 1? Who votes for 0? Who votes for one? That kind of class A Come on, let's try again. 0, who votes for 0? Is it gonna be a 0? I mean, it was on the previous slide. And who votes for 1? Alright, yeah, it's a 0. OK, cool. Um, because 1 + 1 is 2 and 0 + 0 is 0, so if that was 1, it would add up to 3 and that would be bad. Um, OK, so that's rate 4. Let's talk performance. Any guesses? Does anyone want to guess, what's the new capacity? We're going to assume that OneDrive is used for. Parity. So the new capacity is gonna be. In -1 time C, right? Because we lost 1 because of um. Uh, parity drive, right? Uh, the number of disk fails is still gonna be 1, right, so we can have one disk failure. The latency is gonna be the same. Now, throughput for reading, it makes sense, we've got 2, well, more drives, we've got more drives so we can read from lots of drives at a time, that's fine. Um. I'm gonna leave right for the moment because right is a little bit annoying. Um, sequential reads, again, pretty easy, right, we can, um, read from many drives at once. And then the last one is, Sequential rights, and again, nominally if we're, we, we've got a well distributed number of drives, we can, we can write to multiple drives at once, write lots of things, send off lots of requests, we've got, you know, assuming we had 5 discs in total, one is a parody drive, we've got 4 drives, we can write to and read from 4 drives at once. But random write is a question mark. Why? Why would random right be a question mark? Let's have a think about it. First I'm gonna talk about this idea of how do we actually do parody, right? There are two ways of doing parody. There is additive parityity, there is subtractive parity, right? In the additive parity, which is how I explained it, because it's the thing that makes the most sense to any normal person, you add all the numbers together and then you get either 1 or 0, right? In practice though, that sounds like a really bad idea. And the reason is is because imagine I have my parody drive and I want to update one drive, and let's say I've got 16 other drives, right? So I've got 16 other drives, I want to update this one drive, and it has a 1. What do I put in the parody drive? If I'm using additive parity, what I'm gonna do is I'm gonna get drive number 23456 up to 16. I'm gonna read all of them. And then I'm gonna get all of the numbers together and I'll be like, OK. So drive number 1 was a 1, so the parity drive now has to be a 0. And that would require me to read from every other drive, right? That sounds like a bad idea. Like if I want to write 1 bit to one drive, I do not want to read from every other drive. That seems like an insane idea, right? With subtractive parody, what I'm going to do is I'm going to assume that the parody bit is already correct. I'm going to look at the drive that I'm reading from. I'm gonna see what the bit was, and if it changes, then I have to change the parody bit, but if it doesn't change, then I don't have to change the parody bit. Because you know, like if I have a 1, right, and I, originally it was a 1, and I'm going to rewrite over this drive and it's going to change to a 0, it makes sense that the parody bit, if it was a 1, has to go to a 0, or if it's a 0 it would have to go to a 1, right? To account for the fact that I've changed that bit. So now I've got this issue and we can, we can look at the, you know, like the, the description in terms of the order in which these things are occurring are occurring, you see you additive is you'll read all other blocks, so that's really bad. Then compute parity, that's really easy, then you write to the data block, then you write to the parody block. For subtractive, I'm gonna read the old value, I'm gonna find the difference between the old value and the new value, that's really quick. So I've read from the old value, I'm going to write to the data block and I'm gonna write to the parody block. Right? I mean I guess there's a way in which I kind of have to like change the parody block as well, right? I have to read the parody block cause I need to know whether it's a 0 or a 1. Right, as whether to change it or not, right? Because I'm gonna write whatever the opposite of it was, right, so I've gotta do 2 reads and 2 writes for every write. Yeah, and so. When I read, you can see that the latency is actually different, right? And when I read the latency is D, but when I write, I actually have to read and then write. I can't and I can do the two reads simultaneously, like I can read from the parody disc and I can read from the data disk at the same time, and I can write to the parody disc and I can write to the um the data disc at the same time. But I can't read from and write from the disc. Read from and write to the disc at the same time. So a very minimum, when I'm writing, I need to do two things. So my, my latency has actually increased from D to 2D, right? Um. And here we're going to have R on 2, right, so that's gonna, that's the, that's the number that's going to come. Um, as a consequence of all of this, which is, it, you know, like, basically, it's, it's really slow, right, like as in you suddenly I've gone from, you know, like if you look at all the other numbers, I've got like bucket loads of numbers, right? And now I've got really, really, really, really, really, really, really poor performance. Um, So The reason why this was really, really poor performance conceptually is because I'm always, I'm, I'm kind of limited to the parody disc, right? So if you can imagine, whenever I read or write to any of the data blocks, I'm always writing to the parody disc, and so raid 5 is basically designed to overcome this. So raid 5 is the better way of doing it, right, so in raid 5, the idea is that the parody disc or the parody bits or the parody pages or however you wanna do it, are distributed across the different drives, right? So, basically, just because I'm writing to disc 0, doesn't necessarily tell me where the parody disc is going to be for that particular page. Right, so if I'm, I'm reading from page 10, then the parody disc, the parody equivalent block is in disc 2. And so what that means is, if, let's say I was reading from disk 1, from page 1 and page 10 at the same time, I would be reading and writing from disk 0 and disk 1, and for the parody side I'd be, um, Looking at, now I'll get my little mouse out so I can show you, right, cause I think that'll be, where's my laser pointer, laser pointer, laser pointer. Right, so if I was trying to get 1 and 10, or can I, wait, maybe I can do it even better, with a pen. This one And is 10. Right? And what I could do is I'd be like, oh, OK, well the parody one that I'm gonna be looking at is parody 2, and this one is gonna be looking at parody 0. And what that means is I can read and write from 4 different discs at the same time, right? Yeah? So this is really cool because I can do, I can do things fast, right? In the old paradigm, right, if in the old paradigm, where's the old paradigm? I have here. If I was reading and let's say I was reading, uh, writing to this disc and that disc, well I'd be writing to this disc and the parody disc. And I'd be writing to this disc and the, the, the parody disc, and the parody disc would therefore become like a bottleneck. I wouldn't be able to write to the parody disc twice. Easily, because they'd be going to two different sectors. So, yeah, R and 2. that's 4, that race strategy, oh, it actually holds that on, um, let me just see if I can change to not writing. Uh, raise or am I still, ah, OK. Raise all and then. Uh Laser pointer? I don't actually want the laser pointer. Does that stop me from scrolling? It does. OK, sorry, just give me a second. Oh, I can just press escape to get rid of it. OK Cool, and so what I can get here is that like basically the performance can go up because instead of just having, um, Uh, like R on 2, I can have N times N on 4 times R, uh, times R, right, which basically means on average, because I'm writing to different parody drives all the time, and I'm reading from different drives all the time, on average, not all the time. Um, but on average, I can now have an average random write, which is N on 4, which represents basically, I have to read from one drive, and then I have to write to that one drive, right, I read what the old value is, I write what the old, uh, the new value is going to be, and then I read from the parody drive and I write to the parody drive and I can, Read and write both of those at the same time. Um, and so, you know, like I'm going to be doing 4 drives at a time, um, so at any given time 4 drives are going to be active, um, just for, um, what I'm doing, so yeah, I can get a, a much better performance from Raid. Um One other consideration one might want to think about, right, in this paradigm, is because so far we're doing pretty well, right? Mirroring. Now, we go back to our like, you know, uh thing about race conditions and stuff, um. So what could happen is you could be like, the operating system says, I would like to write. And then, then you're like, OK, cool. You would like to write A? Well then I will turn that into two instructions. Instruction number 1 would be, I will write to disk 0. And then instruction number 2 is I'll write to disc 1. And in between writing to disk 0 and writing to disk 1, there is a power failure. Right? Because this is not an atomic action, right? That means that you've got data on one half of your mirror that is not the opposite, like is not the same as the data on the other side, right? And if you go through the logs, you don't really know which it is, right, because you don't know which of these hard drives was written, right, you know when the last writing instruction came through, and you're like, I think I wrote it. And now it says it wrote it, but I don't know whether it's actually written, and I don't know if it's written consistently across both drives. Um, and so this is actually really, really bad. Um. So the way that you would handle this is that often like, it's very similar to one of the ways that we got around it for um deadlock and stuff like that, but what you can do is you can basically say, I am going to write, Some stuff, and then write it. So you like basically log it and go, these are the things I intended to do, right, and then you do it, and then if you get a power failure, you can be like hang on a second, it said, the last thing it said is I was intending to do this thing, right? Um, and you can imagine that like, uh, you can have a situation where you're like, OK, I can at least work out what, what went wrong, right, I can check those parts and be like, oh, I said I was gonna do something, did I actually do it? And then you go to the driver and you're like, oh I don't think I actually did it, and you can compare those sectors of your two mirrors, mirror drives, and you'll be like, yay. Uh, cool. Alright, so I think we'll have a 5 minute break now cause I'm running out of steam until about 502. Um, yeah, there we go. That's it. All right, last thing. Shouldn't take too long. File systems, yeah. Most interesting topic of all time. I think, no, I don't. This one's OK. um. It was fun actually, I had a student, a student come in earlier this week who was asking, you know, like what's the difference between like logical, virtual, and physical, right? And there was a point where I was like, yeah, physical's really obvious cause it's like, like, you know, like in the drive somewhere, there is a bit, and that is the physical address of it, right? Um. Well it took me a while to work out, like I, I hadn't actually really thought about it in, in, in great detail what the difference between logical and, and, and, and virtual is, right? And the, and the way that I was like, oh logical, and I'm like, oh, it's like, it's like, uh, it's like, it's like, and then I was like, oh, hang on a second, the stack and the, the heap don't have any address logic between them, right? Like as in there's no reason that the stack and the heap have any relative location between the two of them. That's not actually logical. They, they, they exist in two different address spaces functionally, from the perspective of the program. Right, and then the virtual's like, oh, when you put them all together, that's the virtual address. You put them in a little block with the stack and the heap pointing at each other. It's very cool. Um. So The only reason I mention that is because we're gonna use the word logical and physical. It was on the, on the um. Physical storage versus logical storage. OK, so physical storage, we've talked about persistence. We had hard drives. We're gonna put stuff on hard drives. We've got pages, we're gonna arrange things in pages, right? Um, but that's not what we're talking about now. Now we're gonna talk about logical, right? So logical, in this case, doesn't even really assume that a hard drive could possibly exist, right? We're, we're, we're back in like computer science land where we're talking about trees, right? Like as in everything's gonna be in the tree, right? Um, so if we think about physical, we've got issues with persistence and stuff, and we've got hard drives and SSDs. Sorry. Um, and then if we're in logical, we, our main things are gonna be like the structure, the format, and we're gonna be talking about files and directories, right, so that's the space that we're gonna be in, OK. Question number one, what is a file? Correct answer, everything is a file, right, like that's the correct answer, right? Everything in Linux is a file, right, in other operating systems this is not true and they suck as a consequence, no, um, but yes, they do, um. But in terms of what we think a file is, right, nominally a file is persistent, right, like as in, as opposed to data, like a variable, right, we kind of accept that the variable will exist and it will cease to exist at some point in time. But when I make a file on my computer, if I go back and it is not there, then I am an angry person, or sad. But usually emotionally roused. Um, persistent, why? It's modifiable, right, so it's not read-only memory, right, so we have to be able to change things about it, that's fine. Um, it's locatable. I just say a file is in a place, right? And that's why we use the word file, I think, is right, because, you know, we're thinking filing cabinet, we've got like a, a file, I, I've opened a file on the, you know, and I put it in a filing cabinet, which is my memory. Um, and I know where in memory, you know, my files are in some kind of structure where I can find all my files. Um, it contains data which is in the form of bytes. File system is a collection of files, right? OK, so what are our choices, right? Like it basically we start with the blank slate, we're gonna start with the blank slate again. Um, we have lots of files, we're gonna assume that we need to have files. I don't think there's another sensible way of organizing data, right, other than to have like chunks of data that we call a file. Um, and a file system is a collection of files, OK, what kind of collection? It's also the management of the collection of files, sort of indirectly, right, like so we think about it, it's not just the structure, it's also like the how do you apply functions to that structure. Um So we start with locatable. For this to be true, It kind of implies that every file needs to have a unique number. Right? One way or another, it has to be unique, right? Because if I said I have two files, and they are not the same file, but they have the same number, at the same address, same place in the universe that which they reside. You wouldn't be able to find them, right? Like it just wouldn't make sense, right, because you'd get one back and you'd be like, oh, that's not the droids I'm looking for, right? I'm looking for these other droids that are also called R2-D2 and C3PO. I don't under I, I wanted these two. I, I don't want, uh, these are not the ones I want, right? So we need to give them like, everything has to have a unique name, right? Um And so, the way that that is resolved in Linux is via an Iode number, right? And there's a little cute quote down here, it's like, what does Iode stand for? And the guy who invented iNodes is like, I don't know, which I found hilarious, he's like, I guess it was index, I don't know. Like, we just started calling them Iodes, it stood for something. Um, but yeah, so if you think about it, every, every file on a, on a computer is going to have an I node, right? And that's just gonna be a unique number that identifies that file. So I'm just gonna have a series of unique numbers, right, I think effectively, right? And then it's a question of, well, how do I find my set of unique numbers, right? How do I map to this set of unique numbers? Where am I gonna store my unique numbers, right? Um, but that's basically it. And if you're in Linux, you can always just do LS dash I if you want to see this list of cool numbers, which. Do I have I, I can, I can do it, I can prove it. Where's my, where's my WSL WSL? I installed WSL. It's, it's, it's, it's very good. It's better than my previous virtual machine. I like it. Other than it takes a while, yeah, OK, do you do the thing? Yeah, no, go. LS dash I. It has one directory with a number of thoughts, that was very underwhelming, CDOSS. OK, CD assignment one. LS. That's better. OK, so if I do LS dash I. Alright, and I'll do LS dash I. Well, You can see here that every single one of them has an I node associated with it. Nice, with random numbers. OK, cool, and it's literally random numbers. OK, cool. Um And so nominally, right, what that allows me to do is I, I can say, you know, like my I node is now at this location of this size, right, so I could just be like, OK, somewhere in hard drive land, right, so physical storage land or however I wanna do it, um, and we've talked about that, you know, like in previous lectures and stuff like that. Um, but I can say that this file is here, because I have a definition of here, and the, the definition of here is going to be defined somewhere else, but I know the thing that has the, I, I, I, I can give it an address, and once I have an address, I can convert that address into a place. Um, and I can do it via, you know, basically base and bounds essentially, but in this case it's location and size, and it works out to be basically the same thing. OK. So On top of that, we have a problem. In that humans do not I note, right? Like if I throw more than about 10 numbers at you, you are going, your brain will just melt and you'll have no idea what I'm talking about, right? So I say, oh, where did you store the file? Well I stored it in 48,921. You'd be like, cool. Right, 48,921. 48,920. How the hell am I gonna remember it, you know, remember that, right? Um, humans like words because, you know, like we're primarily uh linguistic creatures. And as a consequence, the solution was we'll use words, and the words will map to eye notes. So what we're gonna do is gonna create the concept of a directory. Um, and you know, give files names, and, and the idea is that like, instead of just giving something up, like a, a number, each file a number, we're gonna give each file a name and the name is going to conform to a like a structure that we can sort of do something with. Right? And so, the name in the case of this file is, you know, home slash Bernard slash documents slash project slashreport. TXT. Yeah. That's a unique name, right? It's interesting because the name of the file actually includes its directory, right, like as in this is one of the things that's not immediately obvious, right, but it's true, right? Like whenever you have a directory, basically what you're really saying is there's a long string that includes all the directory names that maps to a unique file. This is why you can have two files with the same name in different directories, because they have different names because they're in different paths, which means their directories are different, which means their actual name is actually different. They're uniquely named. Right, um, but that's how it works, right, and I'm, I'm sure everyone is familiar with clicking on folders and finding things or getting confused about where things are. Um. What's that? Right? Like as in there, there is a, there is a, for this to work, it kind of implies that there must be a top, right, which we call root. And it's usually I node 2 in the Iode structure. Um So with our new file, you can imagine here now, uh I know number 2, we could have something, you know, read me, text, 3, hello, 0, whatever, right, like so it, it can be like um a whole bunch of random stuff here, right? Um. In our, you know, it's just a special kind of file, right? Sorry, this is for a directory, right? So you could have a directory that contains a file called ReB.X, right? And it's of size 3, I guess, and then one called hello, right, you can have lots of files, right, so you could have a directory which is just a file that contains the names of other files, right? Um, and that's what a directory is. Yeah? Um, and on Linux, you guys haven't done systems programming, so I can't actually determine whether you've done this before. If you type LS LA. So L means long, that's where you get like the long list, right? I always used to think it stood for list, but it actually stands for long. Um, and then A means all. So when you do LS dash A, it gives you like all this extra information like the owner and groups and stuff like that, the size of the file, the dates of the file, the name of the file, but also the um access, uh, access modifiers, so the read, write, execute. And also the first character will tell you if it's a directory because it has a D, right? Um, now you see where I say me and my parent? You'll notice that there's a dot and a dot dot. Does everyone here know what dot and dot dot are? Right, like, like. Please, well, that's a, that's a mean question to ask. If you've done systems programming, that would have been one of your exam questions pretty much. Um. Dot is here. And is my parent, right? So.dot is immediately obvious how that's useful because you're like, I would like to change directory to dot dot, i.e. I would like to go up one directory. Um, dot is less obviously useful, right? But it's actually incredibly useful because basically that's where you specify or you tell the shell, I want something from here, right? So you can be like dot slash, and if you do dot slash that means something that is in my current directory, right, so if you do, that's why when you run something you always have to do like, Uh, dot slash Xi, right? Um, and that will run Xi. So in this case, even and minihell are both executables, if I wanted to write even I'd do dot slash even, because I'm basically saying here, and then as a directory, the file even, run it as an executable. Um, and then. Yeah, I think I've covered everything here, cool. But that's it, right, like as in basically that's all files, there we go, file system's done, right, we have directories which contain other files and then we've got files which have I node numbers, and you've got a name, turns into an I node, and then we know where the I nodes are stored. Someone knows where the I nodes are stored. Um, Here's a fun question What is the answer to the question? Does anyone have an answer to the question? What does a .txt file contain? Yes.

SPEAKER 1
Wrong.

SPEAKER 0
From Good, that's the answer. It contains bits. There is no guarantee anywhere in the universe that a .TXT file actually contains text. By convention, it does. Right? This is just like one of those little extra things I like to throw in, just to make sure everyone knows this. The extension on a file does not mean anything. It means nothing. It literally means nothing. It is something the, the operating system sees, and it's like, oh, this person, when they open the file, they probably think it's an integer. Right, it's, it's similar to that kind of logic, right, you label something as an, you know, read this as a float, and it'll be like, OK, I'll read this as a game, or I'll read this as a Microsoft Word document by default rather than a text file. Um, there are text files that are called dot TXT that when you open them, they're in binary because someone hates you. Or they're encoded differently to the standard encoding of your operating system, in which case they come up across as garbble. Um, but yeah, it doesn't actually contain anything. Extensions are just a convenience, like a, it's an. You could imagine that the extension was actually at the start of the name if you wanted, or you could have a, so it wasn't an extension, or you could imagine that like, Actually I don't know why they didn't do it that way, that feels like it would have been like made my life a lot easier if the extension was at the start rather than at the end of the file, in a way, right? Because then, then when you sort it, it would sort by type, by default. Um, When we're reading and writing from files, we have 22 locations. We have a start location, we have an offset. So once we've opened a file in um Linux, um, we, we have a start and an offset. So we start here, like that's where in the file, the file nominally starts. But for every file there is an offset that is maintained, right? And that offset will tell you whether you're like reading or like reading or writing from the start or the end of the file. So you can imagine that when you do like read character, it increments the offset. So the next time you read, you write, read character, it reads the next character and it reads the next character and it reads the next character. Um, and, and similarly for writing, you, you know, you can have ones where if you append, what it will do is it will update the offset until it runs out of file and until it gets the end of file character and then that's where the offset will be when you start writing. Alternatively, if you're overwriting your file, the offset will be at the start. Um Yes, Here's a fun, fun little thing. So, when you write to a file, we've all discussed this, right? We've discussed this in previous lectures, um, operating systems and hardware lies to you, right? Because it's like a lot of the time, like we said with, you know, hard drives and stuff like that, uh, a good, a good hard drive will be like, it'll say, oh yes, I have a, I have my own RAM. I'll copy your request into my RAM before writing it to the disk. And then I'll wait for some more write requests, and then I'll write things into the disc whenever I feel like it. Um, there is a thing that you can do called F-sync, which is where you actually like force everything to push through and actually get written. So when you call right, um, often the writing doesn't actually occur because it gets stuck in a buffer within the storage device. Um, but if you use F-sync, you can actually force it to push all the way through. It's just a fun thing, um. Cool, uh, file permissions. Hopefully everyone here's gotten past chemod in OOP, right? Like everyone. Jamud, who here has heard of Jamud? OK, cool, alright, that's, that's, that, that makes me less sad, um. Basically you have the owner, the group, and other, you have read, write, and execute. If it's a dash, it means you can't do it. So there are files that you can read but can't write. There are files that you can read, write and execute, but no one else can. There are files that you can give other people the permission to read or permission to write to, which is very unusual. But often you can have ones that you can read but can't write or execute, and often you'll have ones that you can't read or write, but you can execute. Um, and you can see that here in the first. Character one through. 9, I guess, 1 through 9, because character 0 is the type. Um There are also what's called like access control lists which aren't default to Linux but I think are in EXT4, um, but basically where you can, and these are things that were in like Windows originally, still I think, um, where you instead of having like users, groups and, Global, for your read, write, execute, you can also have like specific lists that you can maintain that where you give, you know, you map an individual user to an individual file and give them specific permissions. Um, it's not a great way of doing things in general, like it's better to be part of, you know, for things to be more consistent, it's, it's much smaller amount of data that you have to maintain and less likely to have problems, um, but there are access control lists. Um, directories we talked about, um. They, depending on the operating system, they're they're very well slightly different, they basically do the same thing, it is essentially a list of files regardless of the operating system, but they do change, um. Yeah, so like this is one of the things that's kind of fun, is that like because directory names are actually stored, there are systems, and I have worked on systems where like we've had file names that were too long, right? So you have directories and directories and directories and directories, and then someone tries to save the file and then it doesn't work because you've, you've asked for more than 256 characters in the file name. Um, so always be really, really careful of having too many directories, like having a lot of directories often makes a lot of sense, but if you're too deep in the, the hierarchy, then sometimes, um, yeah, you won't actually be able to do anything. This is less of a problem now I think because people have realized that limiting file name lengths is pretty dumb, so they're pretty long now, um, but I have definitely run into situations where I couldn't save data because the file name was too long, and it took me ages to work out why. Um, Yeah, no, and, and this is one of the things that I think is really interesting. You know, like in, in, in Windows, if you ever want to watch Windows really struggle, what you do is you create an individual directory and create millions of files in it. You put millions of files in one directory, and then Windows will be like, ah I don't know what to do with this shit. Right, like it'll like it basically, it will chug, and it kind of makes sense because it's trying to load from some gigantic list all the time, it's constantly refreshing this gigantic list of um files, so that kind of loses its brain um when you have lots of files within one directory. But if you think about it, like part of the reason that might could be, and this is the, the situation which would, which would be really, really bad, is if the directory, you know, like the directory which is stored, you know, like it's a file, so it must be on disk somewhere. If the directory is so large and contains so many files that it takes up. More than one page, and those pages are in different parts of the disk, right, in different parts of RAM. You can imagine how that would suddenly turn things into a bit of a nightmare in terms of trying to open and close directories, right? Cause you're doing lots and lots of reads of different pages on different sectors and different drives to try and just see one directory. Um, but in general it's done as lists, but in databases it's often done as a bee tree, and that's partly to avoid this problem so that you can actually have a directory where like basically you aren't just loading one gigantic list, you're loading essentially the first node in a tree, and it's similar to the same kind of logic we use for multi, multi-tiered page tables and page directories when we were doing paging. Um, you just don't want to have too much stuff in the, the, the, the first pointer basically, and if you have a list, you've got one gigantic set of pointers that you have to deal with. Um, we also have the idea of a link, which is sort of a, a fun Linux thing, right? So in, in Linux, you can actually create multiple files that are the same file, right? So if I create a link, I can create a hard link, so I can link old path, new path, and now I have two places, 22 files that point to the same file, um. The disadvantage of a hard link is it can only work within one file system, so you can't have it on separate drives or anything like that, um. And yeah, so I have two pointers to the same file, right, and you can create it using link and you can remove it using RM, um, but one of the things that's kind of interesting about it is, oh wait, is that symbolic links, hardli? Did I not have the, oh, OK, maybe I didn't. Um, you can also do symbolic links, right, and these are like more generic things, they're like soft links, it creates like a little mini file called a path file, right, and that can have anything written in it. And as a consequence of having anything written in it, it can point at anything, and basically um you can just like, Ask for the soft link and it will give you the, the, the my file, but the advantage here, um, compared to the hard link is that softlinks are way more versatile because you can kind of soft link to anything because the soft link is just going, I'm gonna write something random in a file, and anything can be written in a file. So it could, it doesn't even, I don't think it even needs to be a file, you can have like a software, a soft link to a piece of hardware, for example, where you wouldn't be able to do that with a um, a hard link. Um, but just so that you get your own idea of what what, what's going on. What we actually mean when we have them is. If you can imagine, and this is the, the, I don't know, the minimal pair that I sort of put together, is if I put, let's say I, I echo the word hello into, into file one, right? And then I link file one and file two, so that's a hard link, and I cat file two, it's got the word hello in it, right? And if I then delete file one and cat file 2, file 2 is still there. This is the one, this is, this is the thing where it's like a little bit confusing. You know, I'm like, so I created a file and I created another copy of the file and then I deleted the first file. Um, and then the second file didn't delete, right? So when you do a hard link, Basically, it's like you've got two file structures that point at the same data, and the data doesn't disappear because it still has something pointing at it, right? Yes. I No, no, that's intentional. That's intentional, right? Like, as in, no, no, you're, yes, yes, yeah, no, no, no, no, exactly, right, like, like that, that, that, it, it's, it, it is intentional because basically if you do it in the soft link case and you try and cat file two, the file's gone. Right? So, and this is, this is the difference, right, like as in that this is, this is the bit where it gets a little bit weird, right, like so we can sort of. We're using the word hard and soft, and the question is, you know, um, if we go back to like object-oriented programming and we think about like deep copies and shallow copies, which of these is this? Well, it's neither, it's not a deep copy because it's not making a separate bit of data. But the way that it kind of behaves resembles the, the kind of expectation you would have with shallow and deep copy. So in, If you make it a hard link, that second file kind of keeps the file alive. But if you make a soft link and you delete it and you cast delete a soft link, what happens is it goes, oh, it's just a soft link is just a representation of the original file, right, so it's like you're just saying delete file one, when, when you delete a soft link. Whereas in a hard link, you've got two files that are the same data, which then you're like, I'm just gonna get rid of one of the pointers, so you remove, in the first case it's like removing the pointer, in the second case it's actually like removing the file. Which is weird. Um, file manipulation, oh yeah. Really boring things, we have like rename, yeah, find names. Are they legal? check permissions, check the old and new iNotes, lock both directories, unlink the old. Oh my god, there's actually a lot involved here, right? Like, when you just rename a file, right, like if we think about it, then this is where we're getting into like the nitty gritty of file systems, right, you know, like. We have to, you know, find our file, we need to check the permissions of the files in case we're not allowed to do it. We need to check the old and new I nodes to see if they're actually there. We need to lock both directories, we need to unlink the new, the old new, we had to add the new entry and then remove the old entry. So there's like a lot of stuff that goes on when you're, you know, like now that we've got I nodes and we've got files and we've got file names, there's a lot of stuff that we kind of have to do it very atomically in order to avoid disasters. Right, so there's gotta be a lot of like, uh, There's gonna be some uh what are they called, mutexes and stuff in here to make sure that you know like we're not, you know, like, cos you can imagine when you rename a file. You know, you're essentially going, oh OK, um, I, I wanna, I wanna change some Iody stuff over the top, I wanna change the names of things. You need to make sure that everything's nice and locked, right? Um, um, you, we need to worry about the directory as well, right, cos the directory's gonna have the name of the file in it, right? So we need to lock the directory and we need to lock the file, and then we're like, OK, so file, you're now called this and this file's gonna go to this location, and then the directory, we need to lock that so we can be like the thing that you previously thought was the name of a file that's inside you is now the name of a different file. Done. Right, um, so yeah, even really simple things like renaming is um non-trivial. Um, One of the things that's kind of fun is that when you call remove file, right, in um in, so when you delete a file in, in Linux, and, and apparently for a very long time, this wasn't actually that dangerous, right, so when you deleted a file it would be like, it's not there anymore. But because of the way that data works, it would still be there, right, like it would still be in the hard drive. All you've done is you've just gone, I don't have a pointer, it's just deleting the pointer. So it's like a memory leak almost, right? Um, except it's fine because unlike a memory leak, um, what ends up happening is the I node gets freed, right? Um, but basically we're saying that file doesn't exist because it doesn't have an Iode, that Iode is now free. Now, in, in the old days this was fine because what would happen is that you could be like, you could go back and you'd be like, oh, OK, where's the actual data, and you could go into the hard drive and try and find the data. But remember what I said about SSDs where they're constantly trying to find bits of data to like essentially like blank pages and shift data around and all this kind of stuff. It means that it's actually a bit dangerous now to just unlink something because stuff can disappear quite quickly. And, Linux, for example, is very vociferous in reusing its old iNotes. Um, we have file descriptors, which we've covered in systems programming, but um. Yeah. The idea of a file descriptor is basically, imagine that you want to open a file, right? And you want to just keep a track of where it is, right? So instead of going, oh, I know where it is, OK, let me just ask hardware, get the file, write one character, OK, done. Oh wait, I'm gonna have to read another file with another character. Alright, so where's that file? File system, I'm looking for a file called this. That I note, oh that I note points to another I note, oh that I note, OK, cool. Hard drive. Where is this? Oh, it's there, OK, wait, no, which page? OK, page table 1, OK, page table 2, page, OK, there it is. Right? Instead of doing all of that, a file descriptor is basically going, I wanna, I wanna remember where all that um the file is so I don't have to find it again. Um. So processors have a list of file descriptors. The three that you would know by standard are standard in, standard out, and standard error, but those are just like the terminals kind of like a file cause everything in Linux is a file. So in this case what we're gonna do is we're going to maintain a list like standard in and standard out for files when we open them. Um. And each process has its unique set of file descriptors, and we're gonna store it in a file table somewhere, somewhere. Um, but basically it's gonna look like this, right, so you've got your file descriptors for your process, your process has 0 for standard in, 1 for standard out, 2 for standard error, and when you open a file, it's gonna be number 3. But broadly what they're gonna do is they're gonna point at a file table, and that file table is then gonna point at some I nodes, um, and it's gonna keep track of the mode if you've got read or write access or whatever it happens to be, and it's gonna end up looking like a structure like this. Um, but the process never has direct access to the data itself, like it's basically gonna go through the file table, that's how it thinks about things. Um. Yeah, standard in, standard error, standard out, and the next one goes here, so when you open a file it's always gonna be number 3, usually. Um, that's what it looks like in code. I don't know. File descriptor, open the path, flag, mode. Um, you're reading into and out of buffers, or reading into buffers and writing out of buffers. Um, and then you have to close it. Uh You can actually look at this um using Strace, so if you call Strace, right, like um you can actually see, you know, like uh reading and writing and stuff like that, like what's actually going on. I'm reading from 3. Right, so this, this is obviously opening a file, so when I call cat quick test, I'm opening cat. So the CAT program, whose standard in and standard out and standard error is 01, 2 and 01 and 2, but when it opens the file quick test to start printing out what's in it, it's actually reading from 3, right, to write that stuff out, and then it's writing it out to standard out, which is 1. Yeah, so now basically as a summary we've got, you know, the 3 standard names for every file, it's got its Iode, it's got its file name, and it's got its file descriptor. Right, these are the 3 ways that we can talk about files, um. Yeah, that's about it, uh. Just a quick revision on how it actually works, um, this is just about forking for those of you who haven't done systems programming. If you can imagine I've got a process and now I'm gonna clone that process using fork, or like, you know, um, which was in assignment one, basically every child process has the same set of file descriptors and they are pointing at the same file table entries, right, which are then pointing at the same, um, I node links. Um, what this means is that like, uh, like for example when you clone a, uh, a process. The parent and the child will both write to the same standard out which if it is the terminal, they'll both write to the terminal. It's essentially what's going on. um. Those of you who didn't do systems programming, this is how iodes actually work in practice, right, so basically an Iode is gonna have a bunch of attributes that are like the, you know, stuff about the iode. Um, but then it's gonna have pointers to blocks of memory, right? Um, and it can point directly to memory blocks, which in this case I guess I have as 9 bit memory blocks, 512 bytes, I don't know why, um. Maybe it could be pages, who knows, it doesn't matter. Um, but the other option is that like basically instead of having it point directly to a memory block, you can have it point to an indirect block, which is basically another I node, right, so it's an I node pointing at an I node, pointing at memory, memory blocks, right? So you can get this big tree structure, and the reason that you do this is so that you can have really, really big files. Because if you can imagine if an I node is like, if you, it's got like a finite size, right? There's only, you know, it's a list with a finite size which means that it can only point at a finite number of blocks, but if it can point at an I node and that I node can point at a number of blocks, then you can square and then cube the amount of memory that you can point at, obviously this results in a higher latency. Um, Yeah, so each I node maintains the is pointing list. Oh yeah, this is fun. Um, so basically, um, if you're ever wondering, you know, like how do you recycle I nodes, every I node in the system knows how many people care about it at any given point in time, right? So it's got an is pointing at me list, which is the STN link, right, so that's one of the attributes. And when that reaches zero, because it's been unlinked from everyone, right, that means lots of people have deleted it or closed it, right? Um, because you can imagine that you can either have it like the, the operating system can be staring at the file, and therefore, you know, it's in the directory structure somewhere, it's in, you know, your home directory, there's a file and your operating system knows it's there. But you can also have a process which has opened that file, and then you can have it so the operating system deletes that file, so it removes that file, so the operating system doesn't know that file exists, but the process still does. So the I node needs to know that the file descriptor for the process is still pointing at it, even if the file directory system does not. Um, so yeah, that's what STN Link is for, um. And yeah, you can have multiple file systems, you know, like you've got this one, this one, this one, this one, this one, this one, this one, right, like raid. Hard disks, USBs, um. So in Linux, unlike in Windows, you have this concept of mounting, which in the old days was really annoying because you, you used to have to, like if you got a CD drive, and you pushed the CD into the CD drive, you would actually have to explicitly mount the CD back in the day, right, you'd be like, hey, I've got a CD can you pretend it's part of the file system? And then by mounting it, Um, you could look inside the CD. Um, nowadays, obviously the operating systems have made that convenient for users, so that you, you put a CD in most, most operating systems actually bother to, or like the user interface basically does all that for you by default, so it mounts it. But that's all mounting means, right? So you're basically saying this other file system, it put it in a location in my file system, attach it to my tree. So you know, the USB would be the blue files and the yellow would be your operating system files. Mm. Alright, how much time do we got left? 20 minutes. How many slides do I got left? Oh, I got a few. Trying to work out whether I should take a break because I'm running out of running out of voice, um. All right. How? Last part, this part is a little bit more interesting than. The other part, well, I, I find this stuff a bit more interesting. OK, so I want to design a file system, how would I do it? OK We've done this before, sort of indirectly or something very, very similar in the sense that like, you know, like we have translation look aside buffers and page directories and page tables frame. I thought we'd already worked out how persistent storage works, right, um. Memory and storage aren't exactly the same thing, um. So we're gonna have to think about how we're gonna do this, um. All right, so One of the things that we're gonna do that's gonna be the same um is we're just gonna use 4 kilobytes in the same way that we did for pages, we call them frames. We're still gonna have fragmentation as an issue, right? Um. The things that are going to be annoying for us when we're dealing with memory is going to be mostly about speed and fragmentation, those are the two big things that um we're going to have to worry about. Um, and so we've got a whole bunch of different ways that we could do it, right? So once we get into how we can do it, I think it will become easier to explain what we're actually trying to do. I think, right? So let's have a, let's have a look at how we could do it. Imagine, imagine that we have all this data and we've got all of these files and we have a hard drive and we want to store it, Logically in some kind of, I don't know, space, right? Yeah, in our disc, right, and we're trying to allocate stuff in our disc, right? One option is that we could just contiguously, Map each of the files, right, to the disk, right, so we've got A all next to itself, we've got B next to itself, and we've got C next to itself. Pretty sure everyone knows what's wrong here? What's wrong here, someone. Friday afternoon, I'm falling asleep as well. Yes. Fragmentation, yeah, alright, very, very good, it's just fragmentation, right, like now I've got these weird gaps, maybe I don't have enough space to put A even though I've got 5 spaces I can't put A in anymore. Alright, so. Continueous continuous allocation, it's really good for reading and writing, um, there's no metadata overhead, which is good, um. It's not very good for files because we can't make them bigger easily, um, we get a lot of external fragmentation and it's kind of annoying to try and find space for a file. OK, we've done this before. Then we had extent, right, and extent is basically like contiguous, but now we're gonna say we can have little like groups of it, right, so. So we can say file A has one group, but file B is gonna be two blocks here and two blocks there. So this is getting closer to paging, right, you know, like similar to paging, with with paging we're doing something similar. Um. For extent, yeah, it's good for reading and writing. It's worse than contiguous, right, because like we're gonna have to like, you know, look in multiple places, whatever, right, um, and we're dealing with hard drives, right, we're dealing with hard drives, they're slow, it's really annoying, yeah, um. There's not much metadata overhead because, you know, like we've, we've got these different extents. Um, the, the files can grow because we could give them extra spaces, you know, we could give them extra, you know, like give it an extra extent, right, these, these little blocks, um. But we, we're gonna get external fragmentation, which is not great. It's better than contiguous, and finding space for a file is also gonna be a bit of a pain, right? Um, the next one is like the worst one I've ever seen in my entire life is the linked list, right? OK, so imagine we've got a hard drive and we wanna save some data to our hard drive, right? Um, in terms of actual memory, like how we're gonna put them in, in the, the frames, the sectors in the hard drive. Well, what we could do is at the start of every frame. We could put the pointer to the next frame, right? So we, you know, like, and so if I want to get like the 3rd B, I get, get the first B and I'm like, hey, 1st B, where's 2nd B? Alright, hey, 2nd B, where's 3rd B? Hey 3rd B, oh good, that's the data I actually want. Um, this is obviously really, really bad, right? Because if you can imagine, this is a hard drive, it's slow. Every time we ask it for a new bit of data, it's going to take forever, right? And so this is going to take forever times however far through the file we want. So if we're like, hey, file consisting of 900 frames, could I have the 899th frame? I am going to request 899 separate reads from this hard drive. So that's gonna be awful. Awful, awful, awful, awful, awful. Right? Um. And this is a picture describing how awful it would awful, awful, awful, awful be. On the bright side, right? Um, the files can grow arbitrarily, right, like, as in this is real, you know, linked lists are really cool in the sense that it's very easy to just, you know, plug and play different sections, um. It doesn't really have external fragmentation, um, sequential reading and writing is not too bad, right? Because you know, like, I'm basically get this one, then get the next one, then get the next one, then get the next one. That's about as good or as bad as it was going to be before. Um, but random reading and writing is really, really, really bad. Um, and there's a small, like each page is slightly smaller, right? So this is like the first real one. It's called um file allocation table. Has anyone ever heard of FAT32? NTFS? OK, so like it's not completely. So basically the idea here is that what you do instead, And this is, this is one that was used by Windows for a long time, is you have basically a, a block at the start and the block contains the lookup table. Right, so this is kind of similar to the page directory or the page table, and it tells you where all the blocks are, right? So you're like, oh OK, block 0 is in block 15, right, you know what I mean, like as in like, and so you could basically have, it's like you could have the linked list, but in advance, right? Um. And it's all in one place, right, so instead of actually having to call each individual block to find out where the next link was, what you do is you pull out the list of links and you just traverse the links within one page, then work out where you want to go and call for the second block. Right, so this is actually not too bad. You know, like, again, it has a small data overhead. Um, it's really dangerous in the sense that there is one small part of memory that if it corrupts, you've lost your entire hard drive because it's like the, the table of contents, the hard drive is stored in one place, um. But the files can grow easily, you don't have a problem with external fragmentation, um, it's OK for sequential reading and writing, it's basically the same. Um, each read-write request therefore requires two read-write requests, right, because basically you have to talk to the, the original table, like the directory, and then you find the location where it's actually at. It's very similar to paging, right? We have the same problem with paging, right, when we're doing paging, we're basically doing the same thing, you go to page directory, then you go to the multi-level page table, then you go to the final level of the page table. You can do something very, very similar, um, with that. Um, so it's pretty much analogous to paging except just here for reading from hard drives. Um, but it's much, much better than a standard linked list, right, because you don't have to, you know, get 1500 pages, you only have to get 2, which is pretty good. And the overhead is OK, but except it can be corrupted if it's all in one place. Um, then we have indexed allocation, and indexed allocation is really beginning to look like paging, right, because it's basically saying for every file, you just make a block. And in that block it's got the directory for the rest of the block, so each file has its own table of contents as a, as its first um block, right? And then, so you you have an index block and inside that is basic, so it's basically just a page table, um, and inside that it tells you where all the other um blocks are for that particular file. Um, and again, it's got a very big metadata overhead comparatively because basically for lots of really small files, you've got basically one big direct, you've got a table of contents for a file with one thing in it, right? Um, so it can be pretty bad, um. But you can optimize it so that like some of it's stored, some of the file data is actually stored in that first block. Um, and again it solves the problem of fragmentation. It's good for both sequential reading and writing and random reading and writing and, Yeah, um Yeah, the, the other problem with it is, is this one, it's similar to paging, right, like, remember when we were talking about paging, right? In the page table, a page table can have a finite number of entries, because it has a finite number of entries, it kind of defines how big things can be, and we have that same problem here. So if, if your entire block tells you where all the other file parts of the block are, it kind of implies how big a block can be. Right, like a set, like a file can only be a certain number of blocks because I need to work out how many of those blocks I can reference from one other block, right? Um, and so you can imagine that eventually you might want to create like multi-level block things like multi-level page tables, similar come up, similar kind of idea, um, and that's what a multi-leveled indexed allocation is, which is basically, I know it's give or take. Um, and they're great, and we've covered them a bit, but big files can be really slow, but I don't know how else you would solve that. Uh. Yeah, and then, and then you have like multi-level indexed extents, right, which is like, I'll do all the things, right? So, so the idea here is that like essentially what you can do is instead of just marking like blocks, you can mark extents, right? Where an extent is a series of blocks in a row, right, and you can see how that would be a little bit more convenient for sequential writing, because if you know that like all of the blocks are together and you, you're, you, you sort of leave the option open for saying that everything's in big chunks that are multiple pages big. Um, then you end up with a situation where you can read from it slightly faster, um. Which is cool, it's sort of like a in between. Thing, um do do do do, and yeah, performance is as you would expect it, like, um. It's, it, you, external fragmentation's not too bad, sequential reading and writing, this is where it's the best, right, because like with an extent, obviously we're probably gonna, because of locality, read a whole bunch of stuff that's all in the same location. Trying to group them together so that they're in like cohesive blocks rather than or cohesive extents rather than individual blocks scattered throughout memory is going to be an improvement. Alright. That's what's in an I node, I'm not gonna go through it. Uh. Am I gonna go through it? No, I'm not gonna go through it. It's, it's pretty obvious all of this stuff. Uh, we need to block file system. Oh yeah, alright, so within our this is where we get into quite a bit of detail. Alright, so within our Iode system, right? Basically, if you can imagine you've got an I node and it's gonna point at all the blocks that it's associated with, that's fine. Um, we're also gonna need some like, I don't know, like housekeeping stuff at the start of the hard drive, right? Um, so stuff to do with the file system. Uh, we're gonna have a block bitmap and an Iode bitmap, and an Iode table, right, and data blocks. What are they? So, if you can imagine, right, in a hard drive, we're gonna have like a lot of space, and they're all gonna have labels, right, all the addresses, and I need to keep track of which ones I've used. So that would be what I'm using my block bitmap for. Bit Bitmap for. For Iodes, I nodes are like nodes. Where we have a finite number of nodes, we have a big tree that represents all of our files and sort of file directories and how they point at each other and how everything points at everything else, right? I have a finite number of them, I can only have a certain number of nodes in my tree, so I need to have a, which nodes am I using, so when someone asks for, uh, makes a new file, and I have to give them an Iode, which one to give them. Right, so that's my Iode bitmap. Um, I have my Iode table which is the mapping from my files to my I nodes so that I know that this file corresponds to that particular I node. Um, and then I have my data, right, and so this is how we would distribute it across a hard drive essentially, right? Um, a lot of this stuff is gonna be at the start, just sort of like, it's almost like the operating system version of a hard drive where we've got all the basic stuff in order to make the whole thing work, like these bitmaps, the maps of what's free and what's not free. Um, Some of the basic stuff it's gonna have in there is gonna be like, you know, how big are my blocks, how many do I have? Where is all the basic stuff, where is my um, Bitmap of all the free blocks, where is my list of all the free I notes, right? Um, and then we're gonna have those lists and those blocks, um. Alright, so, so, last thing, last thing, let's do an example. What's this gonna look like, right? So, I'm going to create a file called F bar, right? So let's go through the laborious process of what the operating system would actually do. We're gonna start with the root I node, and we're gonna read from it to find out what is in it, right? We are then going to read the data associated. With the root I node, because we're like gonna be like, where is the root I note? OK, what's in the root I node? OK, there are some directory stuff in the root I note. OK, which directory are we going to look for? Oh, it's, it's in food, right, so I need to find food. Yeah, so I'm gonna read from food now, right, the food I note, right? And then I'm going to correspondingly read the food data, right, to find out what's in the food I note, right? Um, and then I'm like, OK, OK, I've got the food I the food data, I've read the food data, what do I need to do now? Oh, OK, well I need to. Because we're creating a file, I need to go to the Iode bitmap, right? So I need to work out which I nodes are available, right? And then I'm going to change that list of available I nodes, cos I'm basically reserving one of those I nodes, right? Then I'm going to write the data that I care about, and then I'm going to write a new I node for this file called bar that I, I just created, right, I need to, I need to find that Iode which I've just created, right, like via the Iode bitmaps, I'm reading that one. Right, and then I need to change it with its details of all the things that I want to make in my new file, like when it was accepted and what its name is, and who its parent is, and all those kinds of pieces of information. And then, I'm going to have to update the f I node, so that the foo I node knows that the file that I created now exists and that it's something that it should be pointing at, which means I think I've created. The file f bar, yeah. F slash bar I should say, right? Now we can do the same thing here like um basically once we have, once we get to bar, right, we're gonna try and open it, we'll read the I node, we'll read the route, we'll read the thing, we'll read the, the food dot data, and then we'll read bar.inode, right? Like so we'll be like, oh OK, cool. Um, so that one's pretty, pretty straightforward. Um, assuming that we've, uh, we've got that far, right? Like, so let's imagine that we fast forwarded, and now what we wanna do is we wanna write to it, and we've done the read the route and read through and read bar and gotten all the way down to the data. So now we've got the bar I node, right? So we're gonna assume that we did all of that stuff before, we're about to write to it. What else do we need to do now? OK. We've just Red, the bar I note, right? So we need to look at the data, right? Like as in like we've basically gotta go, oh OK, you know, we're gonna update the actual blocks of the data being used because we were writing something into bar. Bar is a file, right, which means that we're gonna have to read the data bitmap and then write to it to say that actually I want to, I want to store something. In the data associated with bar, so it's actually a file, it contains stuff, right? OK, so what else do I need to do? OK. Well now I'm gonna have to actually write the data to Bar, so I've basically said that Bar is now using data and the data that it's using is somewhere in the hard drive, right, this is where it is, this is the data block that is being reserved on behalf of my iNode, and I'm going to write some data to it, hooray. Um, then I need to update the, the bar I node, right? With these new details of, you know, the file and the file size and update everything so the bar now knows where everything is, yay. Alright, and now if I'm going to close it. I don't have to do anything, yeah. Right, like, cause I just tell the, you know, this is the only one that requires no effort, right? Because like, if I'm, I, if I close the file, right, all I'm gonna do is say operating system, done. That's it. None of the I nodes get updated. When you close a file, nothing actually happens. Um. In terms of, I don't have to look into the hard drive if I'm closing a file, I just need to be like, say I'm done, and that's the end of it. Um, Yeah, there's a lot of things that you can do to make it all faster, right? I think we've talked about a few of these things like prefetching, um, you know, with hard drives with the disk, you just grab the next few sectors off the disk, um, caching, they have little RAMs to store stuff. Journaling, that's what I was describing about I'm going to do something and then I do it just in case, and then I can go back and see what I said I was going to do and if it matches with what I actually did. Um, you have right back caches and right coalescing and all these things that you can read in your own time because we have 4 minutes left. Um, But yeah, like you you can write your operating system to try and put your i notes together more often, you know, like um so they're like. Things that are supposed to be together are closer in the actual hard drive, and yeah, that's about it. I don't know, the rest of it is pretty self-explanatory, you know, like pre-allocation, you reserve contiguous blocks when creating and extending a file. So you basically go, hm, I'm gonna create a file. I'm just gonna use more than I need, and I'll just say this is my file, and if my file ends up using it, hooray, and if it doesn't, eh, I'll give it back if I have to. Um, but that's it. So today's lecture, raid, file systems, iNotes, storage, and we're done. Any questions? Excellent. Everyone have a good break. I know I need one.
