Week 1: Operating Systems Part 1
Introduction
What is an operating system? Before we can meaningfully answer this question, we first need to establish some terminology. For example, what is a process? What is memory? What is file-management? What are devices? What is hardware?

Some of these terms are probably familiar to you. For example, a keyboard and mouse are an example of hardware. You could also call them devices? Your hard-drive is a form of memory as is a USB stick or data you store on the cloud. What is a process? That is a bit more complicated, but broadly when you have program running on a computer, that is a process. So, operating systems sit in between all of these things. Unfortunately, that isn't a very helpful explanation.

Let's consider a computer program where the term operating system isn't very helpful. Consider the old hand-held game of Donkey Kong (Figure 1). What is this device? It is a small computer that has one purpose and one purpose only. To play Donkey Kong. When this device is turned on, its first thought of the day is to think "I should be playing Donkey Kong right now". It uses a microprocessor and limited memory to manage and run a single program. The program is a glorified state machine representing the location of the player and various obstacles within the game. It contains interfaces to the hardware including the input (buttons) and output (LCD screens; Note: these old game machines didn't even have pixels).

image.png
Figure 1: Donkey Kong (Wikimedia Commons)

Pressing buttons updates the state machine of the game, and the screen displays some representation of that state. Simple enough. Harder question. Does it have an operating system?

The short answer is not really. Why so vague? We are in 'well actually' territory (a hill I am not willing to die on). However, for our purposes, we will say... no. It doesn't. So why not? Let's consider what the architecture of this device actually entails (Figure 2).

image.png
Figure 2: Simplified and inaccurate abstraction of Donkey Kong.

In essence, the problem with Donkey Kong is that it only really does one thing. Moreover, that one thing it does has a strong 'end-user' purpose (i.e., it is a game) and there is a very tight coupling between each of the components of the system.

So what about a real operating system?

Week 1: Operating Systems Part 2
Extending Computers
So, if we use Donkey Kong as our quintessential one-stop-shop computer, what is the next step? Well, we could have a more sophisticated game console, one which has more than one in-built game. Obviously, we'll need a better display than the LCD screen of Donkey Kong (it has fixed images that are illuminated or not). We probably don't need new buttons though. So we have two architectural choices here.

#1: We basically put all of the built in games into one big 'meta-game'. This meta-game (or menu) allows us to pick between each game (Figure 1).

#2: We start to abstract things. As all the games use the same buttons and same display, we would likely want to abstract each of these parts of code, writing universal driver methods that each game can call when it needs to.

image.png
Figure 1: An abstraction of a multi-game hand-held console.

Generic Computers
So what happens if you want to have something a bit more flexible? For example, you want to have a computer which has a variety of inputs (it can have two different keyboards) and a variety of outputs (it can have two different monitors). Now this architectural structure becomes problematic. Each bit of software needs to be compatible with each bit of hardware. Each time the user wants to update their hardware, each piece of software needs to be updated to account for it. There are now thousands of kinds of monitors, thousands of applications, thousands of printers etc. This cross-compatibility problem scales badly (Figure 2). Why should Solitaire need to know the intricate details of every mouse that has ever been manufactured?

image.png
Figure 2: Software-hardware driver relationships...

A program that runs programs
The operating system is a kind of program/process which sits in between... everything (Figure 3). It gets its name from the old-school telephone operators (real people) who connected phone lines together manually (Figure 4). Now, operating systems are actually more complicated than this, but not at the abstract level. Pretty much everything can be boiled down to 'a bit of software running on a bit of hardware'. Software is processes. Hardware is things like memory, devices, processors etc.

image.png
Figure 3: Operating System Architecture Abstraction

image.png
Figure 4: Switchboard Operator

So is that all? Yes... basically. Course over. Job done (<= to be read with heavy sarcasm).

Week 1: Processes
What is a process?
A program that is running right? We have already answered this (in a somewhat uninformative way). Let's reword the question to get a more satisfying answer. What is a process 'made of'. Well, as it is a program that is running, we definitely need to know where in the program we are. To a certain extent, we also need pretty immediate access to the program, which presumably needs to be stored somewhere for the process to know what the next instruction is. In addition to that, we need the things that processes usually need, like access to variables and constants (i.e., memory of some kind), some way of representing complex data structures (i.e., the heap), some way of keeping track of functions calling functions (i.e., the stack) and maybe a few other tidbits about the process (like... how long it has been running?).

So what is a process? In most operating systems it is a block of reserved memory (i.e., address space) where there is program code, constants, the stack and heap. It also has a process ID of some kind, some extra 'metadata' properties etc. The problem here now is that processes necessarily become more complicated as our understanding of computer systems becomes more complicated. What about if memory is divided to include RAM or registers? So, the process needs to keep track of what it has stored in registers too.

Two Processes, One Machine
So let's begin by motivating the goal of multi-process machines. Originally, programs were run in batches. Think of them not as interactive tools but rather as big calculation blocks. A program was mostly taking some data input, processing it in some way and determining an answer. If you had multiple things to do, you could put them all on one big queue and process the jobs one by one. But what if you wrote code that interacted with the outside world in some way. Now you have a problem. The outside world is slow. You have a program which needs to measure some external value, but that external value takes time to respond/calculate/measure. Now your program needs to wait, while all the expensive CPU space is sitting idle (Figure 1).

image.png
Figure 1: When program 1 is waiting for an external device, program 2 is wondering why it can't use the CPU.

So, in the above example, we would very much like to have program 2 running in the space (Figure 2). Of course, this only makes sense if:

Running program 2 doesn't interfere with program 1.
Switching between program 2 and program 1 is cheap.
If these two things are true, then there is a good argument to allow these jobs to get chopped up into little pieces and run whenever there is spare time on the CPU (Figure 2). So now we need to work out how to achieve this goal practically. While in theory it seems simple, in practice it is quite challenging. So, firstly we will need to deal with the idea of loading/unloading a program mid-stream. To do this, we will need to pause the actively running process, save a copy of all the relevant details so we can start it up later, then load the second program into the relevant hardware and get it running instead.

image.png
Figure 2: If program 2 can sneak in, even it if is lower priority, it will get finished quicker.

What could go wrong?
So many things. Consider... two processes which both have access to the same memory. Consider... there are two processes, so which one to run first? Consider... the operating system is also a process, where does it run? Consider... loading processes in and out might be faster or slower depending on how you do it. Consider... what should a process know about how the OS works?

Week 1: Direct Execution
Two Processes, One Machine
It is fairly easy to conceptualise the CPU operating two processes simultaneously. Mostly, because they don't (there are obviously exceptions to this such as computers with multiple cores). Like humans, when a computer is multi-tasking, it is actually just swapping its attention between tasks. Do a bit of A, do a bit of B, do a bit of A etc. So, for the CPU, this isn't really a scary proposition. Where things become far more problematic is for other resources, specifically memory.

Direct Execution
So, simple idea #1. What if, we just... run the code? We could find the program we want to run, find out where it starts, load in its necessary memory and just run it. Problem solved. This solution does assume a few things, most specifically that the program 'does the right thing'. The operating system itself is a program. What if the code you run overwrites the operating system code. That sounds catastrophic (or hilarious depending on your personality). Moreover, assume we want to do this time-sharing of the CPU, we also need some mechanism to halt the process in its tracks so we can unload it and load something else in instead.

Assignment 1 Description
Objectives
Refresh/practice some basic C programming
Familiarise yourself with the Unix system call mechanism
Learn about processes and signals
Get you thinking about parallel processes, as well as what the unix shell really does.
 

Tasks
Task 1: Signals (30%)
Write a C program called even.c that takes the input parameter n from the command line and prints the first “n” even numbers (zero is even). We want the program to run slowly, so that it executes long enough to receive a signal.  To achieve this, you should place a sleep(5) after every print statement.  Compile and run to test it works ok.

Most Unix systems will understand SIGHUP and SIGINT.  Every signal has a default action associated with it, for example the default action for SIGINT is to terminate the process. 

You should modify your even number program to handle the signals as follows:

When it receives a HUP signal, it should print "Ouch!" and continue.
When it receives a INT signal, it should print "Yeah!" and continue.
Task 2: Shell Upgrades (70%)
Read, study and completely understand the minishell.c Download minishell.ccode provided for this assignment. 

Modify that minishell to do the following:

put commands ended by an “&”  into background mode and report when they have finish. 
properly interpret the shell cd command (i.e., change directory correctly)
include an appropriate perror statement after each and every system call.
fix the minishell so that if the exec system call fails, the child process is correctly terminated.
The minishell should follow the POSIX API, thus you may develop you code on a Linux machine. We will provide some simple test for testing 

Submission

You need to submit your code into Gradescope by Sunday 24th August. 

Your code should be well-commented, including notes as to changes and corrections made, and why.