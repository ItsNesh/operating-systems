SPEAKER 0
Capture has not begun. Come on, you can do it. There we go. All right, we can start. Excellent, it's started recording. Hi everyone and welcome to Operating Systems 2025. Um, hopefully we're gonna have a lot of fun this semester. Uh, operating systems is an interesting subject, I suppose, like, I, I find it interesting, um. Or at least I have thus far in the the the short time that I've learnt about it. Um, alright, so today we're gonna be covering, um, mostly like bookkeeping stuff, so you know, like, uh, housekeeping, you know, like what is this course about, you know, like what are you going to actually be doing from day to day when you're studying this course, um, all of that kind of logistical things. Um, we'll go through a little bit about like, like why are you here at all, like, obviously operating system. This is a compulsory 3rd year subject for computer science students and it's a compulsory subject for a Master of Computing innovation students. So like, why is it even in the syllabus? Like why would we subject you to the terror that is operating systems? And then we'll talk a little bit about processes and virtualization. Alright. So housekeeping, let's start with the the basics. Alright, this is a course at university, right, OK. This is me, I'm Bernard, right? I'm, I am friendly, but I'm hidden away. I live in in Gandhiwadli 5.44. This is on level 5 of the IW building. Uh, this means that if you want to come and see me, you need to email me, because if you don't, you'll get to a locked door and the locked door will say, I'm locked, I guess, it's not that advanced, it won't say anything, but you won't be able to get in. So in essence, if you do want to come and see me, please let me know. I'm quite happy to go and see students, but, um, you have to email me in advance or otherwise it's going to be very hard to get into my office. Um, we have 4 workshop supervisors this um semester, Annuav, Jothus, Nthin, and Arjun, um. I would suggest that you try and ask them as many questions as you as you can during your tutorials with them, um, because obviously they're quite knowledgeable on this subject, um. As your first port of call, if you're in the tutorial and they happen to be there and you have a question, ask them, and then then we'll worry about asking me, um. In terms of resources, pretty much everything is gonna be going up my uni, we've got, you know, Echo 360. I do produce lecture notes as well, and there is Piazza, right, so, um, who here has been to the website so far? 123334. All right, who has managed to find the lecture notes for this lecture? Alright, good. OK, so we're so far so good, we're doing fine. Um, has anyone used Piazza yet, cause I, like, oh, excellent, right, like when you say, OK, have people used piazza in the sense that like I have been to the zoo or have they used piazza in the sense that like for operating systems, I went to the operating systems Piazza and it was actually there. OK, it was actually there. OK, good, that's because I don't use Piazza that much. This is like, I think one of the first courses where I'm actually using it, um, and I set it up and I have no idea if it actually worked and whether it's visible to you guys. But if it is visible or if there are any problems, send me an email if you can't actually get to it. Oh right, OK, so that's easy enough, um. Oh, now that, now the dreadful part. OK, so operating systems has as prerequisites, algorithms and data algorithm design and data structures, so that's if you're an undergrad, Programming for IT specialists if you're an IT degree person, Foundations of computer science B if you're like a master's student. Um, and broadly all that means is that you need to know how to code, right, like as in the, in the, you know, the generic sense of being able to code, you can write some simple programmes, um, but it also means that you really kind of need to understand the concept of stacks and cues and trees, right, because I'm just going to assume that you know what a stack a queue in a tree is to have these conversations and I'm not going to tell you how these things work. Um, so if you don't know what those are because you, you passed all the parts of the courses, but that was the part of the course that you just didn't do, I'd suggest that you revise stacks and queues and trees. Um, and generally data structures in general. Um, OK, so we also have assumed knowledge, right, so this course has prerequisites, which means that the people who get here are mostly good, right? Um, we have assumed knowledge of computer systems, which means that I'm also gonna assume that you understand what a logic gate is. You've heard of the word of a register, what a programme counter is, what memory is, um, you know what the stack and the heap are, you understand what the concept of, you know, assembly and compilation is, at least at a high level, um. We also have this assumed knowledge kind of, right, um, because that's a prerequisite, right, so it's a prerequisite that you've done computer systems, I think, right, um, assume knowledge systems programming, who here has done systems programming? Right, so I was the mysterious voice in the extra set of lectures in systems programming, right, so if you did it last year or the year before, um, there would have been some pre-uploaded lectures that would have been me, so maybe I've taught you before. Um, if you have not done systems programming, right, um, I suggest that you revise stuff from systems programming because a lot of it is very relevant here, right, cos in systems programming we talk about things like processors and pipes and file descriptors and system calls and C code. Specifically for assignment one, I have already uploaded a lecture that I'm giving. From systems programming for this course that covers the material that you're supposed to know before you start, right? Um, so you may have to watch one more lecture, uh, in addition to this one which will already be on Echo 360, and if there's any, if anyone has anything from systems programming that they, they, they think should they they don't know that they would like, I'm I'm quite happy to upload those as other lectures as well, um. Alright, so now we get to the course learning outcomes. I, I, I worry about all these things a lot, like, OK, so what are we actually doing in this course, right, so we'll look at the big high level words. The high level words are we're going to explain the role of the operating system in a high level interface to the hardware. Mm, OK, alright, so that broadly translates to understands kind of what an operating system does, right? Um, we're gonna use OS as a resource manager that supports multi-programming, alright, so, OK, so we're gonna have. Be like, OK, so how do, what is an operating system, what does it do? and how does it support us having multiple programmes run at one time? OK, so that's all very good. We're gonna talk about CPU dispatch, right, so the low level implementation of CPU dispatch, um, for those of you who don't know, CPU dispatch is basically where the CPU is going, I wanna run a programme, and it goes, I'm gonna do this thing to run a programme, um, we have a CPU dispatcher, we'll cover that in later lectures, um. We're gonna talk about memory management, low level implementation of memory management, and then, um, performance, trade-offs inherent and OS implementation. So broadly speaking, you know, you can sort of divide this course into three main components, right? One is gonna be like scheduling, right, so we've got lots of tasks, we want to do them all at the same time. Um, uh, we have concurrency which is we're doing them at the same time, oh my God, that's a, that's gonna be a pain, and number 3 is gonna be memory management. So like we have all these tasks at the same time, we have a limited amount of memory, how are we going to, you know, juggle all of these different processes within our memory at the same time? OK, cool, um. Yeah, I mean that's basically me saying the same thing with less words. So if you didn't understand what the previous thing said, that's the less word version of it. OK, uh. What I want to sort of bring home as the take home of this, right, before we actually like, I don't know, you know, delve into lots and lots of details, is that, Instead of approaching this as like a memorization task, because a lot of people when they do things subjects like this, they're like, OK, now I have to memorise what first come, first serve is and, and, and, OK, a translation, look aside buffer or something like that, right? That's the wrong way to approach this subject, right, because if you try and approach it as like a memory task, like memorising digits of pi, except in this case, you know, like it's just arbitrary acronyms and what they mean, um, there's a lot, this course has a lot in it. It's not like a small course, right? I've taught pretty much every other course at the university, I would say, give or take, right? Like cause they throw me at whatever, you know, pops up. Um, this course is intense, right, in a way that the other courses are not. It's why I put this warning in my first, you know, announcement for this course. I, I don't normally put warnings in my announcements for the first thing for a course, right? So I am warning you right now, this course is a little bit different from other courses you may have taken. Right, because there is kind of an expectation that you know most of the stuff that's in the textbook, right, by the end of this course, right, like that's how this course kind of works, like, unlike other courses where you can sort of get by by like having a high level understanding of a few components, right, and it, you know, they're kind of difficult cos you have to try and understand how a stack works or you have to understand how a tree works or you know how to do sorting algorithms and that kind of stuff. In this course, you kind of need to know just lots and lots and lots of random things, right? Um. And so there's two ways that you can approach that. Either you can just be like 3.1415926. You just memorise things, you know, hydrogen, helium, lithium, beryllium, you know, come up with some way of just memorising nonsense, or what you can do is you can go, I want to design an operating system. What does that entail? OK, so if I want to design an operating system, what are the steps that I need to take, what are the trade-offs that I need to make? Like how would I do this myself, right? And if you take that attitude into your reading into your learning for this course, it makes it a lot easier because you sort of naturally have a lot of questions, you're like, OK, well what if I? I was running two processors on a computer at one time and I did want to put them into memory. How could I do that? Wouldn't they be in the same bit of memory? Wouldn't that cause problems, right? And so it becomes a lot easier to sort of like put all of these different ideas of operating systems together if you just take on the persona of the person trying to design an operating system. And this is what I mean by this, there are choices, right, like throughout this course, what we're gonna look at, we're gonna, we're gonna look at, oh well, someone came up with this idea of how to do it, but that was a choice, they decided to do it that way, right, like there were trade-offs that they thought were more important or trade-offs that they thought were less important. Alright, alright, alright, alright. OK, hints. From previous students, this is not from me talking. Previous students went, oh, definitely read all of the textbook, right? I, I had students who did this last year. This was because I was gonna teach it this year. I was like, so what's your biggest suggestion? They just, oh, the textbook's really good, you should just read the whole textbook. Um, that's, that's in it, that's it, that's hard work, right? I am currently in the process of reading the whole textbook, right, like, OK, yeah, alright, I'm about 2/3 of the way through, I think. So I'm ahead, I'm ahead, we're all good, um. But basically, this is actually a really good textbook. Out of the textbooks I have read in my life, it is one that I actually enjoy reading, as opposed to every other textbook where I wanted to kill myself partway through reading the textbook. Um, mostly because basically this, this author takes that kind of frame of reference. They're like, oh well let's imagine that we're building an operating systems. Um, what, you know, what did these people do, what did these people do? So it's, it's very sort of casually written, conversational tone, and it has sort of, it sort of captures the idea of narrative. Whereas one of the things that I tend to notice about people who write computer science textbooks specifically is that they, they think like like computers and and they don't know how to talk to people and then they write a book about how they don't know how to talk to people. Um, and it becomes very, very difficult to read and it's like, OK, page one. Alright, time for a for a for a break. Um, OK, so. Start early, right? This is the only thing I'm gonna say, right, like because of the quantity of information in this course, you should be starting now. Like I know it's week one and everyone's like, oh, it's week one. I don't have to do any work. No, no, no, no, no, week one you should start reading now so that by the time you get to week 12, you're like, oh I only have to read half the textbook now rather rather than, you know, like all of the textbook in the last week of, yeah, alright, um. Oh yeah, read the textbook suggestion from me is read the textbook. Um, have fun. That's the other thing that I would suggest, and ask for help, right? Like this is, this is the fun picture that I, I, I, I, I generated to sort of give an idea of what OS is is like. There's lots of stuff. Alright, alright, alright, alright, OK. Take a deep breath. OK, now assessments, OK, what are we doing? Um, this course is not too complicated in terms of the way that it is presented. Um, there are quizzes, there are tutorials, there are assignments, and there is an exam. You'll notice that the exam is worth 50% of your grade. It is probably also a hurdle. I think it's a hurdle. I should have checked if it's a hurdle. I can check. It's probably a hurdle, go and Google it yourself, right? Um. Lots of people fail the exam, just gonna throw it up right now at the start. Um, OK, so let's talk about quizzes. Quizzes, they're online, there are 4 of them, they're worth 6% in total. You get the best of your 3 results, right? So these are sort of revision, formative assessmenty things. Uh, you'll get a bunch of questions, you'd be like, oh, do I know this material or not? Pretty easy stuff, standard. We have tutorials. They are, there are 5, they start in week 3, so there is no tutorial this week. I'm glad no one went to, hopefully everyone's timetables are now like sufficiently sophisticated that it tells you that you don't have a tutorial and you don't have to ask me. I didn't get, do we have tutorials this week, which is what we used to get, you know, 10 years ago, um. There are 2 parts for every tutorial, right? In order to get your mark for the tutorial, you need to do your preparation, and the preparation will be due before the tutorial, so basically the Sunday night before the week of the tutorial. So if you have a tutorial in week 3, there will be a preparation due at the end of week 2, right? The goal here is to just make it so that you actually bother to do the stuff when you get to the tutorial, and then at the tutorial when they ask you questions, you can be like, oh yeah. I actually remember doing these things rather than, oh, I have a tutorial, oh crap, was I supposed to do preparation? Right, um, so there's a preparation component, so that's like half your grade, and then there is a participation component that is also half your grade. The way that participation works in OS is that basically you will do stuff and then someone will take a photo and then you upload that photo, right? And as long as we're convinced that the photo kind of implies that you actually did something in the tutorial, you'll get your mark, right? So it's a good way for us to do basically take your, Um, attendance, and simultaneously check whether you're actually trying or not, right, um. I don't know. I, I, I've had plenty of tutorials where you sort of just go and like, I attended, yes, Mark. Um, OK, it's week 3579, and 11, um. Alright, uh, we have some assignments. We have assignment one. Assignment one is all about systems calls. This is what I mean by you should have done systems programming, right? If you've done systems programming, this, this assignment is pretty trivial, and if you haven't, it's pretty impossible, right? So, um, what I'm going to suggest is that there is a lecture online that covers the the material that's missing in this particular course for you to do this particular assignment. Um, it's worth 8% of your grade, it's gonna be up on grade scope. There are automatic, um, what do you call it, scripts for marking. Um, it's all about signals, which for people who have done systems programming. Is really easy to understand and if you haven't, you might be able to signal a, like a, like at a train station, yeah, cool, um, and then it's about improving a shell. OK, uh assignment 2 is going to be a group assignment, um, I think you should say the group assignment, it doesn't, well it is a group assignment anyway. Um, basically there's gonna be some scheduling tasks, we're gonna give you some data, your job is to do sort of analysis on them and then write a report, right? Um, so it's a bit of coding, right, to, you know, like actually do the data analysis and then there's a report element of it as well. Um, and it's 15% of your final grade group due in week 8, And then assignment 3 I'll talk about later, cause I just want to make sure that I fully understand what's in assignment 3 before I start telling you nonsense about it. OK. Lecture starts. Alright, so motivation, why are we studying OS? Who knows, I don't know. Someone's paying me to study OS. No, um, learning to learn C, that's the motivation, right, where we're studying OS to learn C. Who here has done C before? Thank heavens! Oh my God, I was worried cause like basically every time I talk to anyone about this course, everyone's like, oh, the students, they really struggle with the C component cause they haven't done C before, and I was like, but isn't there a subject called like programming MATLAB and C, and isn't there systems programming? Alright, if you've done C, that's good. Alright, alright, that simplifies things somewhat. No, it's not about learning, damn it. Alright, OK, is it about learning how to programme? Alright, uh, no, it's not about learning how to programme either. Alright, OK. Understanding how stuff actually happens, memory processes registers concurrency. Yes, alright. That is what we're actually here to do. We're trying to understand how does memory work, how do processors work, how does registers work, how does concurrency work? Basically go, hey, programme that runs all other programmes and I haven't really thought about ever in my life. Like, who here uses Mac? And who here uses Windows? And what is the difference between Mac and Windows? Does anyone actually really really know? From from my perspective, they're almost exactly the same, right, like as in when you look at them, you're like, ah, it's kind of Windows, they've got slightly different shortcuts, but they basically do the same thing, same thing with Linux, right? um. Except they don't, they work entirely differently, right, and operating systems is the subject which will peel that apart. Um, OK, so let's start with some basic definition. What is an operating system? What is an operating? OK, so we're gonna do that thing, you know, you know, you know like when you take a course and it says, I'm gonna take a course in like artificial intelligence, and they're like, now for the history of artificial intelligence. Back in the 19, what's this 1960s, right? We have this concept, well like I said, OK, I'm old enough to just have once spoken to an operator, right? Like as in like when I was very, very young, there was some system where I, I called someone and they're like, there was an actual person on the line and they're like, who do you want to talk to, right? So. Back in the day when you used a telephone, right, you'd call and then a person would pick up and they'd be like, who do you want to talk to? And you'd be like, I want to talk to this person with this number, and they'd be like, OK, just give me a second, and they'd take a physical wire and connect your phone call to someone else's phone call, and then that would connect the like the phone, right, so they did the switching manually, right? And you still had to deal with this if you're doing international calls and stuff like that, right, cos it's kind of complicated. You've got lots of different switchboards and you connect people sort of by connecting wires. OK. So we have a caller and a receiver and we have a switchboard, OK, cool. And the caller's gonna talk to the switchboard and the receiver is gonna talk to the switchboard. Here's a question, why, why did we used to do it this way? Does anyone know? Like, why, why is the switchboard necessary? Yes. Yeah Oh yeah, yeah, yeah, we need a physical, yeah, no, that's a good explanation. So we needed to have some kind of physical connection to get from one to the other. But let's pose the question differently. If we didn't have a switchboard and we wanted to maintain that, we wanted to have a wire between every house, how many wires would we have to have, right? Like you'd have to have a dedicated wire to, you know, like your friend's house and then to the university, and then there would be one from your friend's house to the university. You'd have like one bajillion wires coming out of you, one for every friend that you have, you'd have like one phone line for every friend that you have. I've got different phones for each friend. Um, it'd be very expensive, um. Cool, alright, alright, alright, right, OK, so now that's the switchboard operator, right, so linguistically, we have the switchboard operator and then someone invents a computer, right, and my mum is old enough to have used punch cards, right, so my mum studied um computer science um back in, The 1970s where they had these punch cards, so you can imagine that a computer in the old days is a gigantic box, um, and that the way that you talk to the computer is you have like switches that you switch, but also you feed in these little punch cards, and then what happens is that the computer detects where the holes in the punch cards are, and that represents like instructions like in binary, and then it prints out, it does like a whole bunch of calculations and at the end it prints out another punch card and you get like, This piece of paper that's got holes in it and then you have to work out from the holes what your result of your programme was, right, so this is like old school thinking, this is what a computer used to be, right? Um, so you might be wondering why, why is Bernard trying to explain how computers used to work, um, it's because it kind of informs how computers work now, right? So basically, the computer operator was a person, Who physically got cards and put them into machines and said go, and then got other people's cards and then go, and that's their job, right, they, they operate the machine, so they take your programme and they put it in a sequence. Um, so the logic of it's pretty good, right, um. Where are we, right, like as in, so you know, a computer operator basically if you think about an old computer, if you've got this mysterious black box, um, basically you put in one programme and then you'd run a second programme and then you'd run a third programme, right? So basically each computer could only have one programme and running on it at a time and the operator's job was to basically. Backlog them, right, so you just get jobs and then they'd get another job and then you get another job and they'd sort of like load these things in in like a conveyor belt into your machine and then the results would come out and you, you know, there was a like a glass wall that you'd have to wait behind looking for your baby coming out as if it was um as in the form of a punch card, um. And then one of the things that got kind of annoying is that people invented things like hardware, right? Um, so you can imagine that you've written a programme and now your computer, right, is not just your CPU doing its calculations and stuff, it has to refer to some kind of external bit of hardware, right? And in your first year, I'm guessing in your first year, who, who here has written one of those programmes where you have to put in input, right, where you type something into into the command, right, like everyone, right, surely, right? Um, while you're waiting for the input, the computer's there going, mhm. Mhm. Right, and every other process, if it was in a like a log, you know, like, oh sorry, in a queue behind it, would be waiting for someone to type something into the computer, right? Um, so hardware works the same way, right, so basically what happens is that, you know, like, at some point in time your programme pauses and it's waiting for hardware to do something, so maybe it's like printing something out or maybe it's like collecting data from some kind of sensor or whatever. And nothing is happening, right? And so this is basically what motivates the existence of operating systems in the first place, right, because the human operator feeding in the programmes wasn't good enough, we need to fill in that gap because this computer's goddamn expensive, it's this huge block, um, and we need to have it running all the time. Yeah. And so that is a waste of money, right? And so now we have to invent some way of filling in that gap, so some way of managing which programme runs at which time. Yeah. So we have to get rid of the operator and we'll replace them with the operating system, OK. So in theory, what does an operating system do? It's basically just a smart operator like it's basically replacing a human. Um, So what does a human operator do? OK, OK, so they basically optimise, that's their job, right? The, the, the human operator is trying to get as many programmes run as possible as quickly as possible, right? And when we talk about programmes, what we're really talking about is CPU usage, right? So we want the CPU to be doing as many calculations as it can at any given point in time, right? Um, we're also gotta worry about memory usage. So the thing that we're trying to optimise is CPU usage normally, right, like as in because basically we're just saying, I want to do as many calculations as I physically can in as short a period of time as I can. Right, but in order to facilitate that, I need to have memory, right, I need to have stuff to load from one place to another, I need to hold on to information, um, and generally speaking, I want to use as little memory as possible, right? um. I also want to optimise time so I want to get everything done as quickly as possible, and I also want to make sure that it does it securely and reliable. So, This is one of the things that you know like in in the early days, you sort of trust everyone, right, and then they realise that you can't trust anyone cos everyone is a malicious, horrible person who will destroy your code if you're not careful. Alright, um, so we have a whole bunch of different operating systems. If you want to read about the history of different operating systems, you are more than welcome. Um, I do not find this particularly interesting, um. Basically, like I have programmed on VMS, I have programmed on Unix and I have programmed on iOS and MacOS, and I've programmed on X86 and I've programmed on a whole bunch of different things and from my perspective, the difference between them isn't as interesting as like, Sort of the underlying way that operating systems work, right, so like it's just arbitrary that you know this guy made this one, this guy made that one, this guy made that one, so you can go off and read all of that if you want. Um, I'm not gonna test you on it certainly, right, and I'm certainly not gonna test you on this diagram, but I'm gonna just give you this diagram as an indication of how operating systems have evolved, right? Like so you can imagine that like there's lots of different operating systems and certain operating systems are loosely based on some or strongly based on others and you get this gigantic, I don't know. I programmed on Solaris as well. Um, definitely on Mac. My first computer was a Mac. I've never used Minx, um. And this is basically showing you, you know, the evolution of different operating systems, some of them you probably recognise, you know, Windows 11, um, Windows XP Service Pack 2 was when computers actually became like stable. That was a that was an epoch. So if you were around, what is it? Windows XP, it's like 2003, the, the expectation that that your computer wouldn't just randomly crash actually came into being, right? Like up until that your computer would just randomly crash all the time. Um, it was quite funny. Um, OK. Virtualization, how are we doing for time, right, cause this is a 2 hour lecture. No, we're only half an hour in, you guys should still have some like mental energy left, just take a breath. Alright, so we're gonna talk about um virtualization. Alright, so what are we doing? To make a thing like a thing, but not actually a thing but seem like a thing, right? um. OK. Mm, mm, yeah, alright, we're gonna cover these topics, we can't be bothered reading them out, OK. So, I have a programme, right, this is my programme, it's got code and at some point in time I say use printer, right, like cause I want to print something out, it's programme, it prints something out. I don't know, I don't, I don't know what the program's doing, um. OK, I don't want to have to write this, do I, right, like as in please, OK, OK, when I say use the printer, right? Do I really want to have to specify which printer it is, right, like it's like when, when you go in Word and you like print, you don't have like an option of 9000 printers, you've got a spec you know you can say which printer like where that printer is, but you don't have to say what kind of printer it is. Someone does that work for you, right? Um. In the old days though, When would I like the pizza? Sorry, I'm organising a pizza night on Monday for the, the, or Tuesday, Tuesday, Monday, Monday next week for the software engineers, any software engineers here? Yeah, alright, come get pizza, it's free, um, free advertising, thank you Deany, um. Yeah, anyway, in the old days, if you wanted to use a printer or really any piece of hardware, you would have to specifically specify the piece of hardware that you want to use and you would have to understand the drivers for that piece of hardware. So you would have to understand it like in a detailed level how you actually operate, you know, what are the names of the functions for that piece of hardware, um, which would have been absolutely horrible, right? And so basically the idea here is what we want to do is we want to have like the, you know, the operator person doing with the wires. We wanna have like a a gap between my programme. And the operating system and then let the operating system work out how to use the printer, right? That way I can just be like, hey, I just want to print, and I only need to know how the operating system works, right? And so I only need to write one programme per operating system and hopefully there aren't that many operating systems, right, rather than there being 1 billion printers. Um, and that's basically the idea behind abstraction, right? And so now I've got two programmes and they both say use my printer or use printer and it both goes to the operating system and it both goes to this printer and I could have multiple printers if I wanted to have multiple printers. Um, Alright, so This is just a picture, alright, alright, alright, let's go through the picture, right, we have our memory in our processor and obviously within the hardware, right, so when I say processor I mean CPU, when I say memory I mean like RAM or whatever, right? Um, I might do some caching in between, but I'm gonna be sending some information between, you know, my processor and my memory. Um, I'm gonna have all of these things like page tables and translation look aside buffers which we'll cover in great detail later in the semester. Um, we have IO controllers, we've got all this stuff, right, like so in order for the, um, you know, the computer, even if we don't have printers, right, we have all these weird bits inside the computer, right? Um, how to use the computer, like how to use RAM, right? Like, do I want to have to write and you know, when, like, who here when they wrote Hello World specified which memory address in RAM they were going to be storing their information. No one did, right? Like as in like, could you imagine the like the pain of having to write all of this stuff into a computer where you're like, OK, now I want it to be in, right, uh, which, which register is free? OK, in register 5. It'd be like writing every, everyone did, well, a lot of people here did computer systems, right? Yeah, OK, so it'd be like writing in you know, assembly literally all the time, right, and, and probably a little bit worse. Um, but we also have, you know, storage that we have to worry about, so we've got to try and, you know, abstract away all of this stuff so I never have to think about any of it, and certainly I did not understand any of this and was still able to write programmes, um. And you know, including the monitor, right, like please display to the monitor, right, like I mean who, who here has actually gone, oh actually, right now I need to work out which monitor, which pixel, how to display. Now we don't worry about any of those things, we just say make a window and it makes a window. Um, So when we're talking about the abstraction of hardware, like we have a couple of, you know, sort of equivalent ways of thinking about things, right? So in the real world, you know, we have a processor and we have memory and we have discs and we have networks, and we have machines and stuff like that, right? We don't want to think in those terms unless we're writing an operating system and not everyone wants to write an operating system, I can tell you, right, um. We work in this sort of software abstraction equivalent, right, so I can be like, I know what a thread is and I know how a thread works and I can ask my computer to make me another thread. Um, I don't have to worry about how that works in the processor, so I'm really happy, right? And similarly, you know, like I have my address space that I'm gonna work in, so I know where my addresses are in my software, um, I don't know where they are in the actual hardware, but I don't care if the if the operating system handles all of that nonsense, I can pretend that I've got this nice little unique bit of, you know, memory that I'm operating in. And I don't have to worry about the um you know, the actual hardware, so that's basically what the ROS is doing, it's creating the illusion of all of these things, right, like it's creating the illusion that you've got your own memory space, it's the illusion that you have your own threads. Um, and then basically that's all it's meant to do. OK, so. Oh God, another gigantic one, right, so again we have, you know, our process and our cache and our memory, we have our page table and our translation look aside buffer, right, so it's all the same stuff. We have a compiled programme, OK, cool. And then we have the operating system, right, and basically the operating system is using the instruction set architecture in order to sort of abstract all of these lower level components for us, right? So we never see any of these things, so there's one set of like, essentially it's like a a set of, you know, um, I don't know if it's written in assembly, but something like assembly, where someone has written a programme that goes from operating system to hardware, right, and with all the driver software, right, um, and then we do everything sort of by ourselves on top of that, right? Now you'll notice this word here, execution environment with restricted rights provided by OS. Alright, so we're gonna cover this shortly, but basically the idea is like, OK, so I have my compiled programme and I want to run it on this operating system, so I need to sort of run it in an environment where things are safe, yeah. So you know, like I'm gonna, you know, basically use these, these are my interfaces. I'm gonna think about sockets and files and address spaces and threads, right? And this is going to be like my purchase into the operating system, right? These are the things that the operating I understand and the operating system understands, and the operating system is going to translate them into hardware instructions. And yeah, um, a lot of what we do is via system libraries as well, right, like, so that's another way that you can do it. So if I want to talk to the hardware, I can use a, you know, a system library to basically go I'll call the system call within the library, so like, um, You know, uh, who here has done systems programming? Alright, who here remembers doing like um calling system or ExecVP or any of those? Those are all like, yeah, cool. So those are all, um, what do you call it, uh, system library calls, right? Like so within C you can call something that directly acts on the Linux operating system, right? And then the Linux operating system understands what you're asking it to do. It's not like you're asking it to like run a process for you or something like that. You just, you just get get given the runner process function, you're like, OK, I'll just call that function and then something will happen. Right, um, but you're not actually interfering with the memory and you're not thinking about processes or cat or any of that kind of stuff, it's all automated, all abstracted away from you. OK. Funny cartoon, yeah, um. So the idea is that the programmes only see the interface, right? And you're, you, all you have to do is you, you call the, you know, the calls. It's like calling a library, you're just like, I will just, you know, if I type, um, you know, collection.or, right, like you would in, I don't know, ADDS or something like that, you don't actually need to know how sort works, you just need to know that sort does the sorting, right? And it's a similar kind of idea. There are some system commands that I can call in my operating system and it will work out how to do it with the hardware, and I don't think about it myself. Um, yes, sausages. OK, cool. It's also visual, OK. So this is the key part or the key key takeaway here, right? So, in order to achieve virtualization. The main goal is to basically convince every process that it exists in its own private universe with essentially an infinite amount of memory and CPU and like it has no idea what's actually going on, right? So you're basically putting it in a little box and going, this is your box, do whatever you want, knock yourself out, right? And the process is doing all of its stuff and it has no idea how many other processes are working on this on the um computer at that time, like it's, it's completely um abstracted away, so every process thinks it is by itself, it's the only process running on a computer, right, and that is like the assumption of virtualization, right? So if you take anything away from this lecture, that is the sort of the starting point, you've got to try and trick every process into thinking it, it's in its own computer, um. So why is this good? OK, yeah, you can reuse code, unifies the interface for many devices, allows high level functionality. um, but on the right side, which is basically the topic of this entire course, like why is it hard, right, you know, like, um, what is the best kind of abstraction? There are many choices of abstraction, you know, like. Do we want to, you know, like, is it, is it like C when you're programming in C, like give them all the power, or you're like programming in one of the other languages where they're like, no, no, no, don't let them do that, that would be crazy, right? Um. You've got to ask the question is, you know, like, do I want my programme to be safe, or do I want it to be like, do I want to have as many functions as I possibly can, or do I want to make it really, really easy to use, right? Um, how much hardware control do you want people to have, right, like that's another design decision. Do I want people to actually be able to give specific commands to the printer, or do I just want to have like generic things that they can do with the printer, um. And how much does the hardware determine the abstraction? OK, OK, OK, OK. Alright, we might take a 5 minute break cause I think we're getting to mental, mental, well, certainly I, I need to take a 5 minute, I'm gonna eat something. So, um, everyone can have a 5 minute I'll pause the recording and then we'll continue in 5 minutes. What's it for, it's for protection, protection from who? Is it Germans? Right, I'm German, so I can get away with making ridiculous comments like that, um, alright, so. In little groups, here's the question, here's the question, let's uh we'll do the first class activity, the first class activity, right? So you are using a 1960s OS operating system, right? So, so basically someone has decided that they're going to allow multi multiple processors, right, on this computer, right, so it can run two processes at once, it's an amazing machine. And you are one of the people who's been allowed to use the machine and you hate all your colleagues, all of them, right? So the question is, how, wait, is that, oh yeah, it is there, how would you be an evil person? So in groups of like 2 or 3, just have a quick chat and see if you can come up with like a list of like, I'm trying to, you know, I'm running a programme, in what ways could I potentially you know, smash all the other processes running on this computer at the same time? OK, and I'm just gonna, I'm gonna pause the recording again, and then wander around. Deafening everyone from feedback, see if we can get some audience to give us some suggestions of evil things that you could do. To break it, like, I'm assuming some of you guys study cyber right? OK, so I got I've got at least one here you go. All right.

SPEAKER 1
I don't know if you can, uh, do this in 1960s OSS, but could you do some recursive process calling to just hog all the resources? Yes, very good.

SPEAKER 0
Like, OK, so that's, that's a, that's a beautiful one. You, you basically go, I'm going to, I'm gonna write a recursive programme, and I'm going to take all the memory and the OS is not going to know what to do about me, right? And eventually the, the computer's just gonna crash, right? Like that's a, that's a good example. Do we have any others?

SPEAKER 2
Yes. Accessing random parts of the RAM to interfere with other programmes that might be using said RAM?

SPEAKER 0
Yes, OK, so this is a big one, right, like, so basically what you're gonna do is you're gonna say, oh, you've given me this address space, hey, well I'm just going to add to a pointer and just go over here into this other programme and be like, I'm gonna change some values into threes, right? Um, and so like that's, that's pretty much the big one here, right, and we'll we'll cover it, you know, like how do we avoid that, um. But a lot of it is that kind of thing, um, we have another one for which which is stack smashing, which where you basically, you know, make your stack so big that it starts running into other people's programmes, um, but that's basically the general idea, right? Let me turn this off. Alright, before I destroy everyone. Oh, it's USB neat. All right. So, What do we need protection from? Alright, so this is, this is the thing that the OS is going to do. I have two programmes. I have programme number 1, and programmer number 1 says, I want to use the printer. And then programme number 2 says, I also want to use the printer, and then the printer prints out a half bird half horse, and you're like, ah, this is not what I wanted, right? Because programme wanted wanted a bird, programme 2 wanted a horse. This is a much better bird horse than you would get out of a printer if you had two competing programmes, um, but nonetheless, I just love this picture, I include it in every course that I can look at.ine, this is like the, the dream, it's the dream, the bird has the dream, it's so grand. OK, so. What do we need to do? Like we have process one it has threads and address spaces and files and sockets and stuff, um, and then we have process two and it's got threads and address spaces and files and sockets and stuff, right? We need to isolate process one from process 2, right? If process one wants to live in its own private universe where it has all the computer that it thinks it can use, um, we need to somehow convince it that not to use the parts of the programme or the parts of the hardware that the other process is using, right? um. It also needs is isolation from the OS, which is one thing that no one actually mentioned, right, like, um, and this is probably the biggest concern, right? So yeah, you can break the other programmes if you want, but you could also destroy the operating system and just take control of the computer, right, um, because the operating system is just another programme, it has to be loaded in memory somewhere, right? It's running instructions, it's in, it's in memory. I can, I can break it. OK, so. Let's talk about what a pro progressce actually is, you know, it's a thread of control, whatever that means. I, I, I love it when you read a definition and it just replaces one word with another word. It's a thread of control. I'm like, OK, I still don't really understand. Um, it's not a programme, right, so a programme is a list of instructions. The process is kind of like in the middle of that, right, like you're like, I'm a process, I'm, I'm, I'm meant to be reading this instruction now and doing whatever it tells me to do. That's what the process is. But it does include, you know, registers, a programme counter, a stack pointer, OK, so. If you can imagine now we, now we're thinking about like how programmes programmes work, programmes are lines of machine code. So a process needs to know which line of machine code it is up to, right? If I have multiple processes, it has to be I'm up to line 75, right, like it has to have that in its brain somewhere. It it needs to have a stack pointer, so you know for from memory we've got, you know, in programmes we have the stack, right, so we have, you know, you call main and then main calls another function, it puts another block of code on top of that, and then it puts another block of memory and stuff on top of that, um. So I need to know where the stack is, right, like where in the stack I am. um, it needs an address space, so it's like where can I actually like save memory to. It needs to know which files it has open, right, like as in if I've opened a whole bunch of files, I need to know which ones I've opened, and the last thing it needs is open communication channels which I guess that's like sockets and stuff, um. Alright, so Where is the programme? Right, OK, so I'm, I'm an OS and I'm like I'm gonna run a new process. I'm gonna get a new process. There's a programme. That programme has to be somewhere, right? It's got to be in memory somewhere. I stored it on the hard drive and then I loaded it from the hard drive into RAM and now I've got that programme and it's loaded into RAM in its own little space and I'm, I've got to remember, OK, so where in that programme am I up to? OK, so I've got a programme counter and I've got a stack counter where in the stack it's up to cause all the programmes loaded into into memory. OK, cool. Um, so I'm copying it into memory. Yeah, that's fine. Um, so we're gonna load code into memory. OK, so yeah, that, that seems reasonable, that seems like a reasonable thing that we can do. We transfer the static data of the code into the memory. OK, cool. And then we overwrite what's already there, right? Like we were like, I'm gonna write it into memory. I'm like, oh, OK, so now I need to think about which which bit of memory I'm gonna write it into, right, because if I don't think about which bit of memory I'm gonna write my new programme into. Um, I'm gonna write over an old bit of programme. OK, so that's cool, that's cool, but there's something that I have to think about. Um, fixing pointers. Ah, OK, so what do I mean when I have to fix pointers? Well, all right. When I write my programme, my programme is gonna be like, OK, um, what is the first address in my address space, like where where where would be the first place that I would look, right? Now, the programme doesn't know where it lives, right? It just knows the first bit of memory, right? It goes, OK, I have memory address 0 and I'm going to, you know, I'm going to store X in memory address 4 and I'm gonna store Y in memory address 8. When you're writing a programme, you don't go, OK, in X is equal to 3 at address FF F C C A X or something like, A X, that's not X, A4, right? I don't, I don't write that in my code, right? Like you write a C programme, you're like I want this bit of memory. No, you're just like, I just want in C and even the compiler, right, of the programme, it doesn't know where in memory it's gonna be eventually, right? It shouldn't, that would be ridiculous because then if someone else is already using that memory, you're like, oh I can't use my programme today because someone else is using. You know, memory FF FFF AA C4 or something like that, right? Um, I can't use that anymore, right, so, My programme is going to have to think that I'm starting at address zero, right? Um, but so we're gonna have to fix all the pointers because in reality I'm not going to be there, I'm gonna be somewhere else, right? Like I'm not, I'm, I'm gonna say I want to store X at 4 and then Y at 8, right, but actually it's gonna be in some ridiculous place, so there's gotta be some process that's doing that jump across, right, so, um, and that's gonna be done by the operating system. So I have to fix my pointers. Um, I need to choose how I'm gonna lay out my stack, right, so I need to work out like how is that going to look, how are we gonna put all the memory that I've got into the actual memory, um, and then I have to worry about loading libraries are there other things that I'm loading when I'm loading my programme as well, um. So This is programming people, what is the difference between a process and a thread, we should all know this, right? Yeah, at the, at the low level for us, you know, like. Two threads in the same process can access the same memory. That's basically the only difference. I think I have a picture of that somewhere. Shared memory space, it's basically all the same except shared memory space. So, you know, if you have two processors, they each have one thread and they each have one address space, right? So they each like in their own private universe using the same, their own private little bit of memory. When you have a thread, you have one process that has 2 threads and they have one address space. The advantage of that is it allows the two threads to talk to the same bits of memory at the same time, and you can do fancy things with it, it makes your programme really bad sometimes, right, like it can be really, really bad, but it is useful for speeding up your programme. OK. So. So far so good, we got this idea that we need to, we need to keep all of our processes separate and it means we're gonna have to do some translation stuff and we're gonna have to do a few bits and bobs of other things, um, but now we've got a sort of more fundamental question, right, which is this, right? I have a programme and I want it to do stuff. Which bit of code am I gonna run? I'm gonna run a bit of code that I wrote, or am I gonna run a bit of code that someone who wrote a driver for a bit of hardware wrote, right? So we have this idea of direct execution, right, so the operating system, if you, if you can imagine, has a set of like essentially, sorry, I've got to try and avoid going too far over that way because it changes the sound, um, has a set of cheat codes, right, where it's got its own functions that are all really, really efficient, right, because it's basically got direct access to the hardware, right, like it's like, oh hey I know where the hardware is excellent, this is my hardware, right? I know the magical functions that will make it operate, you know, optimally, right? Um. And then we have the process and the process is like I live in my own little box that the operating system put me in, but I would like to have access to the hardware. I would like to have it, right? And so now we've got this situation where you're like, well, OK, what if you don't have access to the hardware, it's like really I have to do all the calculations myself and it would take forever, right? And it's like, OK, but I, I would like to have access to the hardware and then the operating system's like, hm, OK, I will give you access to the. Right, like, basically, um, the evil programmer will be like, ah, I have access to the hardware now. I can take over the entire world, right? Um, so we need to have a situation where we can be like, OK, OK, how do we, how do we, how do we give you access to the hardware without you going nuts and trying to destroy this computer, right? Because we want to have both of those things, right? So we have this idea of direct execution, right? Um, they're very efficient, very cleverly built, 3, the last time you need. Yeah, OK, I've got the point. OK, cool. So, We have bad programme one, destroy the OS and every other programme, right, and we have good programme, right, like, so we need to have this kind of protection going on, yeah. Um, bad programme can kill good programmes, it can also kill the OS, yeah, when we've been through that, right? Bad programmes can also just kill themselves, right? Like as in they can be like, hey, hey, I am in infinite loop. Yeah, right, and it'd be like, I'm going to take all the resources forever and ever, right? Um, so what we wanna do is we want to have this idea of limited direct execution, right? And so we're going to establish this idea of two modes, one is user mode and one is kernel mode, right? So in user mode programmes, are doing things that programmes are allowed to do within the space that they exist in, um, and they can't do that much, right, they can't make hardware calls, for example, they can't use the underlying good, fast programme um functions of the kernel, right? But in kernel mode, you're allowed to do whatever you want, right? So we're gonna assume that the person who wrote the operating system is not a complete insane person, right, cos we're gonna be like, oh well, we, we, we check these OS people to make sure that they're not insane people, right, it's OK that they use the hardware. So now we just need to have a way of going hey user, how do I via this mechanism of user mode and kernel mode, how do I access things that the kernel does in a safe way, right? And your kernel mode can have multiple levels of privilege, like you can change in a bunch of different ways, but basically, What we're gonna try and do is we're gonna do via what system calls or what are called traps is we're basically gonna say, oh, so the OS is gonna start up, I'm gonna start its user process, and the user process is going to make a system call, right, so it's gonna call a special function in the system, right, and the special function in the system is sometimes called trap is going to change the mode from user mode to kernel mode, and now we're in kernel mode and the operating system's going. You made a very, very specific request from me and I am willing to go along with it, and I shall use the hardware on your behalf, right? Um and then once we're out of that, we'll execute whatever the system call is and then we'll return from the trap and we'll go from kernel mode back into user mode and we'll be like, now you may go and do whatever you want to do, right? And this is the way that we get around it. So basically, uh, a good analogy for it is like, uh, it's it's it's like, uh, what, what is a good analogy for it? I should have had a good analogy baked in with a picture, but I did not. Alright, let's think. It's sort of like, you know, you know, sometimes when you go to a library and you're like, I would like to, you go to the librarian and there's like the restricted section of the of the library, and they're like, we don't want you in the restricted section, but you can go to the librarian and be like, could you please get me this piece of information or photocopy something out of the restricted. And then the librarian will be like, oh yes, I, I can, and then they'll, you know, they'll go off and look through all their nonsense stuff, they'll find the book, they'll photocopy the one page that you asked for, and then they'll come back and give you a photocopy, right? And that's essentially what the user kernel mode is like, right? I don't have access to the restricted section, but I can request information out of it, right? And the advantage there is, Or at least if you think about it, by having it this way, when I go to the librarian I'd be like, hey, could I have the 999,999 page of this book, right, because I'm thinking of the librarians stupid and they're like, oh, the millionth page of this book, I'll just start counting pages 1230, this book is over. I guess I'll have to look in the next book to get to the millionth page. Oh, I guess I'll have to look into the next book to get the millionth page. What they can do is they'll be like, hang on a second. Hang on a second, this book's only got 200 pages. You complete nutcased. You're trying to get into some other book you're not supposed to get into. And that's basically what's gonna happen here, right, but we're going to have these special system calls where we can start imposing rules on what the inputs to these system calls are, right? So, um. Basically what you do is you request a system service, it behaves regular like a function call like from an abstraction point of view, like transparency wise. It basically looks like just calling a function. So if you didn't know this was going on, like when you started studying systems programming in the first place and you were like, oh it's just like a function, you just call like execP or you just call fork or something like that, and it's just like a function, and then I have no idea what happens, but it just looks like a function, right? Um. And It does not have the address of the system function to call. OK, so now we need to think, what's that mean? OK, if you can imagine, the OS is code in memory, so it's going to be somewhere in the memory. There's going to be the you know the magical functions that call like, I don't know the hardware access. It's gonna be like a book in the restricted section of the library, right? Um, I don't know where in the library it is, right? It's kind of important that I don't know where in the library it is. All I know is like some kind of reference to it, and you know, I just want this book. Yeah. Um, and so basically what we're gonna do is we're gonna give it, you know, a system call and they're gonna be some arguments, and the arguments are gonna allow me to, you know, basically, you know, go into the library, but only the librarian knows what the arguments actually mean. OK. So, I can't remember why this is in here. OK, um, so. Feels like a break in the flow, um, but essentially this is just about interrupts, right, like so we have, Oh yeah, OK, so we have different kinds of kernel mode transfers, that's why, right? OK, so in some cases what's happening is basically when you're doing the transfer from user mode to to kernel mode, sometimes that's gonna be, you know, initiated by the process, right, and then sometimes it's gonna be initiated somewhere else like an IO device or something like that, right, that's gonna be like, hey, no, no, no, uh, a really, a really simple example, who here has programmed a sake fault? Everyone has programmed a se fault. What does that actually mean? OK, so a se fault is where you're like, I want this bit of memory. And the operating system's like, really, you want that bit of memory? You're not allowed to have that bit of memory, that's outside of the scope of your memory, die, right? Like that's basically what a fault is, right? And that's why se faults, when you programme them, they're so like uninformative because it's just like, it's just that the operating system said you you tried to do something and say die, right? Um, and so that's an example of like a triggered, you know, interrupt kind of, um, uh, what do you call it, uh, kernel mode transfer because basically at that point in time it's going. Uh, no, no, no, no, no, no, no, we're going, you're trying to do do regular instructions, you try to access something out of the normal. I'm going to go into kernel mode so I can be like, hey, I have all the power that process must die, right, um, so it can be triggered by a variety of different ways. Um, and yeah, sometimes you have the hardware that goes and um triggers the programme instead. Um, oh yeah, we also have this difference between like an interrupt and an exception, so an interrupt is like where you're expecting something to kind of happen from like an IO device, so you're like, I don't know, I want to talk to like the printer and then the printer's gonna send me information and then the operating system's gonna be like, all the information's come, I'm going to trap, I'm gonna interrupt the process and now I'm gonna tell the process that the IRS happened, exceptions is more like a um, Seal or or divide by 0, right, like you, you go, I want to divide by 0, and the, the process is like ha ha, alright, you want to divide by die, right, um, and that's how it sort of um functions. Um, so there's interrupts and exceptions you might hear the two used kind of interchangeably, um, but technically an exception is when something, Wasn't meant to happen and an interrupt is often when something was supposed to happen but you were waiting for something. Um, OK, so this is how it's gonna work, right? So this is how our system call is going to work, right? I have my processP and this is the little bit of memory that I am in, right? And within this little bit of memory, I want to get to sys read, whatever the hell that does. I don't care what it does, but I just want to be able to call siss read. So how am I gonna do it? Well, I'm gonna use it using cis call, and I'm like, well how do I get to cis call, that doesn't make any sense, right? OK, so the way it works it's gonna be like this sort of bunny hop way, right, so basically what's gonna happen is I'm gonna go, I'm gonna make a system call, so I'm gonna make a call to the library. Right, I don't have access to where System Call is, but the operating system is going to elevate itself into kernel mode to be like, oh, I know what System call is, and System call knows where cisread is, right, and then it will go and find ys Read within the operating system, right? So often the way that the CISO will work is we'll be giving it an offset, like you know the example I told you, please get page 258 of this book, right? If you can imagine that you've got this book of all these functions, so you can be like, uh, can I have the, I, I know that page 228 has the instruction for, um, I don't know, uh, my map or something like that, right? Can I please have my map, um. Um, and then basically what will happen is you'll go into the CISO, you'll give it the offset, it'll be like, oh, so you want the map, hey? OK, cool, then I'll do them a map with the information that you gave me and then I will do that thing and then I'll return the result of that because I think you're not an evil programme, it's fine, and then we'll go back into the the regular process, right? So this is where all the useful functions live, this is the offset, and then we can access Ciscal via wrapper, right, so we have a CIO wrapper that we we're allowed to use. So the wrapper then calls Cisco, CISol knows where the actual function is, so I never know where CIsread is unless I'm really well versed in how operating systems. Work and I'm like trying to remember where they're all stored in, you know, cos if you can imagine if you have an operating system, someone programmed it, so that information is available, so perhaps you could work it out, but from the perspective of the programme there's no obvious way of getting to the location of these system level, low level functions. Um, and that's how we're going to do it, right? And in this process, if you can imagine, in order for this to work, this is where we need to do the the escalation. So at this point in time we're going to call CISCO with the wrapper, so whatever a wrapper function is that we imported from the C library, right? And then the system is gonna be like escalate, now I am kernel mode. I'm gonna use CISCO in kernel mode. I'm gonna make some checks to make sure they're not looking for the millionth page. The book, um, and then basically from there I can work out where in memory the function that they're actually trying to call is, and then I'll use the offset to work out where it is in the actual stored part of memory and then I'll call that, it will do whatever it's supposed to do and then I'll back out of that again at the end and give control back to the user rather than kernel mode, which means that they can't do anything nefarious, but the programme can still run. Um, Um, from the perspective of Unix, this is just sort of a summary of how this all works, right? So you can see here that we've got like this system call interface to the kernel, so you've got your standard applications at the top and user mode with your standard libraries. We use the system call and then it allows you to do a whole variety of things, and then the kernel has its own interface to the hardware where it's talking to each of these individual bits of components. And you know, the people who build these hardware components will have written drivers for the operating systems so the operating system understands how to use them. Um, this is so much easier than it used to be back in the day. I remember we, you know, like when I was little, you had to install drivers for things and then you'd be like, I install the driver and the driver doesn't work, you'd be like, why is there not a driver for this device on this computer, it's so annoying. Um, there are other ways that you can do it, so if you've done. Uh, web database, you might be familiar with Docker, um, you can do it with virtual machines where you create like these fake virtual machines that are sort of like machines, and then you've got this hypervisor and then you've got the infrastructure, so there's a bunch of different ways of doing it, but we're mostly gonna be dealing with this style of operating system. Um, just as a little bit of revision, um, for those of you who have forgotten, um, basically for the individual process, the way that we're gonna store the data, we're gonna have the data, so this is global data, we should have code next, hopefully, yes, we have code, and at the bottom we will have a stack and usually you have the heap under the code growing towards the stack, right? And we'll look at how that works. This is just for revision just to remind people what's going on, but every time you get given memory by an operating system, this is broadly what it will look like, um. We have the programme counter for the code, so where are we up to in the code, and we have the stack pointer for the stack. Where are we up to in the stack? OK, so why am I covering this? Because, OK, so we need to know where the programme counter is, so we know like if I'm running like factorial, and we're doing factorial 5, factorial 4 factorial 3, vectorial 2 because they're all calling each other because it's a recursive function, um, we need to know the programme counter, but we also need to know the stack pointer to know which factorial we're up to. Um, OK, so. This is where we start getting into the nebulous detail of operating system. OK, so we've decided as registers we need a programme counter and a stack pointer. What else do we need, right? And some old people decided that we're going to have an accumulator, right? Um, and we don't use this anymore, but like nonetheless they were like, OK, well why don't we just have like a register that we put stuff in that we're using all the time? And it's like, oh yeah, that sounds like a pretty cool idea, so we're gonna have like a a register called the accumulator which eventually becomes the general purpose register, right? um. So you know, like if you load memory in, you add memory and you can add that memory to the accumulator, so you've just got like basically it's it's sort of like, I just want to be able to remember one number really quickly because um just as a, I don't know, like a background point, registers are faster than memory, right, so if you have something in a register, it's really quick, so you just like it's like the one number, remember one number in your head and we're just gonna use that register as the remember one number in your head, um register. Um, then we have status registers, right? OK, so. You know, like this is where we get to the point where like we have interrupts and we have overflows and is this, is, is the process awake or is it asleep? We need to keep track of each process, like what status it's in, right, so we're gonna have to start having status registers, um, or you can keep a lot of statuses in one register because you know if you have like a 16 bit register, you can have lots of individual flags, um. And then we start having more and more registers in our operating system, so basically every process now has, you know, a stack pointer programme counter accumulator or a status register, and then a bunch of other registers, and then you can use them for whatever you want, and it's great, um. And then now we in the different kind of operating systems, we start naming them, right, and then so we get to this, you know, like assembly language where we're like, oh, OK, so what we're doing is we're using move along from this memory address to EAX which is the accumulator, right, so now we can start writing machine language. That gets us, you know, where we're in this um operating system where things are actually gonna be stored, we're gonna store them in registers once they're in a register, and now we're back in computer systems, right, like this is, this should be all very familiar from computer systems, um. At some point in time someone decides to rename all of these things from E's to to ours. I, I don't know why, like, presumably someone decided that R was a much more logical letter for the name of a register, and they thought, whoever came up with E in the first place, I hate them, right? Um, but like you don't need to know all this, by the way. Like I'm not exam question number 23, what is the 17th register? My God, could you imagine now now I'm going to put that in, it's fine. Um, right, um, but this is, this is just, uh, as a reference, this is the X86 32 bit architecture and this is the X86 64 bit architecture, right, so you can see that between different systems they have different idiosyncratic ways of storing all the information, which means that that is why. You have a computer game that runs on Windows and doesn't run on Mac, give or take, right, it's because the programme is not designed to work with these, you know, compilers and these registers and this bit of hardware and this bit of that, right? That's basically the reason why you need to have a different version of code to run on different operating systems. Um, If you wanna, like, because you wanna like um what do you call it, you wanna optimise it for the particular hardware that you've got, right, um, um, so you know there's some more, you know, you push and pop and call and move and all these kinds of good old assembly code. There's a lot of assembly code in the textbook that's worth going through those examples, um. Not in a lecture, I find I don't read code in lectures cos I, as a student, My brain would, if you missed like one line and you're like, I didn't understand that one line, oh now I'm out. Um, OK, cool. So, how much time do we got left? We might take, I'll see how much we got left, and then I'll see if it's, it's worth taking a small break cause I am, I am, I'm, I, I like you. And reaching the end, yeah, I think I'm gonna have like a 5 minute break, alright, because we've got enough to do this last one so I can just have a breather. Alright, um, we'll be back in 5 minutes, which will be 2:30, we'll be back at 2:30, alright. Record. Come on, do it for me. OK, alright, alright, ready, ready, ready, ready, ready, ready, ready, ready, everyone at home and everyone in the lecture theatre, we're gonna do some free revision. OK, OS dispatch. OK, we're gonna run processes in OS dispatch. Basically the idea here is that each, the OS has to decide out of each of these processes how to run it, but that's scheduling, so we're gonna do dispatch. So how do we run a process? What are we gonna do when we run a process? OK, so two questions. One is when do I do it, which is scheduling, and the other one is how do I do this, which is dispatching, right? If I'm a process and I'm the operating system, the dumb way that I could do it is I could have it as a series, so I'm going OS then that process and OS then that process then OS in that process. But the problem with that is that one of the processes, process 3, could just grab the CPU and run forever, right? And as a consequence, I have to have the ability to kill, kill, I need to be able to kill them, right? Um, and so. Alright. The way that I can do this is I can periodically kill it. So basically what I do is then establish a timer and every so often I'm going to kill the process that's currently running on the operating system and then I'm going to do some other stuff and maybe I'll give it to a different process or whatever, but then I'll let it run again and then I can run them all as little time slices like these little coloured bars here, right? um and we're gonna interrupt every periodic period of time. OK, we're gonna do a bit, interrupt, do a bit more, interrupt. Bit more and it requires external hardware to do it. This interrupt may not be ignored because otherwise it would stuff up and the uh the process would run forever. And then what process am I running? We need a process control block which contains all the relevant information for each process, right, because when we're loading something into or out of memory and into the CPU and out of the CPU, we need to keep track of the minimum number of pieces of information that will tell us what the purpose of that process is, um. Including the process ID, the state, the execution state, the scheduling policy, accounting information, whether it's a parent or child, if you're interested in this and you haven't studied systems programming, look up the word fork, um, and it'll tell you all about how to programme forks in C, or it'll give you lots of pictures of cutlery, um, and then credentials. Who's actually running it, right, so these are all the things that we need to know so we can know if they've got access to different bits of memory as well and different kinds of functions. Um, and we also need to know if they've got any files open or if they've got pointers to things, so we need to know what they're all looking at. So if they've opened files we need their file description table or the file table. All right. OK. I'll just check if it's actually running cause I don't want to have to do that again. OK, good, alright. Alright, alright, alright, um, and you can watch that, that's the only section of the lecture that you're allowed to watch on like 0.5 ft, OK. Um, OK, so basically what we're gonna do is, now we've got this thing and we've got the active system, we've got the storage system, so you've gotta imagine that we're gonna run a programme, we're gonna run a programme and it's called a process, but we're gonna run a process from a programme. I don't know. Um, how is this gonna work, right, we have the PID, it's process date, it's execution state, we have all these bits of information about the process, right? Yeah, and we're gonna have to basically kick it away somewhere, right, all this information, right, because basically what we're gonna do is we're gonna say, hey, process one stop, alright, um, tell me everything about yourself and I'll write it in my little notebook and then, um, when it's your turn next, I'll come back and tell you all that information, right, and then it will go, I need all that information from process, well, in this case process one again, it'll be like, hey, process one, you know all that information and I just I I just store it, I have it. This is all the stuff relevant to you. Now I know where to load you back in. Right, so basically we need all of this information that we can store so that we can then reload that process back into memory at some at some later date, so we basically put it back into the active system. So we're gonna like sort of put it, put it off to the side, and that could be in RAM, but it could also, we could actually take all the process. This information they just like stored it on the hard drive somewhere if we were really crappy operating system, and then later we'd be like, OK, I was running this process a long time ago. According to it, this was all of its registers and all of its data, it was up to this part, it had all of this stuff loaded in memory and I'm gonna chuck it back into my active system. All right. So if we think about what a switch means, you know, when we're switching from one process to another process, we're saving registers for process A to some kind of process structure. We're loading registers for process B from some kind of process structure, and then we're switching to K-Stack and return from trap, right, these are technical terms for basically going, oh, OK, um, we're gonna, we're gonna, uh, when we're doing the switch, the OS is doing the interrupt, so there's a trap involved and it's basically going OK. My job is to do all these things and then at the end I will return and give process B the right to start actually running, right? um. So on the hardware end, you know, like the, we're gonna have a trigger timer that's gonna trigger all of this, we're gonna change to kernel mode so that we can do the save register and load register nonsense, right, because we need to be in kernel mode, right, that makes sense, right? We can't let the users, you know, like load other processes from memory, right, that would be really bad, right, so we got to switch into kernel mode so the operating system is the one that's actually doing this job, um. We're gonna have to restore the registers in B and then we're gonna have to change back into user mode at the end, right, so that's kind of a sensible process, basically we go operating system jumps in, does the switch. Jumps out and goes, go back and you can start doing whatever you want to do. Um, Oh yeah, this should be revision from, um, systems programming again. I already went through this before, but running means it's on the CPU ready means it wants to be on the CPU and blocked means it doesn't really want to be on the CPU because even if you put it on CPU, it couldn't do anything cos it's waiting for it in hardware usually. So it's like a, you know, like if, uh, if you're Microsoft Word and the person's there and they're like, I'm going to type, yeah, it's blocked the entire time that you're trying to type. And then when you press the button, it's like, oh, I should do something. I, I want the computer again and then it will do the thing. Um, And so what we're gonna have is we're gonna have a runable processors queue, so this is gonna be the processor, all the processes that basically are ready to run, right? And we'll talk about like this is a really simplistic version, there are much more complicated versions, but basically at the very sort of abstract level there's a queue. Um, we also have a waiting queue, right, and basically the waiting queue is gonna be for IO and you could have it so you have like one waiting queue per piece of IO or you could have one waiting queue and there's like a register in there to tell you which bit of IO you're waiting for or something like that. There's a bunch of different options, um. So waiting for IO1 and waiting for IO2. Uh, so, I think we are at the end. This is lecture one, done, right? What did we learn? Alright, we need to know the difference between a programme and a process, we need to know, how do we, you know, like just the general process of like, The general process, we need to know the general process of processes, processes, yeah, that's that's not, that's clear. Um, we need to know how an operating system basically does multitasking, how does it take one process and put it in the CPU and how does it take a process that's in the CPU and put it away somewhere that isn't going to just break it, right? So how does it do those switching kind of tasks, right? How does it allow processors to access low level hardware instructions without letting them destroy the universe? Right? Um, via abstraction, and how does it allocate resources, right, so this is basically what is an operating system. At the end, and I think that's basically kind of the summary of where we're at, right, so today, operating systems, virtualization processes and system calls, and hopefully if you've got your head around all of those things, we are, we're done for lecture one, time for questions. Excellent, everyone understood everything perfectly, there are no questions, excellent. If you have any questions and you don't want to yell them across an auditorium, you can always come to me at the end. 01 last piece of information that I think is probably useful is that my consultation hours are now, right? That is to say, starting from 3 until 5. That is when I will be available to answer questions kind of freely for OS. So basically my goal, I, I sort of went, I have this huge class, maybe I should just run my consultation hours afterwards because it's 30 on a Friday and I'm not gonna do any work, right? Like after doing lecture on a Friday, so I may as well just keep talking about OS. Alright, I'll see you guys next week, and there's no tutorials next week, but your first tutorial prep will be due at the end of next week, OK.
