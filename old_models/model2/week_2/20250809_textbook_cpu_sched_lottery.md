<!-- 
Generated by LectureQ
Date: 2025-08-09 23:20:34
Model: qwen3:30b
-->

<think>
Okay, the user wants me to create concise study notes from a textbook chapter about CPU scheduling with proportional share concepts. They've provided detailed slides covering lottery scheduling, stride scheduling, and Linux CFS.

First I need to understand what's most important for exam purposes. The key is identifying 5-10 core concepts that would likely be tested. From the slides, these stand out:
- Lottery scheduling using tickets (probabilistic)
- Ticket mechanisms like currency/transfer/inflation
- Stride scheduling as deterministic alternative
- CFS implementation with vruntime and red-black trees
- The fairness tradeoffs between approaches

I notice students often get confused about how lottery vs stride actually works in practice. I should clarify that lottery uses randomness (so proportions are probabilistic over time) while stride achieves exact ratios deterministically.

For the notes, I'll avoid all examples except one perfect illustration - like the 75/25 ticket split for A/B processes. The implementation code snippets can be cut down to just the key idea: "Traverse list adding tickets until counter > random number."

The CFS section has important details about schedlatency and mingranularity parameters that affect time slices. Must include those formulas but simplify them - maybe show only the weighted slice calculation.

Hmm... should I mention all references? Definitely not for study notes. But the key papers (WW94, W95) are worth naming since they're foundational.

Biggest trap to avoid: getting bogged down in CFS's red-black tree details. Just need to say "uses balanced trees for O(log n) scheduling decisions" without explaining tree structures.

For fairness metrics - that Figure 9.2 graph is important but I can summarize it as "Fairness approaches 1 only with long job durations."

Wait, the user emphasized eliminating redundant explanations. So no need to explain why computers count from zero (that Dijkstra note in Slide 13). Cut all tangents.

Let me structure this:
- Core concept bullets first
- Then ticket mechanisms table (currency/transfer/inflation)
- CFS key parameters as a mini-table
- Final comparison of approaches

Must keep it tight. Original slides are ~20 pages, notes should be under 1 page A4 equivalent. Targeting 35% length reduction.

*checks slide count* Slide 9 has that nice weight table - but for study notes I'll just say "weights map to priority (e.g., nice=-5 ‚Üí weight=3121)" without listing all values.

Ah! The homework questions are actually great exam material. But since they're not part of the chapter content, I won't include them in notes unless directly relevant - like question 4 about quantum size affecting fairness.

*mental note*: Emphasize that lottery's randomness causes short-term unfairness but averages out (per Slide 5 graph). That's a common exam point.
</think>

# Week 2: Proportional-Share CPU Scheduling  
*(Condensed for Exam Focus)*  

---

## üîë **Core Concepts**  
1. **Proportional Share Goal**: Guarantee processes receive *specific CPU percentages* (e.g., A gets 75%, B gets 25%), not just min response time.  
2. **Lottery Scheduling**: Uses **tickets** to probabilistically allocate shares:  
   - Each process has tickets; winner = random ticket draw from total pool.  
   - *Example*: Process A (75 tickets), B (25 tickets) ‚Üí A runs ~75% of time (probabilistic, not guaranteed).  
3. **Stride Scheduling**: Deterministic alternative to lottery:  
   - Each process has a `stride` = constant √∑ tickets (e.g., 10,000 √∑ 100 tickets = stride=100 for A).  
   - Scheduler picks lowest `pass value` (updated by stride after each run) ‚Üí *exact* proportional shares.  
4. **CFS (Linux)**: Efficient implementation of fair-share scheduling using:  
   - **Virtual runtime (`vruntime`)**: Accumulates inversely to process weight/nice level.  
   - **Schedlatency**: Target time for all processes to run once (e.g., 48ms). Time slice = `schedlatency / n`.  
   - **Weighting via nice levels** (-20=high priority, +19=low): Weights map to priorities (see table below).  

---

## ‚öôÔ∏è **Key Mechanisms & Formulas**  
| Concept          | Description                                                                 | Formula/Example                                  |
|------------------|-----------------------------------------------------------------------------|-------------------------------------------------|
| **Tickets**      | Represent CPU share; % of tickets = target CPU %.                           | A: 75 tickets, B: 25 ‚Üí A gets ~75% CPU.         |
| **Ticket Currency** | User allocates tickets *within their own jobs* (system converts to global). | User A gives job1/2: 500 tickets each ‚Üí Global = 50 each. |
| **CFS Weighting** | `weight` from nice level; time slice ‚àù weight / total weights.              | Nice=-5 (`weight=3121`) vs. default (nice=0, `weight=1024`).<br>A‚Äôs slice = 3√óB‚Äôs slice (‚âà36ms vs. 12ms @ schedlatency=48ms). |
| **CFS vruntime** | Adjusts for priority: `vruntime += (1024 / weight) √ó runtime`.              | A (`weight=3121`) accumulates vruntime at *‚Öì* rate of B (`weight=1024`). |

---

## üåê **Comparison: Lottery vs. Stride vs. CFS**  
| Approach       | Fairness (Short-Term) | Implementation Complexity | Key Advantage                          |
|----------------|------------------------|----------------------------|-----------------------------------------|
| **Lottery**    | Probabilistic (~75% A over time, not exact) | Very simple (`O(n)` list traversal) | No global state; easy to add new processes. |
| **Stride**     | Exact (deterministic)  | Moderate (track `pass`/`stride`) | Guarantees ratios *every cycle*.        |
| **CFS**        | Near-exact             | High (uses red-black trees for efficiency) | Scales to thousands of processes; efficient. |

> üí° **Why CFS?**: Uses balanced trees (`O(log n)` lookups vs. `O(n)` list scans), critical in datacenters with 1000s of processes.

---

## ‚ö†Ô∏è **Critical Exam Points**  
- **Lottery‚Äôs randomness is a feature, not a bug**: Avoids corner cases (e.g., LRU worst-case) and requires minimal state.  
- **CFS fairness tradeoff**: Shorter `schedlatency` ‚Üí better fairness but more context switches; longer ‚Üí worse fairness but higher performance.  
  - *Mingranularity* prevents tiny time slices (e.g., sets min slice to 6ms).  
- **Ticket assignment problem**: No universal solution ("how many tickets for browser?"). CFS uses `nice` levels as a practical workaround.  
- **I/O starvation risk in CFS**: Sleeping processes wake up with low vruntime ‚Üí *fixed by resetting vruntime to tree min value*.  

---

## üìä **Summary Box: When to Use What**  
| Scenario                          | Best Scheduler       |
|-----------------------------------|----------------------|
| Simple, probabilistic sharing (e.g., VMs) | Lottery              |
| Exact ratios needed (no randomness) | Stride               |
| Modern Linux systems / datacenters  | CFS                  |

> üí° **CFS is dominant**: Used in all modern Linux kernels. *Not* a panacea‚Äîstruggles with I/O-bound processes and requires manual priority tuning (`nice`).

---

## ‚ùå **What to Skip**  
- All code snippets (e.g., `Figure 9.1`).  
- Redundant examples (e.g., full ticket conversion steps).  
- Reference details (cite papers like [WW94] only if asked for *foundational work*).  
- Homework questions (focus on concepts, not simulations).  

> ‚úÖ **Final Tip**: For exams, focus on:  
> 1. How tickets ‚Üí CPU share in lottery.  
> 2. Why stride is deterministic vs. lottery‚Äôs randomness.  
> 3. CFS `vruntime` and weighting logic (`nice` ‚Üî weight ‚Üî slice time).