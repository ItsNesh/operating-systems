<!-- 
Generated by LectureQ
Date: 2025-08-08 01:48:07
Model: qwen3:30b
-->

<think>
I'll create comprehensive study notes for the textbook chapter "Week 1 Introduction: Textbook CPU Mechanisms" based on the provided slides. I'll follow the instructions to create well-structured, comprehensive study notes in markdown format.

Let me analyze the content first to understand the key concepts:

The chapter is about CPU virtualization mechanisms, specifically "Limited Direct Execution" (LDE), which is a technique for operating systems to virtualize the CPU while maintaining control.

Key topics covered:
1. The need for CPU virtualization (sharing physical CPU among many processes)
2. Challenges: performance and control
3. Basic technique: Limited Direct Execution
4. Problem #1: Restricted Operations (system calls, user mode vs kernel mode)
5. Problem #2: Switching Between Processes (cooperative vs non-cooperative approaches, timer interrupts, context switches)

I'll organize the notes following the chapter structure, highlighting key concepts, definitions, and processes.

Let me create the study notes:

# Week 1: CPU Mechanisms - Limited Direct Execution

## Learning Objectives
- Understand the fundamental challenge of CPU virtualization: sharing the physical CPU among multiple processes while maintaining control
- Learn the concept of "Limited Direct Execution" as a mechanism for CPU virtualization
- Understand the role of hardware support (user mode vs kernel mode) in enabling secure system calls
- Learn how operating systems regain control of the CPU through timer interrupts
- Understand the context switch mechanism for process switching

## Core Challenge of CPU Virtualization

**THE CRUX: HOW TO EFFICIENTLY VIRTUALIZE THE CPU WITH CONTROL**

Operating systems must:
- Virtualize the CPU in an efficient manner (minimize overhead)
- Retain control over the system (prevent processes from monopolizing CPU or accessing restricted resources)

This requires both hardware and operating system support.

## 6.1 Basic Technique: Limited Direct Execution

### Concept
- **Direct Execution**: Run programs directly on the CPU (without virtualization)
- **Limited Direct Execution (LDE)**: Run programs directly but with restrictions to maintain OS control

### Why Limited?
Without limitations, the OS would be "just a library" - unable to control processes, leading to security and stability issues.

### Direct Execution Protocol (Without Limits)
1. Create entry for process in process list
2. Allocate memory for program
3. Load program into memory
4. Set up stack with argc/argv
5. Clear registers
6. Execute call to main()
7. Run main()
8. Execute return from main()
9. Free memory of process
10. Remove from process list

*Figure 6.1: Direct Execution Protocol (Without Limits)*

## 6.2 Problem #1: Restricted Operations

### The Challenge
How can a process perform restricted operations (I/O, resource access) without giving it complete control over the system?

### Solution: Hardware Modes of Execution

| Mode | Permissions | Description |
|------|-------------|-------------|
| **User Mode** | Restricted | Code running here cannot perform privileged operations (e.g., I/O requests) |
| **Kernel Mode** | Full Access | OS/kernel runs here; can perform all operations including privileged ones |

### System Calls: The Mechanism for Restricted Operations

**How System Calls Work:**
1. User program calls a library function (e.g., `open()`, `read()`)
2. Library code prepares arguments and system call number
3. Library executes a **trap instruction** (special hardware instruction)
4. Hardware:
   - Saves registers
   - Switches to kernel mode
   - Jumps to trap handler (via trap table)
5. OS handles the system call
6. OS executes **return-from-trap instruction**
   - Restores registers
   - Switches back to user mode
   - Returns to instruction after trap

### Key Insight: System Call Number
- User code places system call number in a register or stack location
- OS checks validity of number before executing corresponding code
- This provides a level of protection (user can't specify exact kernel address)

### Important Details
- **Trap Table**: Set up by OS at boot time; tells hardware where to jump for different exceptions (system calls, interrupts)
- **Trap Instruction**: Must be executed in user mode to trigger a system call
- **Return-from-trap Instruction**: Must be executed in kernel mode to return to user mode

### Security Consideration: User Input Handling
- OS must validate all user inputs to system calls
- Example: For `write()` system call, must check buffer address to prevent kernel memory access
- **Principle**: Treat all user inputs with suspicion - "a secure system must treat user inputs with great suspicion"

## 6.3 Problem #2: Switching Between Processes

### The Challenge
How can the OS regain control of the CPU to switch between processes?

### Cooperative Approach
- OS trusts processes to behave reasonably
- Processes give up CPU via:
  - System calls (e.g., `open()`, `read()`)
  - Illegal operations (e.g., divide by zero, invalid memory access)
  - Explicit `yield()` system call

**Limitation**: If a process enters an infinite loop without making system calls, OS cannot regain control (requires reboot)

### Non-Cooperative Approach: Timer Interrupt
- **Key Insight**: A timer interrupt allows OS to regain control even if processes are non-cooperative
- **How it works**:
  1. At boot time, OS sets up timer interrupt handler in trap table
  2. OS starts the timer (privileged operation)
  3. Timer interrupts CPU every X milliseconds
  4. Hardware saves current state and jumps to interrupt handler
  5. OS regains control and can switch processes

*Figure 6.3: Limited Direct Execution Protocol (Timer Interrupt)*

### Context Switch
- **Definition**: The low-level operation to switch from one process to another
- **How it works**:
  1. Hardware saves current process's registers (onto kernel stack)
  2. OS decides to switch processes (via scheduler)
  3. OS saves current process's context (registers, PC) into process structure
  4. OS restores next process's context (registers, PC) from its process structure
  5. OS switches to new process's kernel stack
  6. OS executes return-from-trap instruction

*Figure 6.4: The xv6 Context Switch Code*

### Context Switch Steps (Detailed)
1. **Timer interrupt occurs**:
   - Hardware saves user registers onto kernel stack
   - Switches to kernel mode
   - Jumps to trap handler

2. **OS handles interrupt**:
   - Decides to switch from Process A to Process B
   - Calls `switch()` routine
   - Saves Process A's registers into its process structure
   - Restores Process B's registers from its process structure
   - Switches to Process B's kernel stack

3. **Return from trap**:
   - Hardware restores Process B's registers from kernel stack
   - Switches to user mode
   - Jumps to Process B's PC

### Key Insight: Two Types of Register Saves/Restores
1. **Hardware implicit save** (during interrupt):
   - User registers saved onto kernel stack
   - Happens automatically when interrupt occurs

2. **Software explicit save** (during context switch):
   - Kernel registers saved into process structure
   - Done by OS code

## 6.4 Worried About Concurrency?

### Challenge
What happens when:
- A timer interrupt occurs during a system call?
- Multiple interrupts occur simultaneously?

### Solutions
1. **Disable interrupts during interrupt processing**:
   - Ensures only one interrupt is handled at a time
   - Risk: Disabling for too long could lead to lost interrupts

2. **Advanced locking schemes**:
   - Protect concurrent access to internal data structures
   - Enable multiple activities within kernel simultaneously
   - Particularly important on multiprocessors

## 6.5 Summary

### Limited Direct Execution (LDE) Protocol
- **Core Idea**: Run programs directly on CPU but with restrictions to maintain OS control
- **Key Components**:
  1. Hardware modes (user mode vs kernel mode)
  2. System calls (via trap instruction)
  3. Timer interrupt (for non-cooperative scheduling)
  4. Context switches (for process switching)

### Analogy: Baby Proofing
- Just as you "baby proof" a room by restricting dangerous elements, the OS "baby proofs" the CPU by:
  1. Setting up trap handlers at boot time
  2. Starting an interrupt timer
  3. Running processes in restricted mode

### Performance Considerations
- **System call cost**: ~4 microseconds (1996), ~0.1-0.5 microseconds (modern systems)
- **Context switch cost**: ~6 microseconds (1996), ~0.1-0.5 microseconds (modern systems)
- **Note**: OS operations are often memory-intensive, so memory bandwidth improvements don't track CPU speed as closely

## Key Terms and Definitions

| Term | Definition |
|------|------------|
| **Limited Direct Execution (LDE)** | A CPU virtualization technique where programs run directly on the CPU but with restrictions to maintain OS control |
| **User Mode** | Hardware execution mode where processes cannot perform privileged operations |
| **Kernel Mode** | Hardware execution mode where OS/kernel has full access to hardware resources |
| **System Call** | A mechanism for user processes to request OS services (via trap instruction) |
| **Trap Instruction** | Hardware instruction that switches to kernel mode and jumps to trap handler |
| **Return-from-trap Instruction** | Hardware instruction that switches back to user mode and returns to user code |
| **Trap Table** | Data structure set up by OS at boot time that tells hardware where to jump for different exceptions |
| **Timer Interrupt** | Hardware mechanism that periodically interrupts CPU to allow OS to regain control |
| **Context Switch** | Low-level operation to switch from one process to another by saving/restoring register state |

## Important Figures and Diagrams

*Figure 6.1: Direct Execution Protocol (Without Limits)*
- Shows the basic sequence of running a program without restrictions

*Figure 6.2: Limited Direct Execution Protocol*
- Shows the full sequence including system calls and context switches

*Figure 6.3: Limited Direct Execution Protocol (Timer Interrupt)*
- Shows the timeline of a timer interrupt triggering a context switch

*Figure 6.4: The xv6 Context Switch Code*
- Shows the assembly code for a context switch in the xv6 operating system

## Summary Box: How Limited Direct Execution Works

**The LDE Protocol in a Nutshell:**

1. **At Boot Time**:
   - OS sets up trap table (specifies addresses for system calls, timer interrupts)
   - OS starts timer interrupt

2. **When Running a Process**:
   - OS allocates memory, sets up process structure
   - OS executes `return-from-trap` to start process (switches to user mode)
   - Process runs until:
     - Makes system call (traps to OS)
     - Timer interrupt occurs (traps to OS)

3. **When OS Regains Control**:
   - Handles system call or timer interrupt
   - Decides whether to switch processes
   - If switching:
     - Saves current process context
     - Restores next process context
     - Executes `return-from-trap` to resume next process

## Review Questions (from Chapter)

1. How does the OS regain control of the CPU when a process is running?
2. What is the difference between user mode and kernel mode?
3. How do system calls work at the hardware level?
4. What is the purpose of the trap table?
5. How does a timer interrupt help with process scheduling?
6. What is a context switch, and how does it work?

## Performance Notes

- **System Call Cost**: 
  - 1996 (Linux 1.3.37, 200 MHz P6): ~4 microseconds
  - Modern systems (2-3 GHz processors): ~0.1-0.5 microseconds

- **Context Switch Cost**:
  - 1996 (Linux 1.3.37, 200 MHz P6): ~6 microseconds
  - Modern systems (2-3 GHz processors): ~0.1-0.5 microseconds

- **Important Note**: OS operations are often memory-intensive, so memory bandwidth improvements don't track CPU speed as closely as might be expected.

## Key Insights

> **"The OS must virtualize the CPU in an efficient manner while retaining control over the system. To do so, both hardware and operating-system support will be required."**

> **"A secure system must treat user inputs with great suspicion. Not doing so will undoubtedly lead to easily hacked software..."**

> **"The addition of a timer interrupt gives the OS the ability to run again on a CPU even if processes act in a non-cooperative fashion. Thus, this hardware feature is essential in helping the OS maintain control of the machine."**

> **"Reboot is useful because it moves software back to a known and likely more tested state. Reboots also reclaim stale or leaked resources which may otherwise be hard to handle."**

## References (Key Papers)

- **[K+61]**: Atlas system pioneered many modern concepts
- **[M+63]**: Early paper about time-sharing using timer interrupts
- **[S07]**: "Return-into-libc" attack technique showing security implications
- **[MS96]**: lmbench benchmark for measuring system call and context switch costs
- **[C+04]**: "Microreboot" technique for system recovery

## Homework: Measurement

**Task**: Measure the cost of a system call and context switch.

**System Call Measurement**:
- Repeatedly call a simple system call (e.g., 0-byte read)
- Time the operation and divide by number of iterations
- Account for timer precision (measure back-to-back calls to `gettimeofday()`)

**Context Switch Measurement**:
- Use two processes communicating via pipes
- One process writes to a pipe, waits for read
- OS switches to other process, which reads from first pipe and writes to second
- Measure communication cost to estimate context switch cost
- Ensure both processes run on the same CPU (use `sched_setaffinity()` on Linux)

**Note**: On multi-CPU systems, ensure both processes are bound to the same processor to measure pure context switch cost.
</think>

# Week 1: CPU Mechanisms - Limited Direct Execution

## Learning Objectives
- Understand the fundamental challenge of CPU virtualization: sharing the physical CPU among multiple processes while maintaining control
- Learn the concept of **Limited Direct Execution** as a mechanism for CPU virtualization
- Understand the role of hardware support (user mode vs kernel mode) in enabling secure system calls
- Learn how operating systems regain control of the CPU through timer interrupts
- Understand the context switch mechanism for process switching

---

## Core Challenge of CPU Virtualization

> **THE CRUX: HOW TO EFFICIENTLY VIRTUALIZE THE CPU WITH CONTROL**

Operating systems must:
- **Virtualize the CPU** in an efficient manner (minimize overhead)
- **Retain control** over the system (prevent processes from monopolizing CPU or accessing restricted resources)

This requires **both hardware and operating system support**. The OS will often use a judicious bit of hardware support to accomplish its work effectively.

---

## 6.1 Basic Technique: Limited Direct Execution

### Concept
- **Direct Execution**: Run programs directly on the CPU (without virtualization)
- **Limited Direct Execution (LDE)**: Run programs directly but with restrictions to maintain OS control

### Why Limited?
Without limitations, the OS would be "just a library" - unable to control processes, leading to security and stability issues.

### Direct Execution Protocol (Without Limits)
1. Create entry for process in process list
2. Allocate memory for program
3. Load program into memory
4. Set up stack with argc/argv
5. Clear registers
6. Execute call to main()
7. Run main()
8. Execute return from main()
9. Free memory of process
10. Remove from process list

*Figure 6.1: Direct Execution Protocol (Without Limits)*

---

## 6.2 Problem #1: Restricted Operations

### The Challenge
How can a process perform restricted operations (I/O, resource access) without giving it complete control over the system?

> **THE CRUX: HOW TO PERFORM RESTRICTED OPERATIONS**

A process must be able to perform I/O and other restricted operations, but without giving the process complete control over the system.

---

### Hardware Modes of Execution

| Mode | Permissions | Description |
|------|-------------|-------------|
| **User Mode** | Restricted | Code running here cannot perform privileged operations (e.g., I/O requests) |
| **Kernel Mode** | Full Access | OS/kernel runs here; can perform all operations including privileged ones |

---

### System Calls: The Mechanism for Restricted Operations

**How System Calls Work:**
1. User program calls a library function (e.g., `open()`, `read()`)
2. Library code prepares arguments and system call number
3. Library executes a **trap instruction** (special hardware instruction)
4. Hardware:
   - Saves registers
   - Switches to kernel mode
   - Jumps to trap handler (via trap table)
5. OS handles the system call
6. OS executes **return-from-trap instruction**
   - Restores registers
   - Switches back to user mode
   - Returns to instruction after trap

---

### Key Insight: System Call Number
- User code places system call number in a register or stack location
- OS checks validity of number before executing corresponding code
- This provides a level of protection (user can't specify exact kernel address)

---

### Important Details
- **Trap Table**: Set up by OS at boot time; tells hardware where to jump for different exceptions (system calls, interrupts)
- **Trap Instruction**: Must be executed in user mode to trigger a system call
- **Return-from-trap Instruction**: Must be executed in kernel mode to return to user mode

> **"The hardware needs to be a bit careful when executing a trap, in that it must make sure to save enough of the caller's registers in order to be able to return correctly when the OS issues the return-from-trap instruction."**

---

### Security Consideration: User Input Handling
- OS must validate all user inputs to system calls
- Example: For `write()` system call, must check buffer address to prevent kernel memory access
- **Principle**: Treat all user inputs with suspicion - "a secure system must treat user inputs with great suspicion"

> **"Not doing so will undoubtedly lead to easily hacked software, a despairing sense that the world is an unsafe and scary place, and the loss of job security for the all-too-trusting OS developer."**

---

## 6.3 Problem #2: Switching Between Processes

### The Challenge
How can the OS regain control of the CPU to switch between processes?

> **THE CRUX: HOW TO REGAIN CONTROL OF THE CPU**

---

### Cooperative Approach
- OS trusts processes to behave reasonably
- Processes give up CPU via:
  - System calls (e.g., `open()`, `read()`)
  - Illegal operations (e.g., divide by zero, invalid memory access)
  - Explicit `yield()` system call

**Limitation**: If a process enters an infinite loop without making system calls, OS cannot regain control (requires reboot)

---

### Non-Cooperative Approach: Timer Interrupt
> **"The addition of a timer interrupt gives the OS the ability to run again on a CPU even if processes act in a non-cooperative fashion. Thus, this hardware feature is essential in helping the OS maintain control of the machine."**

**How it works**:
1. At boot time, OS sets up timer interrupt handler in trap table
2. OS starts the timer (privileged operation)
3. Timer interrupts CPU every X milliseconds
4. Hardware saves current state and jumps to interrupt handler
5. OS regains control and can switch processes

*Figure 6.3: Limited Direct Execution Protocol (Timer Interrupt)*

---

### Context Switch
> **"A context switch is conceptually simple: all the OS has to do is save a few register values for the currently-executing process and restore a few for the soon-to-be-executing process."**

**How it works**:
1. Hardware saves current process's registers (onto kernel stack) when interrupt occurs
2. OS decides to switch processes (via scheduler)
3. OS saves current process's context (registers, PC) into process structure
4. OS restores next process's context (registers, PC) from its process structure
5. OS switches to new process's kernel stack
6. OS executes return-from-trap instruction

*Figure 6.4: The xv6 Context Switch Code*

---

### Context Switch Steps (Detailed)

1. **Timer interrupt occurs**:
   - Hardware saves user registers onto kernel stack
   - Switches to kernel mode
   - Jumps to trap handler

2. **OS handles interrupt**:
   - Decides to switch from Process A to Process B
   - Calls `switch()` routine
   - Saves Process A's registers into its process structure
   - Restores Process B's registers from its process structure
   - Switches to Process B's kernel stack

3. **Return from trap**:
   - Hardware restores Process B's registers from kernel stack
   - Switches to user mode
   - Jumps to Process B's PC

---

### Two Types of Register Saves/Restores
1. **Hardware implicit save** (during interrupt):
   - User registers saved onto kernel stack
   - Happens automatically when interrupt occurs

2. **Software explicit save** (during context switch):
   - Kernel registers saved into process structure
   - Done by OS code

> **"The latter action moves the system from running as if it just trapped into the kernel from A to as if it just trapped into the kernel from B."**

---

## 6.4 Worried About Concurrency?

### Challenge
What happens when:
- A timer interrupt occurs during a system call?
- Multiple interrupts occur simultaneously?

### Solutions
1. **Disable interrupts during interrupt processing**:
   - Ensures only one interrupt is handled at a time
   - Risk: Disabling for too long could lead to lost interrupts

2. **Advanced locking schemes**:
   - Protect concurrent access to internal data structures
   - Enable multiple activities within kernel simultaneously
   - Particularly important on multiprocessors

> **"Operating systems also have developed a number of sophisticated locking schemes to protect concurrent access to internal data structures."**

---

## 6.5 Summary

### Limited Direct Execution (LDE) Protocol
- **Core Idea**: Run programs directly on CPU but with restrictions to maintain OS control
- **Key Components**:
  1. Hardware modes (user mode vs kernel mode)
  2. System calls (via trap instruction)
  3. Timer interrupt (for non-cooperative scheduling)
  4. Context switches (for process switching)

---

### Analogy: Baby Proofing
> **"In an analogous manner, the OS 'baby proofs' the CPU, by first (during boot time) setting up the trap handlers and starting an interrupt timer, and then by only running processes in a restricted mode."**

---

### Performance Considerations
| Operation | 1996 (Linux 1.3.37, 200 MHz P6) | Modern Systems (2-3 GHz) |
|-----------|----------------------------------|--------------------------|
| **System Call** | ~4 microseconds | ~0.1-0.5 microseconds |
| **Context Switch** | ~6 microseconds | ~0.1-0.5 microseconds |

> **"Not all operating-system actions track CPU performance. As Ousterhout observed, many OS operations are memory intensive, and memory bandwidth has not improved as dramatically as processor speed over time."**

---

## Key Terms and Definitions

| Term | Definition |
|------|------------|
| **Limited Direct Execution (LDE)** | A CPU virtualization technique where programs run directly on the CPU but with restrictions to maintain OS control |
| **User Mode** | Hardware execution mode where processes cannot perform privileged operations |
| **Kernel Mode** | Hardware execution mode where OS/kernel has full access to hardware resources |
| **System Call** | A mechanism for user processes to request OS services (via trap instruction) |
| **Trap Instruction** | Hardware instruction that switches to kernel mode and jumps to trap handler |
| **Return-from-trap Instruction** | Hardware instruction that switches back to user mode and returns to user code |
| **Trap Table** | Data structure set up by OS at boot time that tells hardware where to jump for different exceptions |
| **Timer Interrupt** | Hardware mechanism that periodically interrupts CPU to allow OS to regain control |
| **Context Switch** | Low-level operation to switch from one process to another by saving/restoring register state |

---

## Summary Box: How Limited Direct Execution Works

**The LDE Protocol in a Nutshell:**

1. **At Boot Time**:
   - OS sets up trap table (specifies addresses for system calls, timer interrupts)
   - OS starts timer interrupt

2. **When Running a Process**:
   - OS allocates memory, sets up process structure
   - OS executes `return-from-trap` to start process (switches to user mode)
   - Process runs until:
     - Makes system call (traps to OS)
     - Timer interrupt occurs (traps to OS)

3. **When OS Regains Control**:
   - Handles system call or timer interrupt
   - Decides whether to switch processes
   - If switching:
     - Saves current process context
     - Restores next process context
     - Executes `return-from-trap` to resume next process

---

## Review Questions

1. How does the OS regain control of the CPU when a process is running?
2. What is the difference between user mode and kernel mode?
3. How do system calls work at the hardware level?
4. What is the purpose of the trap table?
5. How does a timer interrupt help with process scheduling?
6. What is a context switch, and how does it work?

---

## Key Insights

> **"The OS must virtualize the CPU in an efficient manner while retaining control over the system. To do so, both hardware and operating-system support will be required."**

> **"A secure system must treat user inputs with great suspicion. Not doing so will undoubtedly lead to easily hacked software..."**

> **"Reboot is useful because it moves software back to a known and likely more tested state. Reboots also reclaim stale or leaked resources which may otherwise be hard to handle."**

> **"The only solution to infinite loops (and similar behaviors) under cooperative preemption is to reboot the machine. While you may scoff at this hack, researchers have shown that reboot (or in general, starting over some piece of software) can be a hugely useful tool in building robust systems."**

---

## References (Key Papers)

- **[K+61]**: "One-Level Storage System" by T. Kilburn et al. - Atlas pioneered many modern concepts
- **[M+63]**: "A Time-Sharing Debugging System for a Small Computer" - Early paper about time-sharing using timer interrupts
- **[S07]**: "The Geometry of Innocent Flesh on the Bone" - Shows security implications of arbitrary code execution
- **[MS96]**: "lmbench: Portable tools for performance analysis" - Benchmark for measuring system call and context switch costs
- **[C+04]**: "Microreboot â€” A Technique for Cheap Recovery" - Shows how reboot can improve system robustness

---

## Homework: Measurement

**Task**: Measure the cost of a system call and context switch.

**System Call Measurement**:
- Repeatedly call a simple system call (e.g., 0-byte read)
- Time the operation and divide by number of iterations
- Account for timer precision (measure back-to-back calls to `gettimeofday()`)

**Context Switch Measurement**:
- Use two processes communicating via pipes
- One process writes to a pipe, waits for read
- OS switches to other process, which reads from first pipe and writes to second
- Measure communication cost to estimate context switch cost
- Ensure both processes run on the same CPU (use `sched_setaffinity()` on Linux)

> **"On multi-CPU systems, ensure both processes are bound to the same processor to measure pure context switch cost."**