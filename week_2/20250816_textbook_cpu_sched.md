<!-- 
Generated by LectureQ (Enhanced Comprehensive Version)
Date: 2025-08-16 02:37:57
Model: qwen3:30b
Output Mode: Comprehensive
-->



# Comprehensive Study Notes: CPU Scheduling  
*Based on Textbook Chapter "Week 2: Cpu Sched"*

---

## I. Introduction to Scheduling
### A. Core Problem Statement
> **THE CRUX**: *How should we develop a basic framework for thinking about scheduling policies? What are the key assumptions? What metrics are important? What fundamental approaches have been used in early computer systems?*  

- **Origins**: Scheduling principles originated from operations management (e.g., assembly lines), emphasizing efficiency.
- **Key Insight**: Human endeavors like manufacturing and computing share core concerns: *resource utilization*, *efficiency*, and *fairness*.  
  > *"Assembl[y] lines... require scheduling, and many of the same concerns exist therein."*

---

## II. Workload Assumptions (Simplifying Conditions)
*All assumptions are unrealistic but serve as a starting point for analysis.*

| **Assumption** | **Description**                                                                 | **Realism Check** |
|----------------|---------------------------------------------------------------------------------|-------------------|
| 1              | Each job runs for the same amount of time.                                      | ❌ Highly Unrealistic |
| 2              | All jobs arrive at the same time.                                               | ❌ Unlikely in practice |
| 3              | Once started, each job runs to completion (non-preemptive).                     | ⚠️ Partially Realistic (batch systems) |
| 4              | All jobs only use CPU (no I/O operations).                                      | ❌ Highly Unrealistic |
| 5              | Run-time of each job is known *a priori* ("oracle" assumption).                 | ❌ **Worst Assumption** |

> 💡 **Critical Note**:  
> *"The run-time of each job is known: this would make the scheduler omniscient... not likely to happen anytime soon."*

---

## III. Scheduling Metrics
### A. Turnaround Time (Primary Metric)
- **Definition**:  
  \[
  T_{\text{turnaround}} = T_{\text{completion}} - T_{\text{arrival}}
  \]
- *Simplified under Assumption 2*: \(T_{\text{arrival}} = 0\) → \(T_{\text{turnaround}} = T_{\text{completion}}\).
- **Goal**: Minimize average turnaround time (e.g., for batch processing).

### B. Response Time
- **Definition**:  
  \[
  T_{\text{response}} = T_{\text{first\_run}} - T_{\text{arrival}}
  \]
- *Best-case assumption*: Job produces response instantly upon first run.
- **Goal**: Minimize average response time (e.g., for interactive systems).

### C. Fairness
- Measured by **Jain’s Fairness Index** [J91].
- **Trade-off with Performance**:  
  > *"Performance and fairness are often at odds... a scheduler may optimize performance but prevent some jobs from running, decreasing fairness."*

---

## IV. Scheduling Algorithms & Analysis

### A. First In, First Out (FIFO) / FCFS
#### *Description*
- Simplest algorithm: Run jobs in arrival order.
- **Non-preemptive**: Runs job to completion before switching.

#### *Example 1: Equal Job Lengths*  
| Job | Arrival Time | Runtime | Completion Time |
|-----|--------------|---------|----------------|
| A   | 0            | 10      | 10             |
| B   | 0            | 10      | 20             |
| C   | 0            | 10      | 30             |

- **Average Turnaround Time**: \(\frac{10 + 20 + 30}{3} = 20\) seconds.

#### *Example 2: Unequal Job Lengths (Convoy Effect)*  
| Job | Arrival Time | Runtime |
|-----|--------------|---------|
| A   | 0            | 100     |
| B   | 0            | 10      |
| C   | 0            | 10      |

- **FIFO Schedule**:  
  - A runs (0–100), then B (100–110), then C (110–120).  
  - *Turnaround*: \(A=10