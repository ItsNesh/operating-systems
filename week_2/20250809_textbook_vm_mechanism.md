<!-- 
Generated by LectureQ
Date: 2025-08-09 20:21:08
Model: qwen3:30b
-->

<think>
I need to create comprehensive study notes from the textbook chapter "Mechanism: Address Translation" based on the slides provided. The instructions specify that I must include ALL information without summarizing, preserving every detail, example, and explanation.

Let me go through each slide carefully and extract all the information in a structured way.

Starting with Slide 1:

This introduces the concept of virtualizing memory using a mechanism similar to limited direct execution (LDE) used for CPU virtualization. The key points are:
- LDE: Let programs run directly on hardware, but interpose at critical points (system calls, timer interrupts) to maintain OS control.
- Goals: Efficiency (minimize OS involvement) and Control (ensure processes only access their own memory).
- The "crux" of the problem: How to efficiently and flexibly virtualize memory while maintaining control over memory access.

Slide 2:
- Introduces "hardware-based address translation" as the mechanism for virtualizing memory.
- Hardware transforms each memory access (instruction fetch, load, store) from virtual to physical address.
- OS must manage memory (track free/used locations) and set up hardware for correct translations.
- The goal is to create an illusion that each program has its own private memory.
- Assumptions for initial approach:
  * User's address space must be placed contiguously in physical memory
  * Address space size < physical memory size
  * All address spaces are the same size

Slide 3:
- Provides an example code sequence (in C and x86 assembly) that loads a value from memory, increments it by 3, and stores it back.
- The C code: 
  void func() {
    int x = 3000; // thanks, Perry.
    x = x + 3; // line of code we are interested in
  }
- The assembly:
  128: movl 0x0(%ebx), %eax ;load 0+ebx into eax
  132: addl $0x03, %eax ;add 3 to eax register
  135: movl %eax, 0x0(%ebx) ;store eax back to mem

- Explains the memory accesses that occur when this code runs:
  * Fetch instruction at address 128
  * Execute (load from address 15 KB)
  * Fetch instruction at address 132
  * Execute (no memory reference)
  * Fetch instruction at address 135
  * Execute (store to address 15 KB)

- Mentions Figure 15.1 (which shows the process's address space layout)

Slide 4:
- Shows Figure 15.1: A Process And Its Address Space
- This figure shows the code section (at address 128) and data section (variable x at address 15 KB)
- The initial value of x is 3000

Slide 5:
- Shows Figure 15.2: Physical Memory with a Single Relocated Process
- This figure shows physical memory layout with the OS using the first slot, and the process relocated to start at physical address 32 KB.
- The free slots are 16 KB-32 KB and 48 KB-64 KB.

- Introduces the concept of "base and bounds" (also called "dynamic relocation") as the first incarnation of hardware-based address translation.

Slide 6:
- Explains base and bounds registers:
  * Base register: Holds the starting physical address of the process's address space.
  * Bounds register (limit register): Holds the size of the address space.
  * Address translation: physical address = virtual address + base
  * Hardware checks if virtual address is within bounds (0 ≤ virtual address < bounds)

- Example tracing of instruction execution:
  * For instruction at virtual address 128: physical address = 128 + 32768 = 32896
  * For load from virtual address 15 KB: physical address = 15360 + 32768 = 48128

- Notes that the technique is called "dynamic relocation" because it happens at runtime and allows moving address spaces after a process has started.

Slide 7:
- Explains the bounds register in more detail:
  * It can be defined as either:
    1. The size of the address space (check virtual address against this before adding base)
    2. The physical address of the end of the address space (add base first, then check if within bounds)
  * Both methods are logically equivalent.

- Provides example translations:
  * Virtual Address 0 → Physical Address 16 KB
  * Virtual Address 1 KB → Physical Address 17 KB
  * Virtual Address 3000 → Physical Address 19384
  * Virtual Address 4400 → Fault (out of bounds)

- Mentions that the MMU (Memory Management Unit) is the part of the processor that helps with address translation.

Slide 8:
- Summarizes hardware requirements for dynamic relocation (Figure 15.3):
  * Privileged mode: Needed to prevent user-mode processes from executing privileged operations
  * Base/bounds registers: Need pair per CPU to support address translation and bounds checks
  * Ability to translate virtual addresses and check if within bounds
  * Privileged instructions to update base/bounds
  * Ability to raise exceptions for illegal memory access or privileged instruction execution

- Notes that user processes cannot change base/bounds registers (would cause havoc).

- Mentions the free list data structure for tracking free memory.

Slide 9:
- Summarizes OS requirements for dynamic relocation (Figure 15.4):
  * Memory management: Allocate memory for new processes, reclaim from terminated processes
  * Base/bounds management: Set base/bounds properly upon context switch
  * Exception handling: Code to run when exceptions arise (likely terminate offending process)

Slide 10:
- Explains OS responsibilities in detail:
  * When a process is created: Find space for address space in memory (using free list)
  * When a process is terminated: Reclaim memory and put it back on free list
  * When context switch occurs: Save/restore base/bounds registers
  * Exception handling: Install handlers at boot time for various exceptions

- Mentions that the OS can move a process's address space by:
  1. Descheduling the process
  2. Copying the address space to new location
  3. Updating saved base register in process structure

Slide 11:
- Shows Figures 15.5 and 15.6 which illustrate hardware/OS interaction:
  * Figure 15.5: What OS does at boot time
  * Figure 15.6: What happens when a process runs (with timeline of events)

- Notes that the approach follows "limited direct execution": OS sets up hardware, lets process run directly, only intervenes when process misbehaves.

Slide 12:
- Summarizes the key points about address translation:
  * OS controls each memory access to ensure it stays within bounds
  * Hardware performs translation quickly (virtual to physical)
  * Process is oblivious to translation (wonderful illusion)

- Notes that base-and-bounds is efficient (only needs a base register) and offers protection (ensures no process accesses outside its address space).

- Points out inefficiency: Internal fragmentation (wasted memory between allocated segments).

- Mentions that segmentation will be discussed next as a more sophisticated approach.

Slide 13:
- References to papers and historical context:
  * [M65]: "On Dynamic Program Relocation" by W.C. McGee
  * [P90]: "Relocating loader for MS-DOS .EXE executable files"
  * [SS74]: "The Protection of Information in Computer Systems" by J. Saltzer and M. Schroeder
  * [S04]: History of system call support
  * [WL+93]: "Efficient Software-based Fault Isolation"
  * [W17]: Answer to footnote about "wreak havoc"

Slide 14:
- Homework simulation details:
  * Program: relocation.py
  * Questions about address translations with base and bounds

Now I'll create comprehensive study notes based on all this information, following the instructions to include EVERY detail without summarizing.

I'll structure the notes with proper markdown formatting, hierarchical headers, and include all examples, figures, and technical details.
</think>

# Week 2: Textbook VM Mechanism - Comprehensive Study Notes

## Chapter Title
**Mechanism: Address Translation**

## Learning Objectives
- Understand the concept of hardware-based address translation for virtual memory
- Learn how base-and-bounds (dynamic relocation) works
- Understand the role of hardware support (base/bounds registers) in memory virtualization
- Analyze the OS responsibilities in implementing address translation
- Recognize the limitations of base-and-bounds and the need for more sophisticated techniques

## Key Concepts and Definitions

### Limited Direct Execution (LDE)
A general mechanism used in virtualization where:
- The program runs directly on hardware for most operations
- The OS interposes at critical points (e.g., system calls, timer interrupts)
- Goal: Balance efficiency (minimize OS involvement) with control (maintain OS oversight)

### Hardware-Based Address Translation
The specific mechanism used to virtualize memory:
- Hardware transforms each memory access (instruction fetch, load, store) from virtual address to physical address
- On every memory reference, an address translation is performed by the hardware
- The goal is to create the illusion that each program has its own private memory

### Base and Bounds (Dynamic Relocation)
A simple technique for implementing address translation:
- Uses two hardware registers: base register and bounds (limit) register
- Address translation: physical address = virtual address + base
- Bounds check: ensures virtual address is within 0 ≤ virtual address < bounds
- Referred to as "dynamic relocation" because relocation happens at runtime

### Memory Management Unit (MMU)
The part of the processor that helps with address translation:
- Contains circuitry for performing translations and checking bounds
- Includes the base and bounds registers
- As memory management techniques become more sophisticated, more circuitry is added to the MMU

### Internal Fragmentation
A type of waste in memory allocation:
- Occurs when allocated memory blocks contain unused space within them
- In base-and-bounds, if the address space is smaller than the allocated physical memory slot, the unused space between the code and data sections is wasted
- Example: Process using memory from 32 KB to 48 KB but only using 32 KB of that space (wasting 16 KB)

### Privileged Mode (Kernel Mode)
A CPU mode where:
- The OS has access to the entire machine
- Can execute privileged operations (e.g., modify base/bounds registers)
- Required for OS to manage memory virtualization

### User Mode
A CPU mode where:
- Applications are limited in what they can do
- Cannot execute privileged operations
- Memory references must be translated by hardware

### Free List
A data structure used by the OS to track free memory:
- A list of ranges of physical memory that are not currently in use
- Simplest data structure for memory allocation tracking

### Process Control Block (PCB)
A data structure used by the OS to track process state:
- Contains saved values of base and bounds registers when a process is not running
- Used during context switches to restore correct memory mapping

### Exception Handling
Mechanism for dealing with illegal operations:
- CPU raises an exception when a user program tries to access memory outside its bounds
- CPU stops executing the user program and runs the OS exception handler
- Common reaction: terminate the offending process

## Detailed Mechanism Explanation

### Address Translation Process
For every memory reference generated by a process:
1. Hardware receives a virtual address from the process
2. Hardware adds the base register value to the virtual address
3. Hardware checks if the resulting physical address is within bounds
4. If within bounds, hardware uses the physical address to access memory
5. If out of bounds, CPU raises an exception (memory access violation)

**Formula for Address Translation:**
```
physical address = virtual address + base
```

### Bounds Register Implementation
The bounds register can be implemented in two equivalent ways:

1. **Bounds as size of address space:**
   - Hardware checks if virtual address is within 0 ≤ virtual address < bounds
   - Then adds base to get physical address
   - Example: Bounds = 16 KB (16384 bytes)

2. **Bounds as physical end address:**
   - Hardware first adds base to virtual address
   - Then checks if resulting physical address is within 0 ≤ physical address < (base + bounds)
   - Example: Base = 32 KB, Bounds = 16 KB → physical address must be < 48 KB

Both methods are logically equivalent; the text assumes the first method.

### Base and Bounds Register Usage Example
Let's trace through an example with a process loaded at physical address 32 KB (32768) with bounds set to 16 KB (16384):

| Virtual Address | Physical Address Calculation | Result |
|----------------|------------------------------|--------|
| 0              | 0 + 32768 = 32768           | 32 KB  |
| 1 KB (1024)    | 1024 + 32768 = 33792        | 33 KB  |
| 3000           | 3000 + 32768 = 35768        | 35 KB  |
| 4400           | 4400 + 32768 = 37168        | Fault (out of bounds) |

*Note: 4400 > 16384 (bounds), so it's out of bounds.*

## Hardware Requirements

### Table: Hardware Requirements for Dynamic Relocation (Figure 15.3)

| Hardware Requirement | Notes |
|----------------------|-------|
| **Privileged mode** | Needed to prevent user-mode processes from executing privileged operations |
| **Base/bounds registers** | Need pair of registers per CPU to support address translation and bounds checks |
| **Ability to translate virtual addresses and check if within bounds** | Circuitry to do translations and check limits; in this case, quite simple |
| **Privileged instruction(s) to update base/bounds** | OS must be able to set these values before letting a user program run |
| **Privileged instruction(s) to register exception handlers** | OS must be able to tell hardware what code to run if exception occurs |
| **Ability to raise exceptions** | When processes try to access privileged instructions or out-of-bounds memory |

### Important Notes on Hardware
- Base and bounds registers are hardware structures kept on the chip (one pair per CPU)
- User processes cannot change the base and bounds registers (would cause havoc)
- If a user process tries to modify base/bounds registers, CPU raises an exception and runs "tried to execute privileged operation while in user mode" handler
- CPU must provide a way to inform it of the location of exception handlers

## Operating System Responsibilities

### Table: OS Responsibilities for Dynamic Relocation (Figure 15.4)

| OS Requirement | Notes |
|----------------|-------|
| **Memory management** | Need to allocate memory for new processes; reclaim memory from terminated processes; generally manage memory via free list |
| **Base/bounds management** | Must set base/bounds properly upon context switch |
| **Exception handling** | Code to run when exceptions arise; likely action is to terminate offending process |

### Detailed OS Responsibilities

#### 1. Process Creation
- When a process is created, the OS must find space for its address space in memory
- Given assumptions (each address space is smaller than physical memory and same size), this is simple
- OS views physical memory as an array of slots
- Uses a free list to track which slots are free or in use
- When new process is created, OS searches free list for room and marks it used

*Example from Figure 15.2:*
- OS uses first slot (0-16 KB) for itself
- Process relocated into slot starting at 32 KB (32-48 KB)
- Free slots: 16-32 KB and 48-64 KB
- Free list consists of these two entries

#### 2. Process Termination
- When a process is terminated (exits gracefully or killed due to misbehavior), OS must reclaim all its memory
- OS puts the process's memory back on the free list
- Cleans up any associated data structures

#### 3. Context Switching
- Only one base and bounds register pair exists per CPU
- Values differ for each running program (each loaded at different physical address)
- During context switch:
  - When stopping a process, OS saves base/bounds values to memory (in process structure/PCB)
  - When resuming a process, OS sets base/bounds registers to correct values for that process

*Process relocation example:*
- To move a process's address space:
  1. Deschedule the process
  2. Copy the address space from current location to new location
  3. Update saved base register (in process structure) to point to new location
- When process is resumed, its (new) base register is restored

#### 4. Exception Handling
- OS must provide exception handlers for various illegal operations
- At boot time, OS installs these handlers via privileged instructions
- Common exceptions:
  - Out-of-bounds memory access
  - Attempt to execute privileged instruction in user mode
- Typical OS reaction: terminate the offending process
- OS is highly protective of the machine it's running

## Example: Memory Access Sequence

### C Code Example
```c
void func() {
    int x = 3000; // thanks, Perry.
    x = x + 3; // line of code we are interested in
}
```

### Assembly Code (x86)
```
128: movl 0x0(%ebx), %eax ;load 0+ebx into eax
132: addl $0x03, %eax ;add 3 to eax register
135: movl %eax, 0x0(%ebx) ;store eax back to mem
```

### Memory Access Sequence (from process perspective)
1. Fetch instruction at address 128
2. Execute instruction (load from address 15 KB)
3. Fetch instruction at address 132
4. Execute instruction (no memory reference)
5. Fetch instruction at address 135
6. Execute instruction (store to address 15 KB)

*Note: Figure 15.1 shows the process's address space layout with code at 128 and variable x at 15 KB.*

## Timeline of Hardware/OS Interaction

### Figure 15.5: Limited Direct Execution (Dynamic Relocation) @ Boot
```
OS @ boot Hardware (No Program Yet)
(kernel mode)
initialize trap table
remember addresses of...
system call handler
timer handler
illegal mem-access handler
illegal instruction handler
start interrupt timer
start timer; interrupt after X ms
initialize process table
initialize free list
```

### Figure 15.6: Limited Direct Execution (Dynamic Relocation) @ Runtime
```
OS @ run Hardware Program
(kernel mode) (user mode)
To start process A:
allocate entry
in process table
alloc memory for process
set base/bound registers
return-from-trap (into A)
restore registers of A
move to user mode
jump to A's (initial) PC
Process A runs
Fetch instruction
translate virtual address
perform fetch
Execute instruction
if explicit load/store:
ensure address is legal
translate virtual address
perform load/store
(A runs...)
Timer interrupt
move to kernel mode
jump to handler
Handle timer
decide: stop A, run B
call switch() routine
save regs(A)
to proc-struct(A)
(including base/bounds)
restore regs(B)
from proc-struct(B)
(including base/bounds)
return-from-trap (into B)
restore registers of B
move to user mode
jump to B's PC
Process B runs
Execute bad load
Load is out-of-bounds;
move to kernel mode
jump to trap handler
Handle the trap
decide to kill process B
deallocate B's memory
free B's entry
in process table
```

## Key Principles and Insights

### Interposition is Powerful
- Interposition is a generic and powerful technique used in computer systems
- In virtualizing memory, hardware interposes on each memory access, translating virtual addresses to physical addresses
- Benefits: Transparency (interposition done without changing client interface)

### Why Base and Bounds Works
- Provides both efficiency and control:
  - Efficiency: Only requires a base register addition and bounds check
  - Control: Ensures no process can generate memory references outside its own address space

### Protection is Critical
- Without protection, processes could overwrite memory (including OS structures)
- Example: Processes could overwrite the trap table and take over the system
- Protection is one of the most important goals of the OS

### Limitations of Base and Bounds
- **Internal fragmentation**: Wasted memory within allocated blocks
  - Example: Process using memory from 32 KB to 48 KB but only using 32 KB of that space (wasting 16 KB)
  - This happens because the process must be placed in a fixed-size slot
- **Inflexibility**: Address space must be contiguous in physical memory
- **Fixed size**: All address spaces must be the same size

## Historical Context and References

### Key Papers and References
- [M65] "On Dynamic Program Relocation" by W.C. McGee. IBM Systems Journal, Volume 4:3, 1965, pages 184–199.
  - Summary of early work on dynamic relocation and basics on static relocation.

- [P90] "Relocating loader for MS-DOS .EXE executable files" by Kenneth D. A. Pillay. Microprocessors & Microsystems archive, Volume 14:7 (September 1990).
  - Example of a relocating loader for MS-DOS.

- [SS74] "The Protection of Information in Computer Systems" by J. Saltzer and M. Schroeder. CACM, July 1974.
  - Quote: "The concepts of base-and-bound register and hardware-interpreted descriptors appeared, apparently independently, between 1957 and 1959 on three projects with diverse goals. At M.I.T., McCarthy suggested the base-and-bound idea as part of the memory protection system necessary to make time-sharing feasible. IBM independently developed the base-and-bound register as a mechanism to permit reliable multiprogramming of the Stretch (7030) computer system. At Burroughs, R. Barton suggested that hardware-interpreted descriptors would provide direct support for the naming scope rules of higher level languages in the B5000 computer system."

- [S04] "System Call Support" by Mark Smotherman. May 2004. people.cs.clemson.edu/~mark/syscall.html.
  - History of system call support.

- [WL+93] "Efficient Software-based Fault Isolation" by Robert Wahbe, Steven Lucco, Thomas E. Anderson, Susan L. Graham. SOSP '93.
  - Paper about using compiler support to bound memory references without hardware support.

- [W17] Answer to footnote: "Is there anything other than havoc that can be wreaked?" by Waciuma Wanjohi. October 2017.
  - Finding: "It's only since about 1970 that 'wreak havoc' has been more popular than 'wreak vengeance'. In the 1800s, the word wreak was almost always followed by 'his/their vengeance'."

## Homework Simulation Details

### Program: relocation.py
Allows you to see how address translations are performed in a system with base and bounds registers.

### Questions to Answer:
1. **Run with seeds 1, 2, and 3, and compute whether each virtual address generated by the process is in or out of bounds. If in bounds, compute the translation.**
   - Example: For seed 1, you'll get a sequence of virtual addresses; for each, determine if it's within bounds (0 ≤ virtual address < bounds) and if so, calculate physical address = virtual address + base.

2. **Run with these flags: -s 0 -n 10. What value do you have to set -l (the bounds register) to in order to ensure that all the generated virtual addresses are within bounds?**
   - This asks for the minimum bounds value needed to cover all virtual addresses generated by the simulation.

3. **Run with these flags: -s 1 -n 10 -l 100. What is the maximum value that base can be set to, such that the address space still fits into physical memory in its entirety?**
   - This asks for the maximum base value where (base + bounds) ≤ physical memory size.

4. **Run some of the same problems above, but with larger address spaces (-a) and physical memories (-p).**
   - Experiment with different sizes to understand how base and bounds interact with physical memory.

5. **What fraction of randomly-generated virtual addresses are valid, as a function of the value of the bounds register? Make a graph from running with different random seeds, with limit values ranging from 0 up to the maximum size of the address space.**
   - This asks for a statistical analysis of how bounds register value affects valid address rate.

## Comprehensive Summary

### Address Translation Mechanism
- Hardware-based address translation transforms virtual addresses (generated by processes) into physical addresses (where data actually resides)
- This is done on every memory reference (instruction fetch, load, store)
- The hardware alone cannot virtualize memory; the OS must set up the hardware for correct translations

### Base and Bounds Implementation
- Uses two hardware registers:
  - **Base register**: Starting physical address of process's address space
  - **Bounds register**: Size of address space (or end address)
- Address translation: physical address = virtual address + base
- Bounds check: ensures virtual address is within 0 ≤ virtual address < bounds
- If out of bounds, CPU raises an exception

### Hardware Support Requirements
1. **Privileged mode**: To prevent user processes from executing privileged operations
2. **Base/bounds registers**: One pair per CPU
3. **Translation circuitry**: To perform address translation and bounds checks
4. **Privileged instructions**: To update base/bounds registers (only available in kernel mode)
5. **Exception handling**: To handle illegal memory access or privileged instruction execution

### OS Responsibilities
1. **Memory management**: Track free memory using a free list, allocate for new processes, reclaim on termination
2. **Base/bounds management**: Save and restore base/bounds values during context switches
3. **Exception handling**: Install handlers for memory access violations and privileged instruction attempts

### Advantages of Base and Bounds
- **Efficiency**: Only requires a simple addition and bounds check
- **Protection**: Ensures no process can access memory outside its address space
- **Transparency**: Process is oblivious to address translation (wonderful illusion)

### Limitations of Base and Bounds
- **Internal fragmentation**: Wasted memory within allocated blocks (e.g., 16 KB wasted in Figure 15.2)
- **Contiguous allocation**: Address space must be placed contiguously in physical memory
- **Fixed size**: All address spaces must be the same size

### Future Direction
- To overcome limitations of base and bounds, more sophisticated techniques like segmentation will be introduced
- These techniques aim to better utilize physical memory and avoid internal fragmentation

## Review Questions

1. What is the main goal of limited direct execution in virtualization?
2. How does hardware-based address translation work?
3. Explain the formula for address translation using base and bounds.
4. What are the two ways to implement the bounds register, and why are they equivalent?
5. Why can't user processes modify the base and bounds registers?
6. Describe the process of relocating a process's address space in memory.
7. What is internal fragmentation, and how does it occur in base-and-bounds?
8. What are the hardware requirements for implementing dynamic relocation?
9. What are the OS responsibilities when a process is created, terminated, or during context switching?
10. How does the CPU handle an out-of-bounds memory access?