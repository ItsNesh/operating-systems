<!-- 
Generated by LectureQ (Enhanced Comprehensive Version)
Date: 2025-09-03 05:00:25
Model: qwen3:30b
Output Mode: Comprehensive
-->

<think>
I need to create comprehensive study notes based on a textbook chapter about "Threads Locks" (Week 5). I'll follow the instructions carefully:

1. Extract ALL concepts from the slides provided.
2. Provide detailed explanations of all topics.
3. Define important terms with full context.
4. Include every example with detailed explanations.
5. Focus on complete mastery for exams and deep learning.

Let me organize this into a comprehensive study guide in markdown format, following the formatting requirements:

- Hierarchical headers
- Bold key terms/concepts
- Tables for comparisons where appropriate
- All formulas/processes included
- Comprehensive summary sections
- 15-20 study questions

First, I'll identify all major concepts from these slides to structure my notes.

From reviewing the textbook content (Slides 1 through 22), here are the key topics covered:

1. Introduction to locks and their purpose in concurrent programming
2. Basic lock semantics: lock() and unlock()
3. Pthread Locks (mutexes)
4. Building a lock - hardware support needed
5. Evaluating locks (mutual exclusion, fairness, performance)
6. Controlling interrupts as an early solution (with limitations)
7. Failed attempt using simple loads/stores
8. Test-and-set instruction for building spin locks
9. Peterson's algorithm and Dekker's algorithm (as historical context)
10. Compare-and-swap instruction
11. Load-linked/Store-conditional instructions
12. Fetch-and-add instruction with ticket lock example
13. Problems with spinning: too much CPU waste, priority inversion
14. Approaches to avoid unnecessary spinning:
    - Yielding (simple approach)
    - Using queues/sleeping instead of spinning
15. OS support for locks (Solaris park/unpark vs Linux futexes)
16. Two-phase lock concept

Now I'll create detailed notes covering all these concepts, with examples and explanations.

Let me structure this into comprehensive study notes:
</think>

# Week 5: Threads Locks - Comprehensive Study Notes

## Introduction to Locks in Concurrent Programming

### Core Problem of Concurrency
- **Fundamental problem**: Ensuring a series of instructions executes *atomically* (as if it were a single instruction) despite potential interruptions from other threads or processors.
  
> "We would like to execute a series of instructions atomically, but due to the presence of interrupts on a single processor (or multiple threads executing on multiple processors concurrently), we couldn't."

### What is a Lock?
- A **lock** is a synchronization primitive that ensures only one thread can access a critical section at any given time.
- Programmers annotate source code with locks around *critical sections* to guarantee atomic execution.

> "Programmers annotate source code with locks, putting them around critical sections, and thus ensure that any such critical section executes as if it were a single atomic instruction."

### Basic Lock Semantics
```c
lock_t mutex; // Globally allocated lock

// Critical Section:
lock(&mutex);
balance = balance + 1;
unlock(&mutex);
```

- **Lock state** can be either:
  - *Available* (unlocked/free): No thread holds the lock.
  - *Acquired* (locked/held): Exactly one thread holds the lock and is in a critical section.

> "The semantics of the `lock()` and `unlock()` routines are simple. Calling the routine `lock()` tries to acquire the lock; if no other thread holds the lock... it will acquire the lock and enter the critical section."

### POSIX Implementation (Mutexes)
- In POSIX threads, locks are called **mutexes** (mutual exclusion).
  
```c
pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;

Pthread_mutex_lock(&lock); // Wrapper; exits on failure
balance = balance + 1;
Pthread_mutex_unlock(&lock);
```

> "The name that the POSIX library uses for a lock is a mutex, as it is used to provide mutual exclusion between threads..."

### Key Benefits of Locks
- **Mutual Exclusion**: Ensures only one thread executes in critical section at any time.
- **Control over Scheduling**: Programmers can guarantee no more than single thread active within code block.

> "Locks help transform the chaos that is traditional OS scheduling into a more controlled activity."

---

## Evaluating Lock Implementations

### Three Key Criteria for Evaluation
| Criterion | Description |
|-----------|-------------|
| **Mutual Exclusion** | Does the lock prevent multiple threads from entering critical section? (Basic requirement) |
| **Fairness** | Do all waiting threads get a fair chance to acquire the lock? No starvation allowed. |
| **Performance** | Time overheads added by using the lock in different scenarios: <br> - Single thread with no contention<br> - Multiple threads on single CPU<br> - Multiple CPUs involved |

---

## Historical Approaches and Their Limitations

### 1. Disabling Interrupts (Single-Processor Only)
```c
void lock() {
    DisableInterrupts();
}

void unlock() {
    EnableInterrupts();
}
```

**Pros**: Simple to understand.

**Cons**:
| Issue | Explanation |
|-------|-------------|
| **Trust Requirement** | Requires trusting arbitrary programs with privileged operations (interrupt control) |
| **No Multiprocessor Support** | Doesn't work on multiple processors - threads can run concurrently on different CPUs |
| **Interrupt Loss Risk** | Extended interrupt disabling could cause lost interrupts, leading to system problems |

> "Using interrupt disabling as a general-purpose synchronization solution requires too much trust in applications."

### 2. Simple Flag Approach (Failed Attempt)
```c
typedef struct __lock_t { int flag; } lock_t;

void init(lock_t *mutex) {
    mutex->flag = 0;
}

void lock(lock_t *mutex) {
    while (mutex->flag == 1); // Spin-wait
    mutex->flag = 1;
}

void unlock(lock_t *mutex) {
    mutex->flag = 0;
}
```

**Correctness Problem**: 
- **Race condition** occurs when interrupts happen at critical moments:
  
> "With timely (untimely?) interrupts, we can easily produce a case where both threads set the flag to 1 and both threads are thus able to enter the critical section."

*Example trace showing failure:*
| Thread 1 | Thread 2 |
|----------|----------|
| call lock() | call lock() |
| while (flag == 1) | while (flag == 1) |
| interrupt → switch to T2 | flag = 1; (too!) |

**Performance Problem**: **Spin-waiting** wastes CPU cycles waiting for a lock.

> "The performance problem... is the fact that the way a thread waits to acquire a lock that is already held: it endlessly checks the value of flag, a technique known as spin-waiting."

---

## Hardware-Based Locks

### Test-and-Set Instruction
```c
int TestAndSet(int *old_ptr, int new) {
    int old = *old_ptr;
    *old_ptr = new;
    return old;
}
```

**Key Property**: The operation is **atomic** (test and set happen as a single indivisible instruction).

### Spin Lock Using Test-and-Set
```c
typedef struct __lock_t { int flag; } lock_t;

void init(lock_t *lock) {
    lock->flag = 0;
}

void lock(lock_t *lock) {
    while (TestAndSet(&lock->flag, 1) == 1); // Spin-wait until acquired
}

void unlock(lock_t *lock) {
    lock->flag = 0;
}
```

**Why it works**: 
- When flag is 0: `TestAndSet` returns 0 → thread acquires lock.
- When flag is 1 (held): `TestAndSet` keeps returning 1 → spins until released.

> "By making both the test of the old lock value and set of the new value a single atomic operation, we ensure that only one thread acquires the lock."

### Peterson's Algorithm (Historical Context)
```c
int flag[2];
int turn;

void init() {
    flag[0] = flag[1] = 0;
    turn = 0;
}

void lock() {
    flag[self] = 1;
    turn = 1 - self;
    while ((flag[1-self] == 1) && (turn == 1 - self));
}

void unlock() {
    flag[self] = 0;
}
```

**Key Insight**: 
- Uses `flag` to indicate intent and `turn` to determine whose turn it is.
- **Does not work on modern hardware** due to relaxed memory consistency models.

> "Algorithms like the ones above don't work on modern hardware (due to relaxed memory consistency models), thus making them even less useful than they were before."

---

## Advanced Hardware Primitives

### Compare-and-Swap
```c
int CompareAndSwap(int *ptr, int expected, int new) {
    int original = *ptr;
    if (original == expected)
        *ptr = new;
    return original;
}
```

**Usage for Lock:**
```c
void lock(lock_t *lock) {
    while (CompareAndSwap(&lock->flag, 0, 1) == 1);
}
```

> "Compare-and-swap is a more powerful instruction than test-and-set... If we just build a simple spin lock with it, its behavior is identical to the spin lock we analyzed above."

### Load-Linked / Store-Conditional
**MIPS Architecture Example:**
```c
int LoadLinked(int *ptr) { return *ptr; }

int StoreConditional(int *ptr, int value) {
    if (no update since LL) {
        *ptr = value;
        return 1;
    } else {
        return 0;
    }
}
```

**Lock Implementation:**
```c
void lock(lock_t *lock) {
    while (LoadLinked(&lock->flag) || 
           !StoreConditional(&lock->flag, 1));
}

void unlock(lock_t *lock) {
    lock->flag = 0;
}
```

> "Only one of these threads will succeed in updating the flag to 1 and thus acquire the lock; the second thread... will fail (because the other thread updated the value)..."

---

## Ticket Locks: A Fairer Approach

### Concept
- Uses **ticket** for ordering access.
- Each thread gets a "turn" number when requesting the lock.
- Thread enters critical section only when its turn matches `lock->turn`.

```c
typedef struct __lock_t {
    int ticket;
    int turn;
} lock_t;

void lock_init(lock_t *lock) {
    lock->ticket = 0;
    lock->turn = 0;
}

void lock(lock_t *lock) {
    int myturn = FetchAndAdd(&lock->ticket);
    while (lock->turn != myturn); // Spin until it's your turn
}

void unlock(lock_t *lock) {
    lock->turn++;
}
```

**Key Benefit**: 
- **Fairness guarantee**: Once a thread gets its ticket, it will eventually get to enter the critical section.
  
> "Note one important difference with this solution versus our previous attempts: it ensures progress for all threads."

---

## Problems With Spin Locks

### Performance Issues
| Scenario | Problem |
|----------|---------|
| **Single CPU** | If thread holding lock is preempted, other threads spin wasting entire time slices. <br> *Example*: 99 threads spinning = 99 wasted time slices. |
| **Multiple CPUs** | Spinning on another processor can be efficient if critical section short (wastes few cycles). |

### Priority Inversion
- **Problem**: High-priority thread waiting for lock held by low-priority thread.
  
> "Imagine three threads, T1, T2, and T3, with T3 at the highest priority... If T2 starts to run, it will have higher priority than T1, and thus it will run. T3, which is higher priority than T2, is stuck waiting for T1..."

**Solutions**:
- Avoid spin locks (use sleeping instead)
- **Priority inheritance**: Temporarily boost lower-priority thread's priority
- Ensure all threads same priority

---

## Advanced Lock Implementations: Beyond Spinning

### Approach 1: Yielding Instead of Spinning
```c
void lock() {
    while (TestAndSet(&flag, 1) == 1)
        yield(); // Give up CPU to other thread
}
```

**Pros**: Better than spinning on single processor.

**Cons**:
- **Costly context switches**: Each `yield` causes a full context switch.
- **Starvation possible**: Thread may get caught in endless yield loop while others repeatedly enter/exit critical section.

> "This approach is still costly; the cost of a context switch can be substantial, and there is thus plenty of waste."

### Approach 2: Queues with Sleeping (Solaris)
```c
typedef struct __lock_t {
    int flag;
    int guard;
    queue_t *q;
} lock_t;

void lock(lock_t *m) {
    while (TestAndSet(&m->guard, 1));
    if (m->flag == 0) {
        m->flag = 1;
        m->guard = 0;
    } else {
        queue_add(m->q, gettid());
        m->guard = 0;
        park(); // Sleep until woken up
    }
}

void unlock(lock_t *m) {
    while (TestAndSet(&m->guard, 1));
    if (queue_empty(m->q))
        m->flag = 0; 
    else
        unpark(queue_remove(m->q)); // Wake next thread
    m->guard = 0;
}
```

**Key Features**:
- Uses `park()` to sleep and `unpark(threadID)` to wake threads.
- **Guard variable**: Spin-lock around flag/queue operations (minimizes spin time).
- Solves starvation problem by explicitly controlling who gets the lock next.

> "The real problem with some previous approaches... is that they leave too much to chance."

### Approach 3: Linux Futexes
```c
void mutex_lock(int *mutex) {
    int v;
    if (atomic_bit_test_set(mutex, 31) == 0)
        return; // Fast path - no contention
    
    atomic_increment(mutex);
    while (1) {
        if (atomic_bit_test_set(mutex, 31) == 0) {
            atomic_decrement(mutex);
            return;
        }
        v = *mutex;
        if (v >= 0) continue;
        futex_wait(mutex, v);
    }
}
```

**Key Insight**: 
- Uses a single integer to track both lock status and number of waiters.
- **Two-phase approach**: Spins briefly before sleeping.

> "The Linux approach has the flavor of an old approach... referred to as a two-phase lock."

---

## Two-Phase Locks

### Concept
1. **First phase (spin)**: Spin for short period, hoping to acquire lock quickly if it's about to be released.
2. **Second phase**: If not acquired during spin phase, sleep until woken up.

**Why It Works Well**:
> "Two-phase locks are yet another instance of a hybrid approach, where combining two good ideas may indeed yield a better one."

---

## Summary: Modern Lock Implementation

### Key Components
| Component | Description |
|-----------|-------------|
| **Hardware Support** | Atomic instructions (test-and-set, compare-and-swap) for building basic locks. |
| **OS Support** | `park()`/`unpark()` or futexes to sleep/wake threads efficiently. |
| **Design Trade-offs** | Balance between fairness, performance, and starvation prevention. |

> "The above approach shows how real locks are built these days: some hardware support (in the form of a more powerful instruction) plus some operating system support..."

---

## Key Concepts & Definitions

### Core Terminology
- **Critical Section**: Code that accesses shared data; must be executed atomically.
- **Mutual Exclusion**: Only one thread can execute in critical section at any time.
- **Spin-Waiting (Spinning)**: Thread repeatedly checks lock status without yielding CPU.
- **Fairness**: Guarantee all threads get a chance to acquire the lock eventually.
- **Starvation**: A waiting thread never gets access to resource due to scheduling decisions.
- **Priority Inversion**: High-priority thread blocked by low-priority thread holding lock.

### Lauer's Law
> "If the same people had twice as much time, they could produce as good of a system in half the code." [L81]

**Implication for Lock Design**: Shorter, more concise implementations are preferable (less bugs, easier to understand).

---

## Comparative Analysis: Lock Types

| Type | Hardware Support Needed | Fairness Guarantee? | Performance on Single CPU | Multiprocessor Support |
|------|-------------------------|--------------------|----------------------------|------------------------|
| Interrupt Disabling | None | No | Poor (no multiprocessor) | ❌ Not supported |
| Simple Flag | Basic loads/stores | No | Very poor (spinning waste) | ✅ But incorrect |
| Test-and-Set Spin Lock | Atomic test-and-set | No | Poor (wastes CPU cycles) | ✅ Supported |
| Ticket Lock | Fetch-and-add | Yes | Moderate (fair but spins) | ✅ Supported |
| Queue-Based Sleep Lock | None (OS support needed) | Yes | Good (no spinning waste) | ✅ Supported |

---

## Study Questions

1. What is the fundamental problem that locks solve in concurrent programming?
2. Explain why a simple flag-based lock implementation fails to provide mutual exclusion.
3. Describe how test-and-set instruction works and why it enables building correct spin locks.
4. Why does Peterson's algorithm not work on modern hardware? 
5. How do ticket locks ensure fairness compared to basic spin locks?
6. What is priority inversion, and what are three ways to address it in lock implementations?
7. Explain the difference between a "spin-wait" approach versus an OS-based sleeping approach for waiting threads.
8. Why does disabling interrupts work only on single-processor systems but not multiprocessors?
9. Describe how compare-and-swap differs from test-and-set and why one might be preferred over the other in certain scenarios.
10. What is a futex, and how does it enable efficient lock implementation in Linux?
11. Explain what "two-phase locking" means and provide an example of where this approach would improve performance.
12. Why are short implementations (Lauer's Law) particularly important for synchronization primitives like locks?
13. How do Solaris' `park()`/`unpark()` functions solve the starvation problem that basic spin locks face?
14. What is a "wakeup/waiting race" and how does Solaris address it with its `setpark()` function?
15. In what scenarios would you prefer using a ticket lock over a simple test-and-set spin lock, even though both provide mutual exclusion?
16. How do load-linked/store-conditional instructions work together to build atomic operations without requiring special hardware support beyond these two primitives?
17. What are the three main criteria for evaluating locks? Explain why each is important.
18. Describe a scenario where a simple spin lock would be more efficient than an OS-based sleeping lock, and explain why this might happen.
19. How does Linux's futex implementation optimize for common cases (no contention)?
20. Why do modern operating systems typically avoid using spin locks in their own kernel data structures?

---

## Key Takeaways

- **Locks are essential** for ensuring mutual exclusion in concurrent programming.
- **Hardware support is necessary**: Atomic instructions like test-and-set, compare-and-swap, and load-linked/store-conditional enable correct lock implementation.
- **OS support improves efficiency**: Park/unpark or futexes allow threads to sleep instead of spinning when waiting for a lock.
- **Fairness matters**: Simple spin locks can lead to starvation; ticket locks provide fairness guarantees.
- **Performance trade-offs exist** between spinning (low latency) and sleeping (less CPU waste).
- **Priority inversion is a serious issue**, requiring careful design in real-time systems.

> "Locks help transform the chaos that is traditional OS scheduling into a more controlled activity."